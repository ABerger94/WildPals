<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>Wild Pals — v13 (cheat codes & enhancements)</title>
<style>
  :root{
    --bg:#0b1020; --panel:#11182c; --ink:#e9f1ff; --muted:#9fb3d1; --accent:#4da3ff; --headerH:56px;
    --padPanel:rgba(13,20,40,.6); --padEdge:#28407e; --padGlass:rgba(255,255,255,.06);
    --btnA:#2d7fff; --btnB:#37b24d; --btnStart:#ff4d4d;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial}
  header{padding:10px 14px;background:#0a1226;position:sticky;top:0;z-index:300;border-bottom:1px solid #1f2d54}
  header h1{margin:0;font-size:18px;letter-spacing:.3px}
  header small{color:var(--muted)}
  .wrap{max-width:1200px;margin:0 auto;padding:10px}

  #uiToggles{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
  .toggle{background:#122043;color:var(--ink);border:1px solid #28407e;border-radius:8px;padding:8px 10px;font-weight:600;cursor:pointer}
  .toggle[aria-pressed="true"]{outline:2px solid var(--accent)}

  #hudBar{display:none; gap:8px; flex-wrap:wrap; margin:8px 0 10px 0}
  .chip{background:rgba(0,0,0,.6);border:1px solid #2b3b69;border-radius:6px;padding:4px 8px;font-size:12px;color:#cfe0ff}

  #canvasBox{background:#000;border:2px solid #1f2d54;border-radius:8px;position:relative;overflow:hidden}
  /* Expand the game canvas to fill available horizontal space on desktop.  The
     intrinsic resolution remains 960×528, but CSS scaling allows it to
     stretch to the width of its container without leaving empty space. */
  canvas#game{width:100%;height:auto;image-rendering:pixelated;background:#20314f;display:block;}
  canvas#minimap{width:132px;height:132px;border:1px solid #2b3b69;background:#071023;border-radius:4px;}
  /* Minimap container: default display is block on narrow screens.  We'll override on desktop. */
  #minimapContainer{
    display:block;
    margin-bottom:0;
  }

  /* Game row groups the canvas and minimap.  On mobile it defaults to block (vertical stacking).  On desktop it becomes
     a horizontal flex container via a media query below. */
  #gameRow{
    display:block;
  }
  #hud{position:absolute;left:8px;top:8px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;max-width:min(70%, 520px);z-index:95}

  /* BELOW THE DISPLAY: CTA + status */
  #belowBar{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:8px 10px;background:#0a1226;border:1px solid #1f2d54;border-top:none;border-radius:0 0 8px 8px}
  .cta{background:#0b132a;border:1px solid #28407e;border-radius:8px;padding:6px 10px;font-weight:700}
  #debug{font:12px/1.4 monospace;color:#cfe0ff;opacity:0.9;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  /* ===== GameBoy-style mobile controls ===== */
  #padDock{display:flex;justify-content:center;margin-top:10px; padding-bottom:max(8px, env(safe-area-inset-bottom, 0px));}
  #mobileControls{
    display:grid;
    grid-template-columns: 120px 1fr 160px;
    grid-template-rows: auto auto;
    gap:12px;
    background:linear-gradient(180deg, var(--padPanel), rgba(10,18,38,0.85));
    border:1px solid var(--padEdge); border-radius:16px;
    box-shadow:0 10px 22px rgba(0,0,0,.4); padding:14px; width:min(100%, 720px);
    backdrop-filter: blur(4px);
  }
  /* Enlarged D-pad for easier touch interaction */
  .dpad{grid-column:1;grid-row:1 / span 2; width:160px; height:160px; position:relative; margin:auto;
        background:#101826; border-radius:16px; border:1px solid #192a4e; box-shadow:inset 0 6px 14px rgba(0,0,0,.5)}
  .dpad .cross{position:absolute; inset:0; margin:auto; width:120px; height:120px; background:#1a2336; border-radius:14px}
  .dpad .cross::before,.dpad .cross::after{content:""; position:absolute; background:#1a2336; border-radius:12px}
  .dpad .cross::before{left:0; right:0; top:50%; height:40px; transform:translateY(-50%)}
  .dpad .cross::after{top:0; bottom:0; left:50%; width:40px; transform:translateX(-50%)}
  /* Directional buttons enlarged for easier tapping (approx. double original size) */
  .dpad button{position:absolute; width:64px; height:64px; background:#0f1726; border:1px solid #2a3b64;
               border-radius:14px; color:#9fb3d1; font-weight:900; font-size:20px}
  .dpad button:active{transform:translateY(1px)}
  #btnUp{left:50%; top:6px; transform:translateX(-50%)}
  #btnDown{left:50%; bottom:6px; transform:translateX(-50%)}
  #btnLeft{left:6px; top:50%; transform:translateY(-50%)}
  #btnRight{right:6px; top:50%; transform:translateY(-50%)}

  .actCluster{grid-column:3;grid-row:1; width:160px; height:140px; position:relative; margin:auto}
  .actCluster .btn{position:absolute; width:64px; height:64px; border-radius:999px; border:1px solid #1b2a52;
                   color:#e9f1ff; font-weight:800; font-size:18px; box-shadow:inset 0 8px 18px rgba(0,0,0,.45)}
  #btnA{background:var(--btnA); right:8px; top:10px}
  #btnB{background:var(--btnB); left:18px; bottom:8px}
  /* Position start row under the action buttons (column 3) for more room */
  .startRow{grid-column:3; grid-row:2; display:flex; justify-content:center; gap:14px; align-items:center}
  .startRow .tiny{min-width:auto; width:80px; height:36px; border-radius:999px; background:var(--btnStart); border:1px solid #4b1d1d; color:white; font-weight:800}

  /* General button defaults for desktop UI buttons */
  button,select{background:#122043;color:var(--ink);border:1px solid #28407e;border-radius:8px;padding:8px 10px;font-weight:600;cursor:pointer}
  button:hover{filter:brightness(1.08)} button:active{transform:translateY(1px)}
  .pill{font-size:12px;padding:3px 8px;border-radius:999px;border-color:#3558ad}

  /* Sidebars */
  .sidebar{position:fixed;top:calc(var(--headerH) + env(safe-area-inset-top, 0px)); bottom:0;width:360px;max-width:85vw;background:var(--panel);
           border-left:1px solid #1f2d54;border-right:1px solid #1f2d54;z-index:350;transform:translateX(100%);transition:transform .25s ease;overflow:auto}
  .sidebar.left{left:0;transform:translateX(-100%)} .sidebar.right{right:0}
  .sidebar.open.right{transform:translateX(0)} .sidebar.open.left{transform:translateX(0)}
  .sidebar header.sbHead{position:sticky;top:0;background:#0f1730;border-bottom:1px solid #1f2d54;display:flex;align-items:center;justify-content:space-between;padding:8px 10px;z-index:1}
  .sidebar header.sbHead h2{margin:0;font-size:16px}
  .sbClose{background:#172647;border:1px solid #28407e;color:var(--ink);border-radius:8px;padding:6px 10px;font-weight:700;cursor:pointer}
  .panel{padding:10px}
  .note{font-size:12px;color:var(--muted)}
  .row{display:flex;gap:8px;flex-wrap:wrap}

  #inventoryGrid_sb{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
  .card{background:#0e1731;border:1px solid #213062;border-radius:8px;padding:8px}
  #journalGrid_sb{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
  .dex{background:#0e1731;border:1px solid #213062;border-radius:8px;padding:8px; text-align:center}
  .dex .name{font-size:12px;margin-top:4px;color:#cfe0ff}
  .dex.locked .name{color:#5a6985} .dex.locked canvas{filter:grayscale(100%) brightness(0.6)}
  #questBox_sb{background:#0e1731;border:1px solid #213062;border-radius:8px;padding:8px; font-size:13px;margin:10px}

  #scrim{position:fixed;inset:calc(var(--headerH) + env(safe-area-inset-top, 0px)) 0 0 0;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);
         z-index:340;display:none}
  #scrim.open{display:block}

  /* Hide mobile controls on large screens and configure the desktop HUD layout */
  @media(min-width:831px){
    #mobileControls{display:none}
    /* Arrange the game shell horizontally: HUD on the left, game area on the right. */
    #gameShell{
      display:flex;
      align-items:flex-start;
      gap:16px;
    }
    /* Show the HUD as a vertical sidebar on the left.  Remove absolute positioning and stack chips vertically. */
    #hud{
      position:static;
      display:flex;
      flex-direction:column;
      gap:8px;
      width:220px;
      margin:0;
    }
    /* The game area occupies the remaining space and stacks its children vertically. */
    #gameArea{
      display:flex;
      flex-direction:column;
      flex-grow:1;
    }

    /* On desktop, arrange the canvas and minimap side by side in a row to reduce vertical height. */
    #gameRow{
      display:flex;
      align-items:flex-start;
      gap:16px;
    }
    /* Allow the game canvas to expand and fill the available horizontal space. */
    #canvasBox{
      flex-grow:1;
    }
    /* Ensure the minimap container sits next to the canvas rather than above it. */
    #minimapContainer{
      display:flex;
      justify-content:flex-start;
      margin-bottom:0;
    }
    /* Chips retain their compact styling on desktop */
    #hud .chip{
      display:flex;
      align-items:flex-start;
      justify-content:flex-start;
      padding:2px 4px;
      font-size:11px;
      white-space:normal;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    /* Multi-line groups for desktop HUD */
    #hud .ability-group, #hud .petsdisc-group{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      justify-content:flex-start;
      white-space:normal;
      font-size:11px;
      line-height:1.1;
      padding:2px 4px;
    }
    #hud .sprite-chip{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:2px;
    }
    /* Keep desktop minimap visible; hide the mobile minimap chip */
    #hudBar .minimap-chip{ display:none; }
    /* Align the minimap container next to the canvas rather than above it */
    #minimapContainer{ display:flex; justify-content:flex-start; margin-bottom:0; }
  }
  /* Mobile HUD tweaks */
  @media(max-width:830px){
    /* Hide the large minimap container on mobile to avoid duplicating the minimap (the small
       minimap appears in the HUD bar instead). */
    #minimapContainer{
      display:none;
    }
    /* Revert the game shell to block layout on narrow screens so content stacks vertically. */
    #gameShell{
      display:block;
    }
    /* The game area should also stack its children vertically on mobile. */
    #gameArea{
      display:block;
    }
    /* On mobile, hide the overlay HUD and use the bar instead.  The bar uses
       a 3-column grid.  Ability, companion and coins are grouped into a
       single multi-line chip to ensure text fits and remains readable. */
    #hud{display:none}
    #hudBar{
      /* On mobile, arrange status chips in two rows.  Row 1 has three columns
         for scene, time and weather.  Row 2 has four columns for pets/discovered,
         sprite, ability and the minimap.  Use equal fractions so they fit neatly
         alongside the minimap. */
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(2, auto);
      gap:8px;
    }

    /* Place each chip explicitly into the grid to ensure correct ordering. */
    #hudBar > .chip:nth-child(1){ grid-row:1; grid-column:1; }
    #hudBar > .chip:nth-child(2){ grid-row:1; grid-column:2; }
    #hudBar > .chip:nth-child(3){ grid-row:1; grid-column:3; }
    #hudBar > .chip:nth-child(4){ grid-row:2; grid-column:1; }
    #hudBar > .chip:nth-child(5){ grid-row:2; grid-column:2; }
    #hudBar > .chip:nth-child(6){ grid-row:2; grid-column:3; }
    #hudBar > .chip:nth-child(7){ grid-row:2; grid-column:4; }
    /* Standard chips centered vertically and horizontally.  Reduce padding and font size
       on mobile to prevent the HUD from growing too tall and wide. */
    #hudBar .chip{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:2px 4px;
      font-size:10px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    /* Multi-line group for ability, companion, and coins */
    #hudBar .ability-group{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      justify-content:flex-start;
      white-space:normal;
      font-size:10px;
      line-height:1.1;
      padding:2px 4px;
    }
    /* Multi-line group for pets and discovered counts */
    #hudBar .petsdisc-group{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      justify-content:flex-start;
      white-space:normal;
      font-size:10px;
      line-height:1.1;
      padding:2px 4px;
    }
    /* Hide the desktop minimap container on small screens */
    #minimapContainer{ display:none; }
    /* Show the mobile minimap chip */
    #hudBar .minimap-chip{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:2px;
    }
    /* Ensure the mobile minimap scales to the chip size */
    #hudBar .minimap-chip canvas{
      width:100%;
      height:auto;
    }
    canvas#minimap{width:88px;height:88px}
  }

  /* Start menu overlay */
  #startMenu{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    background:var(--panel);
    border:1px solid #1f2d54;
    border-radius:12px;
    padding:16px;
    z-index:400;
    display:none;
    width:240px;
    text-align:center;
  }

  /* Mini-game overlay styling: center a small dialog with progress bar */
  #catchGame{
    position:fixed;
    top:calc(var(--headerH) + 20px);
    left:50%;
    transform:translateX(-50%);
    background:var(--panel);
    border:1px solid #1f2d54;
    padding:12px;
    border-radius:10px;
    width:320px;
    max-width:90vw;
    z-index:360;
    text-align:center;
    color:var(--ink);
  }
  #catchGame h2{ margin:0 0 8px 0; font-size:18px; }
  #catchGame p{ margin:6px 0; font-size:14px; }
  #startMenu button{margin-top:8px;width:100%;}

/* Instructions overlay: similar styling to the start menu but wider and scrollable */
#instructionsMenu{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  background:var(--panel);
  border:1px solid #1f2d54;
  border-radius:12px;
  padding:16px;
  z-index:400;
  display:none;
  width:min(90%, 480px);
  max-height:80vh;
  overflow:auto;
  color:var(--ink);
  text-align:left;
}
#instructionsMenu button{
  margin-top:8px;
  width:100%;
}
#instructionsMenu p{
  margin:0 0 8px 0;
  font-size:12px;
  line-height:1.4;
}

/* Shop menu overlay styling */
#shopMenu{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  background:var(--panel);
  border:1px solid #1f2d54;
  border-radius:12px;
  padding:16px;
  z-index:400;
  width:min(90%, 320px);
  max-height:80vh;
  overflow:auto;
  text-align:left;
  color:var(--ink);
}
#shopMenu .shopItem{
  margin-bottom:12px;
  font-size:12px;
  line-height:1.3;
}
#shopMenu .shopItem button{
  margin-top:4px;
  width:100%;
}
</style>
</head>
<body>
<header id="topbar">
  <h1>Wild Pals <small>— v13 full build</small></h1>
</header>

<div class="wrap">
  <div id="uiToggles">
    <button class="toggle" id="toggleInventory" aria-pressed="false">Inventory</button>
    <button class="toggle" id="toggleJournal" aria-pressed="false">Journal</button>
    <button class="toggle" id="toggleQuests" aria-pressed="false">Quests</button>
    <button class="toggle" id="toggleCare" aria-pressed="false">Enclosures</button>
  </div>

  <div id="hudBar" role="group" aria-label="Status">
    <!-- Row 1: individual chips for scene, time and weather -->
    <div class="chip">Scene: <span id="sceneLabel2">Meadow</span></div>
    <div class="chip">Time: <span id="timeLabel2">06:00</span></div>
    <div class="chip">Weather: <span id="weatherLabel2">Clear</span></div>
    <!-- Row 2: combine pets and discovered into one chip -->
    <div class="chip petsdisc-group">Pets: <span id="petCount2">0</span><br>Discovered: <span id="discCount2">0</span>/<span id="discTotal2">0</span></div>
    <!-- Row 2: central sprite of the active companion -->
    <div class="chip sprite-chip"><canvas id="activeSprite2" width="48" height="48" aria-label="Active pet"></canvas></div>
    <!-- Row 2: ability, companion and coins -->
    <div class="chip ability-group">Ability: <span id="activeAbility2">—</span><br>Companion: <span id="activePetName2">None</span><br>Coins: <span id="coinsLabel2">0</span></div>
    <!-- Minimaps for mobile: will appear in the same row as the three status chips in mobile layout.  Hidden on desktop. -->
    <div class="chip minimap-chip"><canvas id="minimapMobile" width="88" height="88" aria-label="Minimap"></canvas></div>
  </div>

  <div id="gameShell">
    <!-- Desktop HUD: positioned to the left of the game area.  On mobile this element is hidden via CSS. -->
    <div id="hud">
      <!-- Scene, Time, Weather on desktop (stacked vertically) -->
      <div class="chip">Scene: <span id="sceneLabel">Meadow</span></div>
      <div class="chip">Time: <span id="timeLabel">06:00</span></div>
      <div class="chip">Weather: <span id="weatherLabel">Clear</span></div>
      <!-- Pets/Discovered combined -->
      <div class="chip petsdisc-group">Pets: <span id="petCount">0</span><br>Discovered: <span id="discCount">0</span>/<span id="discTotal">0</span></div>
      <!-- Sprite display for active companion -->
      <div class="chip sprite-chip"><canvas id="activeSprite" width="48" height="48" aria-label="Active pet"></canvas></div>
      <!-- Ability, Companion and Coins -->
      <div class="chip ability-group">Ability: <span id="activeAbility">—</span><br>Companion: <span id="activePetName">None</span><br>Coins: <span id="coinsLabel">0</span></div>
    </div>
    <!-- Game area contains the canvas, minimap, status bar and mobile controls.  On desktop, the canvas and minimap
         appear side by side in a row to minimize vertical space.  On mobile, the minimap is hidden via CSS. -->
    <div id="gameArea">
      <div id="gameRow">
        <div id="canvasBox">
          <canvas id="game" width="960" height="528" aria-label="Game display"></canvas>
        </div>
        <!-- Minimap container sits next to the canvas on desktop.  It will be hidden on mobile via CSS. -->
        <div id="minimapContainer">
          <canvas id="minimap" width="132" height="132" aria-label="Minimap"></canvas>
        </div>
      </div>
      <!-- Status & actions BELOW the display -->
      <div id="belowBar">
        <div style="display:flex;gap:8px;align-items:center">
          <button id="ctaEnter" class="cta" style="display:none">Enter (E)</button>
          <button id="ctaExit" class="cta" style="display:none">Exit (E)</button>
        </div>
        <div id="debug">booting…</div>
      </div>

      <!-- GameBoy-style controls (mobile only) -->
      <div id="padDock">
        <div id="mobileControls" aria-label="On-screen controls">
          <div class="dpad">
            <div class="cross"></div>
            <button id="btnUp">▲</button>
            <button id="btnDown">▼</button>
            <button id="btnLeft">◀</button>
            <button id="btnRight">▶</button>
          </div>
          <div class="actCluster">
            <button class="btn" id="btnA" aria-label="A">A</button>
            <button class="btn" id="btnB" aria-label="B">B</button>
          </div>
          <div class="startRow">
            <button class="tiny" id="btnStart" aria-label="Start">START</button>
          </div>
        </div>
      </div>
    </div><!-- end gameArea -->
  </div><!-- end gameShell -->
</div>

<div id="scrim"></div>

  <!-- Embedded audio clips.  These small beeps are encoded directly into the page
       using base64 data URIs.  They play on certain game events (collecting
       an animal, completing a quest, travelling through portals).  Having
       the audio encoded avoids the need for separate sound files. -->
  <audio id="sndCollect" src="data:audio/wav;base64,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" preload="auto"></audio>
  <audio id="sndQuest"   src="data:audio/wav;base64,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" preload="auto"></audio>
  <audio id="sndPortal"  src="data:audio/wav;base64,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" preload="auto"></audio>

<!-- Start Menu -->
<div id="startMenu" class="start-menu">
  <h2 style="margin-top:0;margin-bottom:8px;">Menu</h2>
  <button id="startSave" class="pill">Save</button>
  <button id="startLoad" class="pill">Load</button>
  <button id="startReset" class="pill">New World</button>
  <!-- Shop button to access upgrades -->
  <button id="startShop" class="pill">Shop</button>
  <button id="startCheats" class="pill">Cheat Codes</button>
  <button id="startInstructions" class="pill">Instructions</button>
  <button id="startClose" class="pill">Close</button>
</div>

<!-- Instructions Overlay -->
<div id="instructionsMenu" style="display:none;">
  <h2 style="margin-top:0;margin-bottom:8px;">How to Play</h2>
  <p>Welcome to <strong>Wild Pals</strong>! Explore diverse biomes, befriend exotic animals and build the ultimate sanctuary.</p>
  <p><strong>Movement:</strong> Use the arrow keys or WASD to move. On mobile, use the on‑screen D‑pad. Press E/Enter (or tap A) to interact with houses, portals, and NPCs.</p>
  <p><strong>Catch animals:</strong> Common animals are collected automatically by walking into them. Uncommon, rare and legendary species trigger a quick tapping mini‑game &mdash; tap or click rapidly to fill the bar before time runs out to catch the creature!</p>
  <p><strong>Complete quests:</strong> Speak to the guide in each biome to see what animals they need. Deliver the required species to complete the quest and unlock the next biome.</p>
  <p><strong>Unlock special biomes:</strong> Collect rare animals to unlock secret biomes beyond the starting loop. Volcano, Glacier and Mystic biomes become available as you discover more uncommon and rare creatures. Each new land has its own quest.</p>
  <p><strong>Manage your sanctuary:</strong> Your house contains land, water and air enclosures. You can showcase any animal without removing it from your inventory. Keep them happy by feeding, cleaning and adding plants or decor to increase their happiness cap.</p>
  <p><strong>Travel through biomes:</strong> Portals appear after finishing each quest. Journey through Meadow → Forest → Desert → Wetlands → Volcano → Glacier → Mystic and repeat to find every species.</p>
  <p><strong>Level up companions:</strong> Catching multiple copies of the same species grants XP. Every 5 XP increases the companion's level, boosting its ability (e.g., movement speed or reveal radius).</p>
  <p><strong>Flying companions:</strong> Some animals can fly over water. Rare and legendary flyers can also soar over mountains, while smaller birds (e.g., Bluebird) can only cross rivers and lakes.</p>
  <p><strong>Shop upgrades:</strong> Access the Shop from the start menu to purchase <em>Speed Boots</em>, a <em>Lantern</em> or a <em>Sand Cloak</em> with your coins. Upgrades improve your speed, reveal radius and sandstorm resistance.</p>
  <p><strong>Achievements, happiness &amp; legendary events:</strong> Earn bonus coins for collecting many species or completing all quests. Keep animals happy in enclosures to earn gifts. Occasionally, a legendary creature appears &mdash; follow the toast prompts and catch it before it disappears!</p>
  <p><strong>Win the game:</strong> Discover all 100 animals, unlock every biome, complete all quests, level up your companions and build a thriving sanctuary!</p>
  <button id="instructionsClose" class="pill" style="margin-top:8px;width:100%;">Close</button>
</div>

<!-- Shop Menu Overlay -->
<div id="shopMenu" style="display:none;">
  <h2 style="margin-top:0;margin-bottom:8px;">Shop</h2>
  <p>Spend your coins on upgrades that improve your abilities.</p>
  <div class="shopItem">
    <b>Speed Boots</b> — Increase movement speed by 20%.<br>
    <button class="purchaseBtn" data-upgrade="boots">Buy</button>
  </div>
  <div class="shopItem">
    <b>Lantern</b> — +1 reveal radius in fog.<br>
    <button class="purchaseBtn" data-upgrade="lantern">Buy</button>
  </div>
  <div class="shopItem">
    <b>Sand Cloak</b> — Negate sandstorm speed penalty.<br>
    <button class="purchaseBtn" data-upgrade="cloak">Buy</button>
  </div>
  <button id="shopClose" class="pill" style="margin-top:8px;width:100%;">Close</button>
</div>

  <!-- Catch mini-game overlay -->
  <!-- This overlay appears when the player encounters a rare animal.  The player must tap/click
       repeatedly to fill the progress bar before time runs out to successfully catch the creature. -->
  <div id="catchGame" style="display:none;">
    <h2 id="catchTitle" style="margin-top:0;margin-bottom:8px;">Catch!</h2>
    <p id="catchMessage">Tap/click repeatedly to catch the animal before it escapes!</p>
    <div id="catchProgress" style="width:100%;height:12px;background:#234;border-radius:6px;margin:8px 0;cursor:pointer;">
      <div id="catchBar" style="height:100%;width:0%;background:var(--accent);border-radius:6px;"></div>
    </div>
    <button id="catchClose" class="pill" style="margin-top:8px;width:100%;">Abort</button>
  </div>

  <!-- Cheat Codes overlay.  When opened from the start menu, this overlay lets the
       player enter special codes to unlock biomes, spawn creatures or adjust
       stats.  A list of available codes is shown for convenience. -->
  <div id="cheatMenu" style="display:none;">
    <h2 style="margin-top:0;margin-bottom:8px;">Cheat Codes</h2>
    <p>Enter a cheat code or select from the list below:</p>
    <input id="cheatInput" type="text" placeholder="Enter code here" style="width:100%;margin-bottom:8px;padding:6px;border-radius:6px;border:1px solid #2b3b69;background:#0e1731;color:var(--ink);">
    <button id="cheatSubmit" class="pill" style="width:100%;">Submit</button>
    <div id="cheatList" style="max-height:180px;overflow-y:auto;margin-top:8px;padding:4px;border:1px solid #2b3b69;border-radius:6px;background:#0e1731;font-size:12px;line-height:1.4;"></div>
    <button id="cheatClose" class="pill" style="margin-top:8px;width:100%;">Close</button>
  </div>

<!-- Sidebars -->
<aside class="sidebar left" id="sbInventory" aria-label="Inventory">
  <header class="sbHead"><h2>Inventory</h2><button class="sbClose" data-close="sbInventory">Close</button></header>
  <div class="panel">
    <div class="row">
      <select id="petSelect_sb"></select>
      <button id="setActive_sb">Set Active</button>
      <span class="chip">Coins: <span id="coinsLabelInv">0</span></span>
    </div>
    <div id="inventoryGrid_sb"></div>
    <hr>
    </div>
</aside>

<aside class="sidebar right" id="sbJournal" aria-label="Journal">
  <header class="sbHead"><h2>Journal — Animal Book</h2><button class="sbClose" data-close="sbJournal">Close</button></header>
  <div class="panel"><div id="journalGrid_sb"></div></div>
</aside>

<aside class="sidebar right" id="sbQuests" aria-label="Quests">
  <header class="sbHead"><h2>Quest Log</h2><button class="sbClose" data-close="sbQuests">Close</button></header>
  <div id="questBox_sb"></div>
</aside>

<aside class="sidebar left" id="sbCare" aria-label="Enclosures">
  <header class="sbHead"><h2>Enclosures</h2><button class="sbClose" data-close="sbCare">Close</button></header>
  <div class="panel">
    <div class="note">Happiness decays; Feed/Clean to improve. Decor increases cap.</div>
    <div class="row">
      <button id="btnFeedAll_sb" class="pill">Feed All</button>
      <button id="btnCleanAll_sb" class="pill">Clean All</button>
      <button id="btnAddDecorLand_sb" class="pill">+ Land Decor</button>
      <button id="btnAddDecorWater_sb" class="pill">+ Water Decor</button>
      <button id="btnAddDecorAir_sb" class="pill">+ Air Decor</button>
    </div>
  </div>
</aside>

<!-- Market sidebar -->
<aside class="sidebar right" id="sbMarket" aria-label="Market">
  <header class="sbHead"><h2>Market</h2><button class="sbClose" data-close="sbMarket">Close</button></header>
  <div class="panel" id="marketPanel_sb"></div>
</aside>

<script>
(function(){
'use strict';
/* ===== Helpers ===== */
function setText(id, value){ const el=document.getElementById(id); if(el) el.textContent=value; }
function setBoth(id1, id2, value){ setText(id1,value); setText(id2,value); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
const baseName=(n)=> (n||'').replace(/\s*★/g,'').trim();
const rand=(a,b)=> Math.floor(Math.random()*(b-a+1))+a;

// Play a short sound effect by element ID.  Resets currentTime so repeated
// triggers play from the beginning.  Wrapped in try/catch to ignore play
// promise rejections (some browsers may require user interaction).
function playSound(id){
  const snd = document.getElementById(id);
  if(!snd) return;
  try{
    snd.currentTime = 0;
    snd.play();
  }catch(err){ /* ignored */ }
}

const TILE=24;

/* ===== Tile types ===== */
const TYPES={
  GRASS:0, FOREST:1, WATER:2, MOUNTAIN:3, SAND:4, HOUSE:5, BRIDGE:6, PATH:7,
  WALL:8, FLOOR:9, DOOR:10, SIGN:11, ENC_WATER:12, ENC_LAND:13, ENC_AIR:14,
  PORTAL:15, NPC:16, THEME_MEADOW:18, THEME_WATER:19, THEME_DESERT:20, THEME_AIR:21,
  // Additional terrain types for new biomes
  LAVA:22, ICE:23, SNOW:24
};
const typeColor={
  0:'#2d6b3d',1:'#1f4d2b',2:'#1b4c84',3:'#565c6f',4:'#9b8a56',5:'#7d3cff',6:'#8b5a2b',7:'#4b5f3b',
  8:'#394055',9:'#232b3f',10:'#ffcc00',11:'#cccccc',12:'#1f6c8f',13:'#3a5f3a',14:'#6b6b2b',15:'#df7d00',16:'#c7f464',
  18:'#2f5636',19:'#1d466e',20:'#8f7a3f',21:'#8087b0'
  ,22:'#e25822',23:'#bcdffb',24:'#f2f2f2'
};
const SCENES=['meadow','forest','desert','wetlands','volcano','glacier','mystic'];
const WEATHER={CLEAR:'Clear', RAIN:'Rain', SAND:'Sandstorm'};

/* ===== Animals ===== */
const animals=[
  // Meadow animals (common & uncommon)
  {name:'Dog',kind:'land',tag:'SCENT',ability:'Scent pings.',rarity:1,home:'meadow'},
  {name:'Horse',kind:'land',tag:'MOUNT',ability:'Ride fast.',rarity:3,home:'meadow'},
  {name:'Goat',kind:'land',tag:'CLIMB',ability:'Climb cliffs.',rarity:2,home:'meadow'},
  {name:'Rabbit',kind:'land',tag:'SPEED',ability:'Hop sprint.',rarity:1,home:'meadow'},
  {name:'Cheetah',kind:'land',tag:'SPEED',ability:'Ultra sprint.',rarity:3,home:'meadow'},
  {name:'Sheep',kind:'land',tag:'FORT',ability:'Produces wool.',rarity:2,home:'meadow'},
  {name:'Cow',kind:'land',tag:'FORT',ability:'Provides milk.',rarity:2,home:'meadow'},
  {name:'Chicken',kind:'land',tag:'FORT',ability:'Drops eggs.',rarity:1,home:'meadow'},
  {name:'Fox',kind:'land',tag:'SCENT',ability:'Stealthy; scares smaller animals.',rarity:3,home:'meadow'},
  {name:'Hedgehog',kind:'land',tag:'FORT',ability:'Defensive curl.',rarity:2,home:'meadow'},
  // Meadow additions
  {name:'Pig',kind:'land',tag:'FORT',ability:'Farm friend.',rarity:1,home:'meadow'},
  {name:'Turkey',kind:'land',tag:'FORT',ability:'Feather alarm.',rarity:1,home:'meadow'},
  {name:'Mole',kind:'land',tag:'CLIMB',ability:'Tunnel dig.',rarity:2,home:'meadow'},
  {name:'Field Mouse',kind:'land',tag:'SPEED',ability:'Quick dash.',rarity:1,home:'meadow'},
  {name:'Bluebird',kind:'air',tag:'FLIGHT',ability:'Song reveals; flies over water.',rarity:2,home:'meadow'},
  {name:'Skunk',kind:'land',tag:'FORT',ability:'Spray defense.',rarity:2,home:'meadow'},
  {name:'Badger',kind:'land',tag:'FORT',ability:'Dig & defend.',rarity:3,home:'meadow'},
  {name:'Opossum',kind:'land',tag:'FORT',ability:'Feign death.',rarity:2,home:'meadow'},

  // Forest animals
  {name:'Bear',kind:'land',tag:'FORT',ability:'Fortitude.',rarity:4,home:'forest'},
  {name:'Raccoon',kind:'land',tag:'SCENT',ability:'Forage scent.',rarity:2,home:'forest'},
  {name:'Owl',kind:'air',tag:'SURVEIL',ability:'Night watch.',rarity:2,home:'forest'},
  {name:'Hawk',kind:'air',tag:'SURVEIL',ability:'Bigger reveal.',rarity:3,home:'forest'},
  {name:'Deer',kind:'land',tag:'SPEED',ability:'Speed burst.',rarity:2,home:'forest'},
  {name:'Wolf',kind:'land',tag:'SPEED',ability:'Pack howl.',rarity:3,home:'forest'},
  {name:'Boar',kind:'land',tag:'FORT',ability:'Charge attack.',rarity:3,home:'forest'},
  {name:'Squirrel',kind:'land',tag:'CLIMB',ability:'Quick climb & nut gathering.',rarity:1,home:'forest'},
  {name:'Tree Frog',kind:'land',tag:'CLIMB',ability:'Sticky jump on trees.',rarity:2,home:'forest'},
  {name:'Crested Gecko',kind:'land',tag:'CLIMB',ability:'Arboreal cling.',rarity:3,home:'forest'},
  // Forest additions
  {name:'Elk',kind:'land',tag:'FORT',ability:'Antler charge.',rarity:3,home:'forest'},
  {name:'Moose',kind:'land',tag:'FORT',ability:'Massive build.',rarity:4,home:'forest'},
  {name:'Woodpecker',kind:'air',tag:'SURVEIL',ability:'Tree tap reveal.',rarity:2,home:'forest'},
  {name:'Chipmunk',kind:'land',tag:'SPEED',ability:'Nut stash.',rarity:2,home:'forest'},
  {name:'Lynx',kind:'land',tag:'SPEED',ability:'Silent stalk.',rarity:3,home:'forest'},
  {name:'Cougar',kind:'land',tag:'SPEED',ability:'Pounce.',rarity:4,home:'forest'},
  {name:'Porcupine',kind:'land',tag:'FORT',ability:'Quills defense.',rarity:2,home:'forest'},
  {name:'Bobcat',kind:'land',tag:'SPEED',ability:'Leap attack.',rarity:3,home:'forest'},
  {name:'Coyote',kind:'land',tag:'SPEED',ability:'Howl & chase.',rarity:2,home:'forest'},
  {name:'Weasel',kind:'land',tag:'SCENT',ability:'Sneaky hunter.',rarity:2,home:'forest'},

  // Desert animals
  {name:'Camel',kind:'land',tag:'MOUNT',ability:'Desert mount.',rarity:3,home:'desert'},
  {name:'Vulture',kind:'air',tag:'SURVEIL+',ability:'Thermals.',rarity:3,home:'desert'},
  {name:'Lizard',kind:'land',tag:'SPEED',ability:'Sun sprint.',rarity:2,home:'desert'},
  {name:'Chameleon',kind:'land',tag:'CLIMB',ability:'Blend & climb.',rarity:3,home:'desert'},
  {name:'Iguana',kind:'land',tag:'CLIMB',ability:'Warm perch.',rarity:3,home:'desert'},
  {name:'Fennec Fox',kind:'land',tag:'SPEED',ability:'Night sprint.',rarity:3,home:'desert'},
  {name:'Scorpion',kind:'land',tag:'FORT',ability:'Poison sting.',rarity:3,home:'desert'},
  {name:'Desert Tortoise',kind:'land',tag:'FORT',ability:'Extreme fortitude.',rarity:4,home:'desert'},
  {name:'Sidewinder Snake',kind:'land',tag:'SPEED',ability:'Sand slither.',rarity:3,home:'desert'},
  {name:'Bearded Dragon',kind:'land',tag:'FORT',ability:'Sun bask buff.',rarity:3,home:'desert'},
  {name:'Monitor Lizard',kind:'land',tag:'FORT',ability:'Giant lizard.',rarity:4,home:'desert'},
  {name:'Leopard Gecko',kind:'land',tag:'CLIMB',ability:'Night desert climber.',rarity:3,home:'desert'},
  // Desert additions
  {name:'Roadrunner',kind:'land',tag:'SPEED',ability:'Sprint across dunes.',rarity:3,home:'desert'},
  {name:'Meerkat',kind:'land',tag:'FORT',ability:'Alert watch.',rarity:2,home:'desert'},
  {name:'Jerboa',kind:'land',tag:'SPEED',ability:'Jump dash.',rarity:2,home:'desert'},
  {name:'Camel Spider',kind:'land',tag:'FORT',ability:'Scare bite.',rarity:3,home:'desert'},
  {name:'Sand Cat',kind:'land',tag:'SPEED',ability:'Silent pad.',rarity:3,home:'desert'},
  {name:'Dingo',kind:'land',tag:'SPEED',ability:'Pack chase.',rarity:2,home:'desert'},
  {name:'Emu',kind:'land',tag:'SPEED',ability:'Sprint & peck.',rarity:2,home:'desert'},
  {name:'Kangaroo Rat',kind:'land',tag:'SPEED',ability:'Leap across sand.',rarity:2,home:'desert'},
  {name:'Horned Lizard',kind:'land',tag:'FORT',ability:'Squirt blood.',rarity:3,home:'desert'},
  {name:'Armadillo',kind:'land',tag:'FORT',ability:'Roll defense.',rarity:3,home:'desert'},

  // Wetlands animals
  {name:'Otter',kind:'water',tag:'SWIM',ability:'Swim (cross rivers).',rarity:2,home:'wetlands'},
  {name:'Beaver',kind:'water',tag:'BRIDGE',ability:'Build Bridge (place ahead).',rarity:2,home:'wetlands'},
  {name:'Frog',kind:'water',tag:'SWIM+',ability:'Wetland speed.',rarity:1,home:'wetlands'},
  {name:'Salmon',kind:'water',tag:'SWIFT_SWIM',ability:'Fast in rivers.',rarity:1,home:'wetlands'},
  {name:'Trout',kind:'water',tag:'SWIFT_SWIM',ability:'Fast in rivers.',rarity:1,home:'wetlands'},
  {name:'Duck',kind:'water',tag:'SWIM',ability:'Pond friend.',rarity:1,home:'wetlands'},
  {name:'Turtle',kind:'water',tag:'SWIM',ability:'Amphibious.',rarity:2,home:'wetlands'},
  {name:'Heron',kind:'air',tag:'SURVEIL',ability:'Reeds lookout.',rarity:2,home:'wetlands'},
  {name:'Axolotl',kind:'water',tag:'SWIM',ability:'Regenerates health over time.',rarity:3,home:'wetlands'},
  {name:'Pacman Frog',kind:'water',tag:'SWIM',ability:'Ambush predator (bite stun).',rarity:3,home:'wetlands'},
  {name:'Poison Dart Frog',kind:'water',tag:'SWIM',ability:'Contact poison.',rarity:3,home:'wetlands'},
  {name:'Glass Frog',kind:'water',tag:'SWIM',ability:'Camouflage (translucent).',rarity:3,home:'wetlands'},
  {name:'Kingfisher',kind:'air',tag:'SURVEIL',ability:'Dive catch fish.',rarity:2,home:'wetlands'},
  {name:'Capybara',kind:'water',tag:'MOUNT',ability:'Wetland mount; group buff.',rarity:3,home:'wetlands'},
  {name:'Koi Fish',kind:'water',tag:'SWIM',ability:'Wetland beauty.',rarity:2,home:'wetlands'},
  // Wetlands additions
  {name:'Newt',kind:'water',tag:'SWIM',ability:'Tiny swimmer.',rarity:2,home:'wetlands'},
  {name:'Crayfish',kind:'water',tag:'SWIM',ability:'Quick pinch.',rarity:1,home:'wetlands'},
  {name:'Snapping Turtle',kind:'water',tag:'SWIM',ability:'Bite clamp.',rarity:3,home:'wetlands'},
  {name:'Alligator',kind:'water',tag:'SWIM',ability:'Ambush strike.',rarity:4,home:'wetlands'},
  {name:'Crocodile',kind:'water',tag:'SWIM',ability:'Death roll.',rarity:5,home:'wetlands'},
  {name:'Hippo',kind:'water',tag:'MOUNT',ability:'Run & swim mount.',rarity:4,home:'wetlands'},
  {name:'Manatee',kind:'water',tag:'SWIM',ability:'Gentle swim.',rarity:3,home:'wetlands'},
  {name:'Swan',kind:'air',tag:'SURVEIL',ability:'Graceful float.',rarity:2,home:'wetlands'},
  {name:'Flamingo',kind:'air',tag:'SURVEIL',ability:'Stand & filter.',rarity:3,home:'wetlands'},
  {name:'Crane',kind:'air',tag:'SURVEIL',ability:'Tall view.',rarity:2,home:'wetlands'},
  {name:'Boa Constrictor',kind:'land',tag:'FORT',ability:'Constriction.',rarity:4,home:'wetlands'},
  {name:'Tapir',kind:'land',tag:'FORT',ability:'Water wade.',rarity:3,home:'wetlands'},

  // Exotic forest and tree-dwelling animals (non-standard biomes)
  {name:'Flying Squirrel',kind:'air',tag:'SURVEIL',ability:'Glide between trees.',rarity:3,home:'forest'},
  {name:'Sugar Glider',kind:'air',tag:'SURVEIL',ability:'Glide & forage boost.',rarity:3,home:'forest'},
  {name:'Tokay Gecko',kind:'land',tag:'CLIMB',ability:'Loud call; intimidation.',rarity:3,home:'forest'},
  {name:'Sloth',kind:'land',tag:'CLIMB',ability:'Hang & slow time.',rarity:3,home:'forest'},
  {name:'Toucan',kind:'air',tag:'SURVEIL',ability:'Colorful call.',rarity:3,home:'forest'},
  {name:'Macaw',kind:'air',tag:'SURVEIL',ability:'Mimic call.',rarity:3,home:'forest'},
  {name:'Panda',kind:'land',tag:'FORT',ability:'Bamboo munch.',rarity:4,home:'forest'},
  {name:'Red Panda',kind:'land',tag:'CLIMB',ability:'Cute distraction.',rarity:3,home:'forest'},
  {name:'Capuchin Monkey',kind:'land',tag:'CLIMB',ability:'Tool use.',rarity:4,home:'forest'},
  {name:'Lemur',kind:'land',tag:'CLIMB',ability:'Long leap.',rarity:3,home:'forest'},
  {name:'Gibbon',kind:'land',tag:'CLIMB',ability:'Swing across.',rarity:4,home:'forest'},

  // Legendary animals (event spawns)
  {name:'Phoenix',kind:'air',tag:'FLIGHT',ability:'Fly across mountains.',rarity:5,home:'legendary'},
  {name:'Dragon',kind:'land',tag:'FLIGHT',ability:'Fly across mountains.',rarity:5,home:'legendary'}
];

function info(n){ const bn=baseName(n); return animals.find(a=>a.name===bn); }
function tag(){ return info(activePetName)?.tag||null; }
function kind(){ return info(activePetName)?.kind||null; }

/* ===== DOM refs ===== */
const game=document.getElementById('game'), g=game.getContext('2d',{alpha:false});
const mini=document.getElementById('minimap'), mctx=mini.getContext('2d',{alpha:false});
// Mobile minimap: only present on small screens.  Use optional chaining in case
// the element does not exist on desktop.  We'll draw to both minimap
// canvases if they are present.
const miniMobile=document.getElementById('minimapMobile'), mctxMobile = miniMobile ? miniMobile.getContext('2d',{alpha:false}) : null;
const dbg=document.getElementById('debug');
const ctaEnter=document.getElementById('ctaEnter'), ctaExit=document.getElementById('ctaExit');

/* ===== World state ===== */
let scene='meadow', mapW=120, mapH=100;
let map=new Uint8Array(mapW*mapH), fog=new Uint8Array(mapW*mapH);
let player={x:12,y:12}, keys={}, wildSpawns=[], companions=[], activePetName=null, pingAnimalsTimer=0, lastDir={x:1,y:0};
let timeMin=360, weather=WEATHER.CLEAR, weatherTimer=0, coins=0;
let housePos={x:10,y:10};
let portals={back:null,forward:null};
let npcs=[]; // array of {x,y,type:'main'|'trade'|'vendor', data?}
let enclosures={ water:[], land:[], air:[] }, decor={water:0, land:0, air:0};
let slotPos={water:[], land:[], air:[]};
let discovered=new Set();
let rngRare=0.03;

// ===== Cheat state and temporary effects =====
// Global multiplier applied to player speed via cheats (default 1)
let cheatSpeedMult = 1;
// Flag to hide the player sprite (for invisibility cheat)
let playerInvisible = false;
// Multiplier applied to market values via cheats (default 1)
let marketMultiplier = 1;
// Timer controlling confetti/party visuals (in seconds).  When >0, the draw
// function will render colourful particles on the game canvas.
let partyTimeTimer = 0;

// Market pricing state.  Recomputed each time the market opens.
let currentMarketPrices = {};

// Tracking for special unlock conditions and mini-games
let rareCollectedCount = 0; // number of epic or legendary animals collected
let catchActive = false;    // whether a mini-game is in progress
let catchAnimal = null;     // record of the animal being caught via mini-game
let catchClicks = 0;        // clicks accumulated in the mini-game
let catchTarget = 0;        // required clicks to succeed
let catchTimerId = null;    // timer id for mini-game timeout
// Track XP for each companion species.  Each duplicate catch adds XP and levels up the ability.
let companionXP = {};
// Player upgrades purchased from the shop: boots (speed), lantern (reveal), cloak (sandstorm resistance)
let playerUpgrades = { boots:false, lantern:false, cloak:false };
// Achievements awarded to avoid double rewards
let achievementsAwarded = {};
// Timer for legendary spawn events (in seconds)
let legendaryTimer = 0;
/* Tracks which scenes have been unlocked via quest completion.  The forward portal
   for a scene will only appear once its next scene has been unlocked.  Meadow
   is implicitly unlocked as the starting biome. */
const unlocked={ meadow:true, forest:false, desert:false, wetlands:false, volcano:false, glacier:false, mystic:false };

const saveKey='wildpals_v13';

/* ===== Quests (loop) ===== */
const questDefs={
  meadow: { name:'Meet the Scout', desc:'Bring a Rabbit and a Fox to the Meadow Guide.', need:['Rabbit','Fox'], rewards:{coins:5, open_next:true} },
  forest: { name:'Forest Friends', desc:'Bring a Deer to the Lumber Warden.', need:['Deer'], rewards:{coins:6, open_next:true} },
  desert: { name:'Oasis Aid', desc:'Bring a Camel and a Vulture to the Ranger.', need:['Camel','Vulture'], rewards:{coins:7, open_next:true} },
  wetlands:{ name:'Marsh Mentor', desc:'Bring an Axolotl and a Kingfisher.', need:['Axolotl','Kingfisher'], rewards:{coins:8, open_next:true} }
  ,
  volcano:{ name:'Volcano Trial', desc:'Bring a Sidewinder Snake, a Bearded Dragon and a Horned Lizard to the Magma Sage.', need:['Sidewinder Snake','Bearded Dragon','Horned Lizard'], rewards:{coins:10, open_next:true} },
  glacier:{ name:'Frozen Friends', desc:'Bring a Moose and a Swan to the Ice Hermit.', need:['Moose','Swan'], rewards:{coins:12, open_next:true} },
  mystic:{ name:'Mystic Challenge', desc:'Bring a Phoenix and a Dragon to the Ancient Spirit.', need:['Phoenix','Dragon'], rewards:{coins:20, open_next:true} }
};
let quest={...questDefs.meadow, delivered:[], complete:false};

/* ===== Achievements ===== */
// A small achievement system awarding coins for reaching milestones.  Achievements are only rewarded once.
const achievementsList=[
  {key:'collector10', desc:'Catch 10 species', coins:5, condition:()=>discovered.size>=10},
  {key:'collector25', desc:'Catch 25 species', coins:10, condition:()=>discovered.size>=25},
  {key:'questMaster', desc:'Complete all main quests', coins:15, condition:()=>unlocked.forest && unlocked.desert && unlocked.wetlands && unlocked.volcano && unlocked.glacier && unlocked.mystic && quest.complete}
];

function checkAchievements(){
  for(const ach of achievementsList){
    if(!achievementsAwarded[ach.key] && ach.condition()){
      achievementsAwarded[ach.key]=true;
      coins += ach.coins;
      toast('Achievement unlocked: '+ach.desc+' +' + ach.coins + ' coins.');
      syncInventoryUI();
    }
  }
}

function idx(x,y){ return y*mapW + x; }
function inBounds(x,y){ return x>=0 && y>=0 && x<mapW && y<mapH; }
function isNight(){ return timeMin<360 || timeMin>1140; }
// Return the level of a companion species based on its XP.  Each 5 XP levels up the companion.
function companionLevel(name){
  const xp = companionXP[name] || 0;
  return 1 + Math.floor(xp / 5);
}
function speed(){
  // Returns tiles per second rather than per frame.  Base speeds remain the same
  // as earlier versions but are no longer divided by 60.  Actual movement
  // distance in update() is scaled by dtSec (elapsed real time in seconds).
  let base=3.8; const t=tag(); const bn=baseName(activePetName);
  if(t==='SPEED') base=6; if(t==='MOUNT') base=7.4;
  // Level bonuses: speed and mount companions get +0.5 speed per level above 1
  if(t==='SPEED' || t==='MOUNT'){
    const lvl = companionLevel(bn);
    if(lvl>1) base += 0.5*(lvl-1);
  }
  // Player boots upgrade increases base speed by 20%
  if(playerUpgrades.boots) base *= 1.2;
  // Sandstorm slowdown unless player has cloak upgrade
  if(scene==='desert' && weather===WEATHER.SAND && baseName(activePetName)!=='Camel' && !playerUpgrades.cloak) base*=0.85;
  // Apply any active cheat speed multiplier
  return base * cheatSpeedMult;
}
function revealRadius(){
  const t=tag(); let r=4;
  if(t==='SURVEIL') r=6; if(t==='SURVEIL+') r=8;
  if(scene==='desert' && !isNight()) r+=1;
  // Player lantern upgrade adds +1 reveal radius
  if(playerUpgrades.lantern) r += 1;
  // Level bonuses: surveil companions gain +1 radius per level above 1
  const bn=baseName(activePetName);
  const lvl = companionLevel(bn);
  if((t==='SURVEIL' || t==='SURVEIL+') && lvl>1){ r += (lvl-1); }
  return Math.max(3,r);
}
function timeString(){ const h=Math.floor(timeMin/60)%24, m=Math.floor(timeMin%60); return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`; }

/* ===== World gen helpers ===== */
function blob(tile,rmin,rmax,cond){
  let cx=rand(0,mapW-1), cy=rand(0,mapH-1), rr=rand(rmin,rmax);
  for(let y=-rr;y<=rr;y++) for(let x=-rr;x<=rr;x++){
    const px=cx+x, py=cy+y;
    if(!inBounds(px,py)) continue;
    if(x*x+y*y<=rr*rr && (!cond||cond(map[idx(px,py)]))) map[idx(px,py)]=tile;
  }
}
function carveSafeYard(cx,cy,r){
  for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){
    const px=cx+x, py=cy+y; if(!inBounds(px,py)) continue;
    if(x*x+y*y<=r*r){
      const id=idx(px,py); if(map[id]===TYPES.HOUSE||map[id]===TYPES.NPC||map[id]===TYPES.PORTAL) continue;
      map[id] = (Math.abs(x)+Math.abs(y))%3===0 ? TYPES.PATH : TYPES.GRASS;
    }
  }
}

/* ===== Scene generators (loop: meadow -> forest -> desert -> wetlands -> meadow) ===== */
function genScene(next){
  scene=next||scene;
  if(scene==='house'){ return genHouse(); }
  // Common size
  mapW=120; mapH=100; map=new Uint8Array(mapW*mapH); fog=new Uint8Array(mapW*mapH);
  for(let i=0;i<map.length;i++) map[i]=TYPES.GRASS;
  npcs=[]; portals={back:null, forward:null};
  // Determine if the forward portal should be present based on unlocks.  The next scene
  // in the biome cycle is unlocked once its preceding quest is completed.  Without
  // unlocking, the forward portal remains absent and the player cannot progress.
  const sceneIndex = SCENES.indexOf(scene);
  const nextSceneName = SCENES[(sceneIndex+1) % SCENES.length];
  const forwardUnlocked = !!unlocked[nextSceneName];
  // biome shaping
  if(scene==='meadow'){
    // meadows: forest patches + winding streams
    for(let k=0;k<120;k++) blob(TYPES.FOREST,2,5,(t)=>t===TYPES.GRASS);
    for(let r=0;r<3;r++){ let x=rand(0,mapW-1), y=0; for(let s=0;s<mapH*2;s++){ if(!inBounds(x,y)) break; map[idx(x,y)]=TYPES.WATER; y+=1; x+=rand(-1,1); if(Math.random()<.25) map[idx(clamp(x+1,0,mapW-1),y)]=TYPES.WATER; } }
    housePos={x:10,y:10}; map[idx(housePos.x,housePos.y)]=TYPES.HOUSE; carveSafeYard(housePos.x, housePos.y, 8);
    // portals: meadow has only a forward portal to forest when unlocked
    if(forwardUnlocked){
      portals.forward={x:housePos.x+4, y:housePos.y};
      map[idx(portals.forward.x, portals.forward.y)] = TYPES.PORTAL;
    } else {
      portals.forward = null;
    }
    portals.back=null;
    // NPCs
    const main={x:housePos.x+2,y:housePos.y,type:'main'}; map[idx(main.x,main.y)]=TYPES.NPC; npcs.push(main);
    const trade={x:housePos.x+1,y:housePos.y+3,type:'trade'}; map[idx(trade.x,trade.y)]=TYPES.NPC; npcs.push(trade);
    // Market NPC: sells animals from any biome; place slightly south-east of house
    const market={x:housePos.x+3,y:housePos.y+2,type:'market'};
    map[idx(market.x,market.y)] = TYPES.NPC; npcs.push(market);
    quest={...questDefs.meadow, delivered:[], complete:false};
    player.x=housePos.x+1; player.y=housePos.y;
  }
  else if(scene==='forest'){
    for(let i=0;i<map.length;i++) map[i]=TYPES.FOREST;
    for(let k=0;k<160;k++) blob(TYPES.GRASS,1,3,(t)=>t===TYPES.FOREST);
    for(let r=0;r<4;r++){ blob(TYPES.WATER,2,4,(t)=>t!==TYPES.MOUNTAIN); }
    portals.back={x:6,y:6}; map[idx(portals.back.x,portals.back.y)]=TYPES.PORTAL;
    // forward portal only if desert is unlocked
    if(forwardUnlocked){
      portals.forward={x:mapW-8,y:8};
      map[idx(portals.forward.x,portals.forward.y)] = TYPES.PORTAL;
    } else {
      portals.forward=null;
    }
    const main={x:8,y:6,type:'main'}; const trade={x:10,y:8,type:'trade'};
    map[idx(main.x,main.y)]=TYPES.NPC; map[idx(trade.x,trade.y)]=TYPES.NPC; npcs.push(main,trade);
    // Market NPC for forest: place near other NPCs
    const market={x:12,y:8,type:'market'};
    map[idx(market.x,market.y)] = TYPES.NPC; npcs.push(market);
    quest={...questDefs.forest, delivered:[], complete:false};
    player.x=portals.back.x+1; player.y=portals.back.y;
  }
  else if(scene==='desert'){
    for(let i=0;i<map.length;i++) map[i]=TYPES.SAND;
    for(let k=0;k<100;k++) blob(TYPES.MOUNTAIN,1,3,(t)=>t===TYPES.SAND);
    for(let o=0;o<6;o++){ let cx=rand(12,mapW-12), cy=rand(10,mapH-10);
      for(let y=-3;y<=3;y++) for(let x=-3;x<=3;x++){ const px=cx+x, py=cy+y; if(!inBounds(px,py)) continue; map[idx(px,py)]= (x*x+y*y<8)?TYPES.WATER:TYPES.SAND; }
    }
    portals.back={x:6,y:5};
    map[idx(portals.back.x,portals.back.y)] = TYPES.PORTAL;
    // forward portal only if wetlands is unlocked
    if(forwardUnlocked){
      portals.forward={x:mapW-8,y:6};
      map[idx(portals.forward.x,portals.forward.y)] = TYPES.PORTAL;
    } else {
      portals.forward = null;
    }
    const main={x:8,y:6,type:'main'}; const trade={x:10,y:8,type:'trade'};
    map[idx(main.x,main.y)]=TYPES.NPC; map[idx(trade.x,trade.y)]=TYPES.NPC; npcs.push(main,trade);
    // Market NPC for desert
    const market={x:12,y:9,type:'market'};
    map[idx(market.x,market.y)] = TYPES.NPC; npcs.push(market);
    quest={...questDefs.desert, delivered:[], complete:false};
    player.x=portals.back.x+1; player.y=portals.back.y;
  }
  else if(scene==='wetlands'){
    for(let i=0;i<map.length;i++) map[i]=TYPES.GRASS;
    for(let k=0;k<240;k++) blob(TYPES.WATER,1,3,(t)=>t!==TYPES.MOUNTAIN);
    for(let k=0;k<40;k++) blob(TYPES.FOREST,1,3,(t)=>t===TYPES.GRASS);
    // boardwalk: convert some water to PATH lines
    for(let y=10;y<mapH-10;y+=3) for(let x=10;x<mapW-10;x++) if(map[idx(x,y)]===TYPES.WATER) map[idx(x,y)]=TYPES.PATH;
    portals.back={x:6,y:6};
    map[idx(portals.back.x,portals.back.y)] = TYPES.PORTAL;
    // wetlands forward portal leads back to meadow; appears only if meadow is unlocked (always true after first cycle)
    if(forwardUnlocked){
      portals.forward = {x:mapW-7, y:mapH-7};
      map[idx(portals.forward.x, portals.forward.y)] = TYPES.PORTAL;
    } else {
      portals.forward = null;
    }
    const main={x:8,y:6,type:'main'}; const trade={x:11,y:8,type:'trade'};
    map[idx(main.x,main.y)]=TYPES.NPC; map[idx(trade.x,trade.y)]=TYPES.NPC; npcs.push(main,trade);
    // Market NPC for wetlands
    const market={x:13,y:8,type:'market'};
    map[idx(market.x,market.y)] = TYPES.NPC; npcs.push(market);
    quest={...questDefs.wetlands, delivered:[], complete:false};
    player.x=portals.back.x+1; player.y=portals.back.y;
  }
  else if(scene==='volcano'){
    // Volcano biome: rugged terrain with lava pools.  Base terrain is sand for walkability.
    for(let i=0;i<map.length;i++) map[i]=TYPES.SAND;
    // Carve mountains and lava pools
    for(let k=0;k<100;k++) blob(TYPES.MOUNTAIN,1,3,(t)=>t===TYPES.SAND);
    for(let r=0;r<80;r++) blob(TYPES.LAVA,2,4,(t)=>t===TYPES.SAND || t===TYPES.MOUNTAIN);
    portals.back={x:6,y:6};
    map[idx(portals.back.x,portals.back.y)] = TYPES.PORTAL;
    if(forwardUnlocked){
      portals.forward={x:mapW-8,y:6};
      map[idx(portals.forward.x,portals.forward.y)] = TYPES.PORTAL;
    } else {
      portals.forward = null;
    }
    // NPCs: magma sage and trader
    const main={x:8,y:6,type:'main'};
    const trade={x:10,y:8,type:'trade'};
    map[idx(main.x,main.y)] = TYPES.NPC; map[idx(trade.x,trade.y)] = TYPES.NPC;
    // Market NPC
    const market={x:12,y:8,type:'market'};
    map[idx(market.x,market.y)] = TYPES.NPC;
    npcs.push(main,trade,market);
    quest={...questDefs.volcano, delivered:[], complete:false};
    player.x=portals.back.x+1; player.y=portals.back.y;
  }
  else if(scene==='glacier'){
    // Glacier biome: snowy landscape with patches of ice
    for(let i=0;i<map.length;i++) map[i]=TYPES.SNOW;
    for(let k=0;k<120;k++) blob(TYPES.ICE,1,3,(t)=>t===TYPES.SNOW);
    portals.back={x:6,y:6};
    map[idx(portals.back.x,portals.back.y)] = TYPES.PORTAL;
    if(forwardUnlocked){
      portals.forward={x:mapW-8,y:6};
      map[idx(portals.forward.x,portals.forward.y)] = TYPES.PORTAL;
    } else {
      portals.forward = null;
    }
    // NPCs: ice hermit and trader
    const main={x:8,y:6,type:'main'};
    const trade={x:10,y:8,type:'trade'};
    map[idx(main.x,main.y)] = TYPES.NPC; map[idx(trade.x,trade.y)] = TYPES.NPC;
    // Market NPC
    const market={x:12,y:8,type:'market'};
    map[idx(market.x,market.y)] = TYPES.NPC;
    npcs.push(main,trade,market);
    quest={...questDefs.glacier, delivered:[], complete:false};
    player.x=portals.back.x+1; player.y=portals.back.y;
  }
  else if(scene==='mystic'){
    // Mystic biome: lush and magical.  Start with grass and add forests and water.
    for(let i=0;i<map.length;i++) map[i]=TYPES.GRASS;
    for(let k=0;k<180;k++) blob(TYPES.FOREST,1,3,(t)=>t===TYPES.GRASS);
    for(let k=0;k<90;k++) blob(TYPES.WATER,1,2,(t)=>t!==TYPES.MOUNTAIN);
    portals.back={x:6,y:6};
    map[idx(portals.back.x,portals.back.y)] = TYPES.PORTAL;
    // Mystic forward portal loops back to meadow if unlocked
    if(forwardUnlocked){
      portals.forward={x:mapW-8,y:8};
      map[idx(portals.forward.x,portals.forward.y)] = TYPES.PORTAL;
    } else {
      portals.forward = null;
    }
    // NPCs: ancient spirit and trader
    const main={x:8,y:6,type:'main'};
    const trade={x:10,y:8,type:'trade'};
    map[idx(main.x,main.y)] = TYPES.NPC; map[idx(trade.x,trade.y)] = TYPES.NPC;
    // Market NPC
    const market={x:12,y:8,type:'market'};
    map[idx(market.x,market.y)] = TYPES.NPC;
    npcs.push(main,trade,market);
    quest={...questDefs.mystic, delivered:[], complete:false};
    player.x=portals.back.x+1; player.y=portals.back.y;
  }
  // Fog reset & spawns
  fog.fill(0);
  spawnWildFor(scene);
  ensureQuestAnimalsReachable(scene);
  syncQuestUI();
}

/* ===== House (simplified, no podiums) ===== */
function genHouse(){
  scene='house';
  mapW=96; mapH=38; map=new Uint8Array(mapW*mapH); fog=new Uint8Array(mapW*mapH);
  for(let i=0;i<map.length;i++) map[i]=TYPES.FLOOR;
  // walls
  for(let x=0;x<mapW;x++){ map[idx(x,0)]=TYPES.WALL; map[idx(x,mapH-1)]=TYPES.WALL; }
  for(let y=0;y<mapH;y++){ map[idx(0,y)]=TYPES.WALL; map[idx(mapW-1,y)]=TYPES.WALL; }
  const hallY=Math.floor(mapH/2);
  // Create a hallway through the center of the house.  Previously we built solid
  // wall rows at hallY-2 and hallY+2 which blocked access to the top/bottom rooms.
  // To allow movement to the themed rooms, we only lay a path at hallY and avoid
  // building continuous wall barriers above and below.
  for(let x=1;x<mapW-1;x++){
    map[idx(x,hallY)] = TYPES.PATH;
  }
  // Front door
  map[idx(1,hallY)] = TYPES.DOOR;
  // themed rooms (simple)
  function room(ox,oy,w,h,theme,kind){
    for(let x=ox;x<ox+w;x++){ map[idx(x,oy)]=TYPES.WALL; map[idx(x,oy+h-1)]=TYPES.WALL; }
    for(let y=oy;y<oy+h;y++){ map[idx(ox,y)]=TYPES.WALL; map[idx(ox+w-1,y)]=TYPES.WALL; }
    for(let y=oy+1;y<oy+h-1;y++) for(let x=ox+1;x<ox+w-1;x++) map[idx(x,y)]=theme;
    const cx=Math.floor(ox+w/2); map[idx(cx,oy+(oy<hallY? h-1:0))]=TYPES.FLOOR; // doorway
    placeSlotGrid(kind, ox+4, oy+3, 3, 2);
  }
  // reset slots
  slotPos={water:[],land:[],air:[]};
  room(10, 4, 24, 10, TYPES.THEME_MEADOW, 'land');
  room(40, 4, 24, 10, TYPES.THEME_WATER , 'water');
  room(10, 24,24, 10, TYPES.THEME_DESERT, 'land');
  room(40, 24,24, 10, TYPES.THEME_AIR   , 'air');
  // fit enclosures array sizes
  ['water','land','air'].forEach(k=>{
    const want=slotPos[k].length; const cur=(enclosures[k]||[]);
    const out=new Array(want).fill(null); for(let i=0;i<Math.min(want,cur.length);i++) out[i]=cur[i]; enclosures[k]=out;
  });
  player.x=3; player.y=hallY; fog.fill(1);
  syncQuestUI();
}
function placeSlotGrid(kind,ox,oy,cols,rows){
  const tile = kind==='water'?TYPES.ENC_WATER : kind==='air'?TYPES.ENC_AIR : TYPES.ENC_LAND;
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
    const x=ox+c*3, y=oy+r*3; map[idx(x,y)]=tile; (slotPos[kind]||(slotPos[kind]=[])).push({x,y});
  }
}
function slotIndexAt(kind, tx, ty){
  const arr=slotPos[kind]||[];
  for(let i=0;i<arr.length;i++){ const p=arr[i]; if(p.x===tx && p.y===ty) return i; }
  return -1;
}

/* ===== Spawns ===== */
function spawnWildFor(sceneName){
  wildSpawns=[]; let pool=[];
  if(sceneName==='meadow') pool=[
    'Dog','Horse','Goat','Rabbit','Cheetah','Sheep','Cow','Chicken','Fox','Hedgehog',
    'Pig','Turkey','Mole','Field Mouse','Bluebird','Skunk','Badger','Opossum'
  ];
  if(sceneName==='forest') pool=[
    'Bear','Raccoon','Owl','Hawk','Deer','Wolf','Boar','Squirrel','Tree Frog','Crested Gecko',
    'Elk','Moose','Woodpecker','Chipmunk','Lynx','Cougar','Porcupine','Bobcat','Coyote','Weasel',
    'Flying Squirrel','Sugar Glider','Tokay Gecko',
    'Sloth','Toucan','Macaw','Panda','Red Panda','Capuchin Monkey','Lemur','Gibbon'
  ];
  if(sceneName==='desert') pool=[
    'Camel','Vulture','Lizard','Chameleon','Iguana','Fennec Fox','Scorpion','Desert Tortoise','Sidewinder Snake','Bearded Dragon','Monitor Lizard','Leopard Gecko',
    'Roadrunner','Meerkat','Jerboa','Camel Spider','Sand Cat','Dingo','Emu','Kangaroo Rat','Horned Lizard','Armadillo'
  ];
  if(sceneName==='wetlands') pool=[
    'Otter','Beaver','Frog','Salmon','Trout','Duck','Turtle','Heron','Axolotl','Pacman Frog','Poison Dart Frog','Glass Frog','Kingfisher','Capybara','Koi Fish',
    'Newt','Crayfish','Snapping Turtle','Alligator','Crocodile','Hippo','Manatee','Swan','Flamingo','Crane','Boa Constrictor','Tapir'
  ];
  if(sceneName==='volcano') pool=[
    // Fire and desert creatures thrive here.  Phoenix and Dragon may spawn rarely through legendary events.
    'Sidewinder Snake','Bearded Dragon','Horned Lizard','Monitor Lizard','Scorpion','Desert Tortoise','Camel','Vulture',
    'Fennec Fox','Camel Spider','Sand Cat','Armadillo','Meerkat','Roadrunner','Dingo'
  ];
  if(sceneName==='glacier') pool=[
    // Cold biome: reuse hardy forest and wetland species suitable for icy climates
    'Moose','Bear','Wolf','Elk','Lynx','Cougar','Porcupine','Coyote','Swan','Flamingo','Crane',
    'Snapping Turtle','Alligator','Crocodile','Hippo','Manatee','Tapir','Boa Constrictor'
  ];
  if(sceneName==='mystic') pool=[
    // Mystic biome: magical and exotic creatures
    'Phoenix','Dragon','Poison Dart Frog','Glass Frog','Tree Frog','Crested Gecko','Flying Squirrel','Sugar Glider',
    'Macaw','Panda','Red Panda','Sloth','Lemur','Gibbon','Axolotl','Pacman Frog','Koi Fish','Kingfisher','Capybara'
  ];
  let tries=0;
  while(wildSpawns.length<40 && tries<15000){
    tries++;
    const x=rand(0,mapW-1), y=rand(0,mapH-1);
    if(sceneName==='meadow' && idx(x,y)===idx(housePos.x,housePos.y)) continue;
    const t = map[idx(x,y)];
    if(!spawnHabitatOk(pool, t)) continue;
    if(wildSpawns.some(s=>s.x===x&&s.y===y)) continue;
    const nm = pool[rand(0,pool.length-1)];
    if(!spawnHabitatOk([nm], t)) continue;
    const nearStart = Math.hypot(x-player.x,y-player.y) < 12;
    const rare = (!nearStart) && Math.random()<rngRare;
    wildSpawns.push({x,y,name:nm,rare});
  }
  // bias a few friendly spawns near start (gentle start)
  for(let i=0;i<6;i++){
    const nx=clamp(Math.floor(player.x)+rand(-5,5),0,mapW-1);
    const ny=clamp(Math.floor(player.y)+rand(-5,5),0,mapH-1);
    const t=map[idx(nx,ny)];
    const near=['Frog','Beaver','Rabbit','Otter'][rand(0,3)];
    if(spawnHabitatOk([near],t)) wildSpawns.push({x:nx,y:ny,name:near,rare:false});
  }
}
function spawnHabitatOk(nms,t){
  function ok(name){
    const a=info(name); if(!a) return false;
    if(a.kind==='water') return t===TYPES.WATER || t===TYPES.ICE;
    if(a.kind==='land') return t!==TYPES.WATER && t!==TYPES.MOUNTAIN && t!==TYPES.LAVA && t!==TYPES.ICE;
    if(a.kind==='air')  return t!==TYPES.MOUNTAIN && t!==TYPES.LAVA;
    return true;
  }
  return nms.some(n=>ok(n));
}

/* ===== Reachability guarantee for quest species ===== */
function basePassable(t){ return t!==TYPES.WATER && t!==TYPES.MOUNTAIN && t!==TYPES.LAVA && t!==TYPES.ICE; }
function floodReachable(sx,sy){
  const q=[[sx,sy]], seen=new Uint8Array(mapW*mapH); seen[idx(sx,sy)]=1;
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  while(q.length){
    const [x,y]=q.shift();
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if(!inBounds(nx,ny)) continue;
      const id=idx(nx,ny); if(seen[id]) continue;
      if(basePassable(map[id])){ seen[id]=1; q.push([nx,ny]); }
    }
  }
  return seen;
}
function ensureQuestAnimalsReachable(sceneName){
  const need=new Set(questDefs[sceneName].need);
  const seen=floodReachable(Math.floor(player.x),Math.floor(player.y));
  for(const s of wildSpawns){ if(need.has(s.name) && seen[idx(s.x,s.y)]) need.delete(s.name); }
  for(const name of need){
    let placed=false, tries=0;
    while(!placed && tries++<4000){
      const x=rand(0,mapW-1), y=rand(0,mapH-1);
      if(!seen[idx(x,y)]) continue;
      const t=map[idx(x,y)]; if(!spawnHabitatOk([name],t)) continue;
      wildSpawns.push({x,y,name,rare:false}); placed=true;
    }
    // fallback: put on path near player
    if(!placed){
      outer: for(let r=1;r<10;r++){
        for(let dy=-r;dy<=r;dy++) for(let dx=-r;dx<=r;dx++){
          const x=Math.floor(player.x)+dx, y=Math.floor(player.y)+dy;
          if(!inBounds(x,y)) continue;
          if(map[idx(x,y)]===TYPES.PATH){ wildSpawns.push({x,y,name,rare:false}); placed=true; break outer; }
        }
      }
    }
  }
}

/* ===== Legendary spawn event ===== */
function spawnLegendaryEvent(){
  // Determine which legendary species can spawn in this biome
  let pool=[];
  if(scene==='desert' || scene==='volcano') pool=['Phoenix'];
  else if(scene==='wetlands' || scene==='glacier') pool=['Dragon'];
  else pool=['Phoenix','Dragon'];
  if(pool.length===0) return;
  const name = pool[rand(0,pool.length-1)];
  // Find a random reachable tile to spawn the legendary creature
  let placed=false; let tries=0;
  while(!placed && tries++<5000){
    const x=rand(0,mapW-1), y=rand(0,mapH-1);
    const t=map[idx(x,y)];
    if(!spawnHabitatOk([name], t)) continue;
    // Avoid spawning on the house or NPCs
    if(scene==='meadow' && idx(x,y)===idx(housePos.x,housePos.y)) continue;
    if(wildSpawns.some(s=>s.x===x && s.y===y)) continue;
    wildSpawns.push({x,y,name:name,rare:true});
    placed=true;
  }
  toast('A legendary '+name+' has appeared!');
}

/* ===== Mini‑game: Catching rare animals ===== */
// When encountering an uncommon or rarer species (rarity ≥ 3), the player must rapidly tap/click
// to fill a progress bar before the timer runs out.  Success captures the animal; failure lets
// it escape.  Rare catches increase rareCollectedCount which may unlock new biomes.
const catchGame = document.getElementById('catchGame');
const catchProgress = document.getElementById('catchProgress');
const catchBar = document.getElementById('catchBar');
const catchCloseBtn = document.getElementById('catchClose');

function startCatchGame(spawn){
  // Do not start a new mini‑game if one is already active
  if(catchActive) return;
  catchActive = true;
  catchAnimal = spawn;
  catchClicks = 0;
  // Determine required taps based on rarity (rarer animals require more taps)
  const rarity = info(spawn.name)?.rarity || 2;
  catchTarget = Math.max(3, 4 * rarity);
  // Reset progress bar
  if(catchBar) catchBar.style.width = '0%';
  // Update message
  const msgEl = document.getElementById('catchMessage');
  if(msgEl) msgEl.textContent = `Tap/click repeatedly to catch the ${spawn.name}!`;
  // Show overlay
  if(catchGame) catchGame.style.display = 'block';
  // Set timeout: base 2s + 0.5s per rarity tier
  const timeout = 2000 + (rarity * 500);
  catchTimerId = setTimeout(()=>finishCatch(false), timeout);
}

function catchClick(){
  if(!catchActive) return;
  catchClicks++;
  const progress = Math.min(1, catchClicks / catchTarget);
  if(catchBar) catchBar.style.width = Math.floor(progress * 100) + '%';
  if(progress >= 1){
    finishCatch(true);
  }
}

function finishCatch(success){
  if(!catchActive) return;
  clearTimeout(catchTimerId);
  // Hide overlay
  if(catchGame) catchGame.style.display = 'none';
  catchActive = false;
  if(success){
    // Capture the animal and award rewards
    if(catchAnimal) collectAnimal(catchAnimal);
  } else {
    // Escape: nothing happens, the animal remains on the map
    if(catchAnimal) toast('The '+catchAnimal.name+' escaped!', true);
  }
  catchAnimal = null;
}

// Attach click events for the mini‑game after DOM has loaded
document.addEventListener('DOMContentLoaded', ()=>{
  if(catchProgress) catchProgress.addEventListener('click', catchClick);
  if(catchCloseBtn) catchCloseBtn.addEventListener('click', ()=>finishCatch(false));
});

// Collect an animal into the player’s inventory, awarding XP and checking unlocks
function collectAnimal(s){
  const nm = s.name + (s.rare ? ' ★' : '');
  const base = s.name;
  // Add to companions and discovered species
  companions.push(nm);
  discovered.add(base);
  // Award XP and show level‑up toast
  const prevLvl = companionLevel(base);
  companionXP[base] = (companionXP[base]||0) + 1;
  const newLvl = companionLevel(base);
  if(newLvl > prevLvl){ toast(base+' leveled up to Lv'+newLvl+'!'); }
  // Remove the spawn from the world
  const idxRemove = wildSpawns.findIndex(a => a.x===s.x && a.y===s.y && a.name===s.name);
  if(idxRemove >= 0) wildSpawns.splice(idxRemove,1);
  toast('Collected: '+nm);
  // play collect sound effect for capturing an animal
  playSound('sndCollect');
  syncInventoryUI();
  // Rare animals (rarity ≥ 3) increment counter for unlocks
  const rarity = info(base)?.rarity || 1;
  if(rarity >= 3) rareCollectedCount++;
  // Check achievements and unlocks
  checkAchievements();
  checkUnlocks();
}

// Unlock new biomes based on rare animal count
function checkUnlocks(){
  if(!unlocked.volcano && rareCollectedCount >= 5){
    unlocked.volcano = true;
    toast('New biome unlocked: Volcano!');
  }
  if(!unlocked.glacier && rareCollectedCount >= 10){
    unlocked.glacier = true;
    toast('New biome unlocked: Glacier!');
  }
  if(!unlocked.mystic && rareCollectedCount >= 15){
    unlocked.mystic = true;
    toast('New biome unlocked: Mystic!');
  }
}

/* ===== Unlocking ===== */
// Marks the next scene in the biome loop as unlocked.  Called when a quest
// is completed.  Uses the current value of `scene` to determine which
// biome’s completion unlocks the next.  For example, completing the meadow
// quest unlocks forest.
function unlockNextScene(){
  const i=SCENES.indexOf(scene);
  const nextScene=SCENES[(i+1)%SCENES.length];
  // Mark the next biome as unlocked so that future generations will include its portal
  unlocked[nextScene] = true;
  // If we are currently in the biome that just completed its quest, spawn the forward
  // portal immediately so the player doesn’t need to re-enter the scene.  Each scene
  // has a fixed portal location that we replicate here.
  if(scene==='meadow'){
    // place forward portal to forest next to the house
    const px=housePos.x+4, py=housePos.y;
    portals.forward={x:px,y:py};
    map[idx(px,py)] = TYPES.PORTAL;
  } else if(scene==='forest'){
    const px=mapW-8, py=8;
    portals.forward={x:px,y:py};
    map[idx(px,py)] = TYPES.PORTAL;
  } else if(scene==='desert'){
    const px=mapW-8, py=6;
    portals.forward={x:px,y:py};
    map[idx(px,py)] = TYPES.PORTAL;
  } else if(scene==='wetlands'){
    const px=mapW-7, py=mapH-7;
    portals.forward={x:px,y:py};
    map[idx(px,py)] = TYPES.PORTAL;
  } else if(scene==='volcano'){
    // Volcano quest completion unlocks Glacier; portal on the east
    const px=mapW-8, py=6;
    portals.forward={x:px,y:py};
    map[idx(px,py)] = TYPES.PORTAL;
  } else if(scene==='glacier'){
    // Glacier quest completion unlocks Mystic
    const px=mapW-8, py=6;
    portals.forward={x:px,y:py};
    map[idx(px,py)] = TYPES.PORTAL;
  } else if(scene==='mystic'){
    // Mystic loops back to Meadow; place portal to cycle
    const px=mapW-8, py=8;
    portals.forward={x:px,y:py};
    map[idx(px,py)] = TYPES.PORTAL;
  }
}

/* ===== Controls ===== */
window.addEventListener('keydown', e=>{
  keys[e.key]=true;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
});
window.addEventListener('keyup', e=>{ keys[e.key]=false; });
window.addEventListener('keydown', e=>{
  // Cycle companions on Q, q, B or b
  if(e.key==='q' || e.key==='Q' || e.key==='b' || e.key==='B'){
    cycleActive();
    return;
  }
  // Action button on E, e or Enter
  if(e.key==='e' || e.key==='E' || e.key==='Enter'){
    actionButton();
    return;
  }
  // Close sidebars/menus on Escape
  if(e.key==='Escape'){
    closeAllSidebars();
    return;
  }
  // Open the start menu on desktop via the "P" key (stands for pause/start)
  if(e.key==='p' || e.key==='P'){
    toggleStartMenu();
    return;
  }
});

function pressKey(k,d){ keys[k]=d; }
function bindTouch(el, keyName){
  el.addEventListener('mousedown',()=>pressKey(keyName,true));
  el.addEventListener('mouseup',()=>pressKey(keyName,false));
  el.addEventListener('mouseleave',()=>pressKey(keyName,false));
  el.addEventListener('touchstart',(e)=>{ e.preventDefault(); pressKey(keyName,true); }, {passive:false});
  el.addEventListener('touchend',(e)=>{ e.preventDefault(); pressKey(keyName,false); }, {passive:false});
}
bindTouch(document.getElementById('btnUp'),'ArrowUp');
bindTouch(document.getElementById('btnDown'),'ArrowDown');
bindTouch(document.getElementById('btnLeft'),'ArrowLeft');
bindTouch(document.getElementById('btnRight'),'ArrowRight');
document.getElementById('btnA').addEventListener('click',()=>actionButton());
document.getElementById('btnB').addEventListener('click',()=>cycleActive());
// Ensure mobile taps on the B button cycle the active companion immediately
document.getElementById('btnB').addEventListener('touchstart',(e)=>{
  e.preventDefault();
  cycleActive();
}, {passive:false});
// On mobile, the Start button opens the start menu instead of performing an in-game action
document.getElementById('btnStart').addEventListener('click', (e)=>{
  e.preventDefault();
  toggleStartMenu();
});

/* ===== Actions ===== */
function cycleActive(){
  // Cycle through the companions list in a robust way.  We attempt to find the
  // current active companion by exact match first.  If not found (e.g. the
  // activePetName string differs by rarity suffix), we fall back to matching
  // by base species name.  This prevents cycling from getting stuck when
  // activePetName does not exactly equal one of the array entries.
  if(companions.length===0) return;
  let i = companions.indexOf(activePetName);
  if(i < 0){
    // Attempt to locate by species name if the exact string isn't found
    const bn = baseName(activePetName);
    i = companions.findIndex(nm => baseName(nm) === bn);
  }
  if(i < 0){ i = 0; }
  i = (i + 1) % companions.length;
  activePetName = companions[i];
  syncInventoryUI();
}
function actionButton(){
  if(scene!=='house'){
    const nearHouse = (scene==='meadow' && Math.hypot(player.x-housePos.x, player.y-housePos.y) < 1.2);
    const nearBack = portals.back && Math.hypot(player.x-portals.back.x, player.y-portals.back.y)<1.2;
    const nearForward = portals.forward && Math.hypot(player.x-portals.forward.x, player.y-portals.forward.y)<1.2;
    const n = nearNPC(); // returns NPC or null

    if(nearHouse){
      // entering the house plays a portal sound
      playSound('sndPortal');
      genHouse();
      return;
    }
    if(n){ interactNPC(n); return; }
    if(nearBack){
      // travelling to previous biome plays portal sound
      playSound('sndPortal');
      goPrevScene();
      return;
    }
    if(nearForward){
      // travelling to next biome plays portal sound
      playSound('sndPortal');
      goNextScene();
      return;
    }

    const t=tag();
    if(t==='BRIDGE'){
      const tx=Math.floor(player.x+lastDir.x), ty=Math.floor(player.y+lastDir.y);
      if(inBounds(tx,ty) && map[idx(tx,ty)]===TYPES.WATER){ map[idx(tx,ty)]=TYPES.BRIDGE; toast('Beaver built a bridge.'); }
      else toast('No water ahead to bridge.', true);
    } else if(t==='SCOUT'||t==='SCENT'){ pingAnimalsTimer=300; toast('Scanning for animals…'); }
    else toast('No active action for this companion.');
  } else {
    const p=getInteractionTarget(); if(!p){ toast('Stand on/next to a slot and press Enter/E.', true); return; }
    const {tx,ty,tile}=p; if(tile===TYPES.DOOR){
      // exiting house back to meadow plays portal sound
      playSound('sndPortal');
      genScene('meadow');
      return;
    }
    if([TYPES.ENC_WATER,TYPES.ENC_LAND,TYPES.ENC_AIR].includes(tile)){
      const k = tile===TYPES.ENC_WATER?'water':(tile===TYPES.ENC_LAND?'land':'air');
      const slotIndex = slotIndexAt(k, tx, ty); if(slotIndex<0) return;
      const arr = enclosures[k];
      if(arr[slotIndex]){ companions.push(arr[slotIndex].name); arr[slotIndex]=null; toast('Retrieved'); syncInventoryUI(); }
      else{
        if(!activePetName){ toast('No active companion selected.', true); return; }
        if(kind()!==k){ toast('Wrong habitat.', true); return; }
        // Remove the active companion by matching base names in case names include stars or rarity markers
        const ci = companions.findIndex(nm => baseName(nm) === baseName(activePetName));
        if(ci < 0){ toast('You do not have '+activePetName, true); return; }
        companions.splice(ci,1);
        const cap = 70 + 10*(decor[k]||0);
        arr[slotIndex]={name:activePetName, px:rand(4,12), py:rand(4,12), happy:Math.min(60,cap)};
        toast('Placed '+activePetName+' in '+k+' enclosure.'); syncInventoryUI();
      }
    }
  }
}
function getInteractionTarget(){
  const px=Math.floor(player.x), py=Math.floor(player.y);
  const under=inBounds(px,py)?{tx:px,ty:py,tile:map[idx(px,py)]}:null;
  if(under && [TYPES.ENC_WATER,TYPES.ENC_LAND,TYPES.ENC_AIR,TYPES.DOOR].includes(under.tile)) return under;
  const adjx=px+lastDir.x, adjy=py+lastDir.y; if(inBounds(adjx,adjy)) return {tx:adjx,ty:adjy,tile:map[idx(adjx,adjy)]};
  return null;
}
function nearNPC(){
  for(const n of npcs){
    if(Math.hypot(player.x-n.x, player.y-n.y) < 1.2) return n;
  }
  return null;
}
function interactNPC(n){
  if(n.type==='main'){
    let deliveredNow=[];
    for(const need of quest.need){
      if(quest.delivered && quest.delivered.includes(need)) continue;
      const ii=companions.findIndex(nm=>baseName(nm)===need);
      if(ii>=0){ companions.splice(ii,1); (quest.delivered||(quest.delivered=[])).push(need); deliveredNow.push(need); }
    }
    if(deliveredNow.length){ toast('Delivered: '+deliveredNow.join(', ')); syncInventoryUI(); }
    if(quest.delivered && quest.delivered.length===quest.need.length && !quest.complete){
      quest.complete=true;
      coins += quest.rewards.coins||0;
      toast('Quest complete! +' + (quest.rewards.coins||0) + ' coins.');
      // play quest completion sound
      playSound('sndQuest');
      // Unlock the next biome if the quest signals it
      if(quest.rewards.open_next){
        unlockNextScene();
      }
      // After awarding coins and potentially unlocking, refresh UI and quest status
      syncInventoryUI();
      syncQuestUI();
    } else {
      const remaining = quest.need.filter(nm=>!(quest.delivered||[]).includes(nm));
      toast(remaining.length?('Quest: Bring '+remaining.join(' & ')) : 'Quest already complete.' );
    }
  } else if(n.type==='trade'){
    // simple trade: 2x Beaver -> Iguana (example varies per scene)
    const offers={ meadow:{give:'Beaver',take:'Iguana'},
                   forest:{give:'Otter', take:'Owl'},
                   desert:{give:'Lizard',take:'Camel'},
                   wetlands:{give:'Frog', take:'Heron'} }[scene];
    const have = companions.filter(nm=>baseName(nm)===offers.give).length;
    if(have>=2){ // do trade
      let removed=0;
      for(let i=companions.length-1;i>=0 && removed<2;i--){ if(baseName(companions[i])===offers.give){ companions.splice(i,1); removed++; } }
      companions.push(offers.take);
      toast('Traded 2× '+offers.give+' for '+offers.take+'.');
      syncInventoryUI();
    } else {
      toast('Trade needs 2× '+offers.give+'.');
    }
  } else if(n.type==='market'){
    // Open the market sidebar to sell animals for coins
    openMarket();
  }
}

/* ===== Scene navigation ===== */
function goNextScene(){
  const i=SCENES.indexOf(scene);
  const next=SCENES[(i+1)%SCENES.length];
  genScene(next);
}
function goPrevScene(){
  const i=SCENES.indexOf(scene);
  const prev=SCENES[(i-1+SCENES.length)%SCENES.length];
  genScene(prev);
}

/* ===== UI sync ===== */
function syncInventoryUI(){
  const counts={}; for(const n of companions){ const bn=baseName(n); counts[bn]=(counts[bn]||0)+1; }
  const grid=document.getElementById('inventoryGrid_sb'); grid.innerHTML='';
  Object.keys(counts).sort().forEach(n=>{
    const a=info(n)||{}; const div=document.createElement('div'); div.className='card';
    div.innerHTML=`<b>${n}</b><div class="note">${(a.kind||'').toUpperCase()} — ${a.ability||''}</div><div class="note">Owned: ${counts[n]}</div>`;
    grid.appendChild(div);
  });
  const sel=document.getElementById('petSelect_sb');
  sel.innerHTML = companions.map(n=>`<option value="${n}" ${n===activePetName?'selected':''}>${n}</option>`).join('');
  if(!activePetName && companions.length>0){ activePetName=companions[0]; }
  setBoth('activePetName','activePetName2', activePetName || 'None');
  setBoth('activeAbility','activeAbility2', (info(activePetName)?.tag)||'—');
  setBoth('petCount','petCount2', String(companions.length));
  setBoth('coinsLabel','coinsLabel2', String(coins)); setText('coinsLabelInv', String(coins));
  updateJournal(); syncQuestUI();
  // Update shop button states when inventory or coins change
  if(typeof updateShopButtons === 'function'){ updateShopButtons(); }
}
document.getElementById('setActive_sb').addEventListener('click', ()=>{ activePetName=(document.getElementById('petSelect_sb').value)||null; syncInventoryUI(); });
function updateJournal(){
  const species=[...new Set(animals.map(a=>a.name))];
  setBoth('discTotal','discTotal2', String(species.length));
  setBoth('discCount','discCount2', String(discovered.size));
  const grid=document.getElementById('journalGrid_sb'); grid.innerHTML='';
  species.forEach(n=>{
    const card=document.createElement('div'); card.className='dex'+(discovered.has(n)?'':' locked');
    const cv=document.createElement('canvas'); cv.width=48; cv.height=48; const ctx=cv.getContext('2d'); drawAnimalIcon(ctx, n, 16,16, 1.5); card.appendChild(cv);
    const nm=document.createElement('div'); nm.className='name'; nm.textContent=discovered.has(n)?n:'???'; card.appendChild(nm);
    grid.appendChild(card);
  });
}
function syncQuestUI(){
  setBoth('sceneLabel','sceneLabel2', scene.charAt(0).toUpperCase()+scene.slice(1));
  const html = `<b>${quest.name||''}</b><br>${quest.desc||quest.description||''}<br><br>` +
    (quest.complete? `<span style="color:#35c48d">Completed ✓</span>` :
     `Needed:<br>${quest.need.map(n=> (quest.delivered||[]).includes(n)?'✓ '+n:'— '+n).join('<br>')}`);
  const qb=document.getElementById('questBox_sb'); if(qb) qb.innerHTML=html;
}

/* ===== Market system ===== */
// Base value per rarity tier (tier 1 = common, 5 = legendary)
const rarityBaseValue = {1:5, 2:12, 3:30, 4:60, 5:120};

// Compute base price for an animal name
function getBasePrice(name){
  const a = info(name);
  const r = a?.rarity || 2;
  return rarityBaseValue[r] || 10;
}

// Compute the current market price for a given animal name
function computeMarketPrice(name){
  const base = getBasePrice(name);
  // Random fluctuation ±20%
  const fluct = 0.8 + Math.random()*0.4;
  // Foreign animals (not from this biome) get 50% bonus
  const a = info(name);
  const foreign = (a?.home && a.home !== scene);
  const mult = foreign ? 1.5 : 1.0;
  let price = Math.max(1, Math.floor(base * fluct * mult));
  // Apply any cheat-driven market multiplier
  price = Math.floor(price * marketMultiplier);
  return price;
}

// Render the market panel with current inventory and prices
function renderMarket(){
  const panel = document.getElementById('marketPanel_sb');
  if(!panel) return;
  panel.innerHTML = '';
  // Compute counts per species
  const counts = {};
  for(const n of companions){ const bn=baseName(n); counts[bn] = (counts[bn]||0) + 1; }
  const names = Object.keys(counts);
  if(names.length === 0){
    const div = document.createElement('div');
    div.textContent = 'No animals to sell.';
    panel.appendChild(div);
    return;
  }
  currentMarketPrices = {};
  // Sort names alphabetically for consistent listing
  names.sort();
  for(const nm of names){
    const price = computeMarketPrice(nm);
    currentMarketPrices[nm] = price;
    const row = document.createElement('div');
    row.className = 'row';
    row.style.display = 'flex';
    row.style.justifyContent = 'space-between';
    row.style.alignItems = 'center';
    row.style.marginBottom = '6px';
    const left = document.createElement('div');
    left.innerHTML = `<b>${nm}</b><br><span class="note">Owned: ${counts[nm]}</span>`;
    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.alignItems = 'center';
    const priceSpan = document.createElement('span');
    priceSpan.textContent = price + ' coins';
    priceSpan.style.marginRight = '8px';
    const btn = document.createElement('button');
    btn.className = 'pill';
    btn.textContent = 'Sell';
    btn.setAttribute('data-sell', nm);
    right.appendChild(priceSpan);
    right.appendChild(btn);
    row.appendChild(left);
    row.appendChild(right);
    panel.appendChild(row);
  }
  // Attach sell handlers
  panel.querySelectorAll('button[data-sell]').forEach(btn => {
    btn.onclick = (e) => {
      const bn = btn.getAttribute('data-sell');
      sellAnimal(bn);
    };
  });
}

// Open the market sidebar and render current inventory prices
function openMarket(){
  renderMarket();
  // Use generic sidebar open helper; no toggle button associated
  openSidebar(sbMarket);
}

// Sell one instance of the given baseName
function sellAnimal(speciesName){
  // Find first occurrence in companions (including rarities)
  const index = companions.findIndex(nm => baseName(nm) === speciesName);
  if(index < 0) return;
  // Remove companion and award coins
  companions.splice(index, 1);
  const price = currentMarketPrices[speciesName] || computeMarketPrice(speciesName);
  coins += price;
  toast('Sold ' + speciesName + ' for ' + price + ' coins.');
  // Refresh inventory and market list
  syncInventoryUI();
  renderMarket();
}

/* ===== Render ===== */
function draw(){
  // Reveal fog
  if(scene!=='house'){
    const r=revealRadius();
    for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){
      const px=Math.floor(player.x)+x, py=Math.floor(player.y)+y;
      if(!inBounds(px,py)) continue; if(x*x+y*y<=r*r) fog[idx(px,py)]=1;
    }
  } else { fog.fill(1); }
  // camera (40x22 tiles fits 960x528 at TILE=24)
  const viewW=40, viewH=22;
  const camX=clamp(Math.floor(player.x - viewW/2), 0, mapW - viewW);
  const camY=clamp(Math.floor(player.y - viewH/2), 0, mapH - viewH);
  g.clearRect(0,0,game.width,game.height);

  // tiles
  for(let y=0;y<viewH;y++){
    for(let x=0;x<viewW;x++){
      const tx=camX+x, ty=camY+y, t=inBounds(tx,ty)?map[idx(tx,ty)]:TYPES.GRASS;
      // base tile
      g.fillStyle=typeColor[t]||'#20314f'; g.fillRect(x*TILE,y*TILE,TILE,TILE);
      if(scene!=='house'){
        if(t===TYPES.FOREST){ g.fillStyle='#183a22'; g.fillRect(x*TILE+8,y*TILE+4,8,14); }
        else if(t===TYPES.MOUNTAIN){ g.fillStyle='#a5adb9'; g.fillRect(x*TILE+6,y*TILE+6,12,12); }
        else if(t===TYPES.HOUSE){
          g.fillStyle='#b64732'; g.fillRect(x*TILE+3, y*TILE+3, 18, 7);
          g.fillStyle='#e6d3a1'; g.fillRect(x*TILE+5, y*TILE+10, 14, 10);
          g.fillStyle='#5a3b29'; g.fillRect(x*TILE+11, y*TILE+14, 2, 6);
          g.fillStyle='#2b3147'; g.fillRect(x*TILE+7, y*TILE+12, 3, 3);
          g.fillStyle='#2b3147'; g.fillRect(x*TILE+15, y*TILE+12, 3, 3);
        }
        else if(t===TYPES.BRIDGE){ g.fillStyle='#b98547'; g.fillRect(x*TILE, y*TILE+10, TILE, 4); }
        else if(t===TYPES.PATH){ g.fillStyle='#5e7b4f'; g.fillRect(x*TILE, y*TILE, TILE, TILE); }
        else if(t===TYPES.PORTAL){ g.fillStyle='#ff8c00'; g.fillRect(x*TILE+4,y*TILE+4,16,16); g.fillStyle='#000'; g.fillRect(x*TILE+10,y*TILE+6,4,12); }
        else if(t===TYPES.NPC){
          // Determine the type of NPC at this location so we can draw variants
          let npcType = null;
          for(const npc of npcs){
            if(npc.x===tx && npc.y===ty){ npcType = npc.type||null; break; }
          }
          drawNPC(x*TILE,y*TILE,npcType);
        }
      } else {
        if(t===TYPES.WALL){ g.fillStyle='#525d7a'; g.fillRect(x*TILE+2,y*TILE+2,TILE-4,TILE-4); }
        if(t===TYPES.DOOR){ g.fillStyle='#ffcc00'; g.fillRect(x*TILE+4,y*TILE+6,16,12); }
        if(t===TYPES.SIGN){ g.fillStyle='#aaaaaa'; g.fillRect(x*TILE+6,y*TILE+6,12,8); }
        if(t===TYPES.THEME_MEADOW){ g.fillStyle='#356c40'; g.fillRect(x*TILE+4,y*TILE+15,16,3); g.fillStyle='#3fa44e'; g.fillRect(x*TILE+8,y*TILE+12,4,3); }
        if(t===TYPES.THEME_WATER){ g.fillStyle='rgba(255,255,255,0.08)'; g.fillRect(x*TILE+2,y*TILE+6,20,3); g.fillRect(x*TILE+5,y*TILE+12,14,2); }
        if(t===TYPES.THEME_DESERT){ g.fillStyle='#b69454'; g.fillRect(x*TILE+6,y*TILE+14,12,2); g.fillStyle='#c9a765'; g.fillRect(x*TILE+10,y*TILE+10,4,2); }
        if(t===TYPES.THEME_AIR){ g.fillStyle='rgba(255,255,255,0.25)'; g.fillRect(x*TILE+5,y*TILE+6,14,6); }
        if([TYPES.ENC_WATER,TYPES.ENC_LAND,TYPES.ENC_AIR].includes(t)){
          g.fillStyle = t===TYPES.ENC_WATER?'#1f6c8f':(t===TYPES.ENC_LAND?'#3a5f3a':'#6b6b2b');
          g.fillRect(x*TILE+2,y*TILE+2,TILE-4,TILE-4);
          const k = t===TYPES.ENC_WATER?'water':(t===TYPES.ENC_LAND?'land':'air');
          const tx2=tx, ty2=ty; const slot = slotIndexAt(k, tx2, ty2);
          const entry=(k==='water'?enclosures.water:k==='land'?enclosures.land:enclosures.air)[slot];
          if(entry){
            entry.px+=(Math.random()-.5)*0.8; entry.py+=(Math.random()-.5)*0.8;
            entry.px=Math.max(4,Math.min(12,entry.px)); entry.py=Math.max(4,Math.min(12,entry.py));
            drawAnimalAt((x*TILE)+entry.px,(y*TILE)+entry.py, entry.name, 1.0);
            g.fillStyle='#000'; g.fillRect(x*TILE+3,y*TILE+3,18,3);
            g.fillStyle='#35c48d'; g.fillRect(x*TILE+3,y*TILE+3, Math.floor(18*(entry.happy||50)/100),3);
          }
        }
      }
      // fog overlay for overworld scenes
      if(scene!=='house' && !fog[idx(tx,ty)]){ g.fillStyle='rgba(0,0,0,.45)'; g.fillRect(x*TILE,y*TILE,TILE,TILE); }
    }
  }
  // animals
  if(scene!=='house'){
    for(const s of wildSpawns){
      if(s.x>=camX && s.x<camX+viewW && s.y>=camY && s.y<camY+viewH){
        const seenFog=fog[idx(s.x,s.y)];
        const ax=(s.x-camX)*TILE, ay=(s.y-camY)*TILE;
        drawAnimalAt(ax+6,ay+6,s.name, seenFog?1:0.35);
        if(s.rare && seenFog){ g.fillStyle='#ffd700'; g.fillRect(ax+2, ay+2, 3,3); }
      }
    }
  }
  // player
  const px=(player.x-camX)*TILE, py=(player.y-camY)*TILE; drawPlayer(px,py);

  // overlays
  if(scene!=='house' && isNight()){ g.fillStyle='rgba(0,0,40,0.25)'; g.fillRect(0,0,game.width,game.height); }
  if(scene==='desert' && weather===WEATHER.SAND){ g.fillStyle='rgba(200,180,80,0.15)'; g.fillRect(0,0,game.width,game.height); }
  if(scene!=='house' && weather===WEATHER.RAIN){ g.fillStyle='rgba(120,160,255,0.35)'; for(let i=0;i<90;i++){ const x=Math.random()*game.width, y=Math.random()*game.height; g.fillRect(x,y,2,8); } }

  // CTA labels
  if(scene!=='house'){
    const nearHouse = (scene==='meadow' && Math.hypot(player.x-housePos.x, player.y-housePos.y) < 1.2);
    const nearBack = portals.back && Math.hypot(player.x-portals.back.x, player.y-portals.back.y)<1.2;
    const nearForward = portals.forward && Math.hypot(player.x-portals.forward.x, player.y-portals.forward.y)<1.2;
    ctaEnter.style.display = (nearHouse||nearBack||nearForward)?'inline-block':'none';
    if(nearHouse) ctaEnter.textContent='Enter House (E)';
    else if(nearBack) ctaEnter.textContent='Prev Biome (E)';
    else if(nearForward) ctaEnter.textContent='Next Biome (E)';
    ctaExit.style.display='none';
  } else {
    ctaEnter.style.display='none'; ctaExit.style.display='inline-block'; ctaExit.textContent='Exit (E)';
  }

  setBoth('timeLabel','timeLabel2', timeString());
  setBoth('weatherLabel','weatherLabel2', weather);
  drawMini();

  // Update the mobile HUD sprite.  On mobile, a dedicated canvas displays
  // a large icon for the currently active companion.  We draw the sprite
  // scaled up to fill the canvas.  When no companion is active, the
  // canvas remains blank.  The base animal sprite is roughly 12px
  // wide, so use the canvas width divided by 12 as the scale factor.
  const spriteCanvas2 = document.getElementById('activeSprite2');
  if(spriteCanvas2){
    const sctx = spriteCanvas2.getContext('2d');
    sctx.clearRect(0, 0, spriteCanvas2.width, spriteCanvas2.height);
    if(activePetName){
      const bn = baseName(activePetName);
      // calculate scale: canvas width divided by 12; clamp to avoid
      const scale = spriteCanvas2.width / 12;
      drawAnimalSprite(sctx, bn, 0, 0, scale);
    }
  }

  // Update the desktop HUD sprite.  This canvas mirrors the mobile sprite
  // but is shown only on large screens.  If no companion is active, it
  // remains blank.
  const spriteCanvas = document.getElementById('activeSprite');
  if(spriteCanvas){
    const dctx = spriteCanvas.getContext('2d');
    dctx.clearRect(0, 0, spriteCanvas.width, spriteCanvas.height);
    if(activePetName){
      const bn2 = baseName(activePetName);
      const scale2 = spriteCanvas.width / 12;
      drawAnimalSprite(dctx, bn2, 0, 0, scale2);
    }
  }

  // Confetti / party visuals.  When the partyTimeTimer is active, draw
  // colourful squares randomly across the game canvas.  The effect is purely
  // cosmetic and lasts until the timer expires.
  if(partyTimeTimer > 0){
    const colours = ['#ff3e3e','#ff9f1c','#f5e663','#2ec4b6','#23ce6b','#3a86ff','#ff006e'];
    for(let i=0;i<60;i++){
      const cx=Math.random()*game.width;
      const cy=Math.random()*game.height;
      g.fillStyle = colours[Math.floor(Math.random()*colours.length)];
      g.fillRect(cx, cy, 3, 3);
    }
  }
}
function drawNPC(ax,ay,type){
  // Draw a non-player character.  The default NPC uses a beige head and dark shirt.
  // Market vendors are drawn with an orange shirt and a light purple tile behind them.
  if(type==='market'){
    // Light purple backdrop for vendor's tile
    g.fillStyle = '#5a3b7a';
    g.fillRect(ax, ay, TILE, TILE);
    // Head
    g.fillStyle = '#f2d3a0';
    g.fillRect(ax+8, ay+6, 8, 8);
    // Body (orange shirt)
    g.fillStyle = '#ff8c00';
    g.fillRect(ax+6, ay+14, 12, 8);
  } else {
    // Default NPC colors
    g.fillStyle='#f2d3a0'; g.fillRect(ax+8,ay+6,8,8);
    g.fillStyle='#6a3a1a'; g.fillRect(ax+6,ay+14,12,8);
  }
  // Eyes
  g.fillStyle='#000'; g.fillRect(ax+11,ay+9,2,2);
  // Exclamation mark above head to indicate interactable NPC
  g.fillStyle='#fff'; g.font='10px monospace'; g.fillText('!', ax+12, ay+4);
}
function drawPlayer(px,py){
  // If the player is invisible (due to a cheat), do not draw the sprite
  if(playerInvisible) return;
  g.fillStyle='#eaeaea'; g.fillRect(px+8,py+6,8,8);
  g.fillStyle='#3a75c4'; g.fillRect(px+6,py+14,12,8);
  g.fillStyle='#2b2b2b'; g.fillRect(px+6,py+22,5,2); g.fillRect(px+13,py+22,5,2);
  g.fillStyle='#000'; g.fillRect(px+11,py+9,2,2);
}
function drawMini(){
  // Draw the minimap on all available minimap contexts (desktop and mobile).
  const canvases=[];
  if(mctx) canvases.push({ctx:mctx, width: mini.width, height: mini.height});
  if(mctxMobile) canvases.push({ctx:mctxMobile, width: miniMobile.width, height: miniMobile.height});
  for(const {ctx,width,height} of canvases){
    ctx.clearRect(0,0,width,height);
    const sx=width/mapW, sy=height/mapH;
    for(let y=0;y<mapH;y++) for(let x=0;x<mapW;x++){
      const t=map[idx(x,y)]; ctx.fillStyle=typeColor[t]||'#20314f'; ctx.fillRect(x*sx,y*sy,sx,sy);
      if(scene!=='house' && !fog[idx(x,y)]){ ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(x*sx,y*sy,sx,sy); }
    }
    if(scene!=='house' && pingAnimalsTimer>0){
      ctx.fillStyle='#ffea00'; for(const s of wildSpawns){ if(fog[idx(s.x,s.y)]) ctx.fillRect(s.x*sx, s.y*sy, Math.max(1,sx), Math.max(1,sy)); }
    }
    ctx.fillStyle='#fff'; ctx.fillRect(player.x*sx-1, player.y*sy-1, 2,2);
  }
}
function drawAnimalAt(ax,ay,name,alpha=1){ g.save(); g.globalAlpha=alpha; drawAnimalSprite(g,baseName(name),ax,ay,1); g.restore(); }
function drawAnimalIcon(ctx,name,x,y,scale){ ctx.save(); drawAnimalSprite(ctx,name,x,y,scale); ctx.restore(); }
function drawAnimalSprite(ctx,name,x,y,s){
  function R(cx,cy,w,h,c){ ctx.fillStyle=c; ctx.fillRect(Math.floor(x+cx*s), Math.floor(y+cy*s), Math.ceil(w*s), Math.ceil(h*s)); }
  const a=info(name); const k=a?.kind||'land';
  const body = (name==='Frog') ? '#4fd36b' :
               (name==='Otter') ? '#8b5a3c' : (name==='Beaver') ? '#7a4e2b' :
               (name==='Salmon') ? '#e06a6a' : (name==='Trout') ? '#e0866a' :
               (name==='Turtle') ? '#6a8f5a' :
               (name==='Duck') ? '#d9e6ff' :
               (name==='Heron') ? '#cfd8e8' :
               (name==='Goat') ? '#cfcfcf' : (name==='Cheetah') ? '#d9a441' : (name==='Dog') ? '#b58b65' :
               (name==='Tortoise') ? '#6a8f5a' : (name==='Horse') ? '#7b4a2e' : (name==='Hawk') ? '#a07c3a' :
               (name==='Eagle') ? '#c8b18a' : (name==='Parrot') ? '#2aa84a' :
               (name==='Camel') ? '#b78b59' : (name==='Vulture') ? '#a09060' :
               (name==='Lizard'||name==='Iguana'||name==='Chameleon') ? '#66bb66' :
               (name==='Rabbit') ? '#c7c7c7' : (name==='Bear') ? '#5a4a3a' : (name==='Raccoon') ? '#7b7b7b' :
               (k==='water') ? '#40c3ff' : (k==='air') ? '#e0e668' : '#ffd166';
  const accent = '#000';
  R(1,4,10,6,body);
  if(['Hawk','Eagle','Parrot','Owl','Falcon','Vulture','Heron'].includes(name)) R(9,5,3,2,'#ffd966');
  else if(['Otter','Beaver','Dog','Horse','Goat','Cheetah','Tortoise','Camel','Bear','Rabbit','Raccoon','Lizard','Chameleon','Iguana'].includes(name)) R(9,5,2,2,'#f0e0d0');
  else if(['Salmon','Trout','Duck','Turtle'].includes(name)) R(0,5,3,2,'#8ddbe0');
  if(k==='land'){ R(2,10,2,2,accent); R(8,10,2,2,accent); }
  if(k==='water'){ R(0,7,2,2,accent); R(10,7,2,2,accent); }
  if(k==='air'){ R(0,4,2,4,accent); R(10,4,2,4,accent); }
  R(4,6,1,1,'#000'); R(6,6,1,1,'#000');
  if(name==='Cheetah'){ R(3,5,1,1,'#000'); R(5,7,1,1,'#000'); R(7,5,1,1,'#000'); }
}

/* ===== Loop ===== */
let last=0;
function update(dt){
  // Convert dt from milliseconds to seconds for time-based updates
  const dtSec = dt / 1000;
  // Decrement party/confetti timer if active
  if(partyTimeTimer > 0){
    partyTimeTimer = Math.max(0, partyTimeTimer - dtSec);
  }
  // If a mini-game is in progress, freeze movement and collisions.  Still
  // advance time, weather and legendary timers so the world stays alive.
  if(catchActive){
    // Advance game time: 30 in‑game minutes per real second
    timeMin = (timeMin + 30 * dtSec) % (24*60);
    // Weather timer counts down in seconds
    weatherTimer -= dtSec;
    if(weatherTimer <= 0){
      if(scene==='meadow'||scene==='forest'){ weather = Math.random()<0.25 ? WEATHER.RAIN : WEATHER.CLEAR; }
      else if(scene==='desert'){ weather = Math.random()<0.25 ? WEATHER.SAND : WEATHER.CLEAR; }
      else { weather = Math.random()<0.15 ? WEATHER.RAIN : WEATHER.CLEAR; }
      weatherTimer = 15 + Math.random()*10;
    }
    // Legendary timer
    legendaryTimer -= dtSec;
    if(legendaryTimer <= 0){
      spawnLegendaryEvent();
      legendaryTimer = 90 + Math.random()*90;
    }
    return;
  }
  // Determine intended movement direction from keys
  let dx=0,dy=0;
  if(keys['ArrowUp']||keys['w']||keys['W']) dy-=1;
  if(keys['ArrowDown']||keys['s']||keys['S']) dy+=1;
  if(keys['ArrowLeft']||keys['a']||keys['A']) dx-=1;
  if(keys['ArrowRight']||keys['d']||keys['D']) dx+=1;
  // Remember last non-zero direction to support facing for actions
  if(dx||dy) lastDir={x:dx,y:dy};
  // Normalize diagonal movement so speed remains constant in all directions
  if(dx||dy){ const len=Math.hypot(dx,dy); dx/=len; dy/=len; }
  const spd=speed();
  // Move according to elapsed time and per-second speed
  let nx=player.x + dx * spd * dtSec;
  let ny=player.y + dy * spd * dtSec;
  const t=inBounds(Math.floor(nx),Math.floor(ny))?map[idx(Math.floor(nx),Math.floor(ny))]:TYPES.GRASS;
  if(passable(t)){ player.x=clamp(nx,0,mapW-0.01); player.y=clamp(ny,0,mapH-0.01); }

  if(scene!=='house'){
    // Check for collisions with animals.  Common/uncommon animals (rarity ≤ 2) are collected
    // instantly, while rarer species trigger a mini‑game.  Only one interaction occurs per update.
    for(let i=wildSpawns.length-1;i>=0;i--){
      const s=wildSpawns[i];
      if(Math.hypot(player.x-s.x, player.y-s.y) < 0.5){
        const rarity = info(s.name)?.rarity || 1;
        if(rarity <= 2){
          collectAnimal(s);
        } else {
          startCatchGame(s);
        }
        // Stop checking other spawns this frame
        break;
      }
    }
    // Decrease the animal ping timer proportionally to real time (approx. 60 frames per second)
    if(pingAnimalsTimer>0) pingAnimalsTimer -= dtSec * 60;
  } else {
    // Enclosure happiness decays randomly over time; rate not tied to framerate
    if(Math.random()<0.02){
      ['water','land','air'].forEach(k=>{
        const cap=70 + 10*(decor[k]||0);
        (enclosures[k]||[]).forEach(e=>{ if(e){ e.happy=Math.max(0,(e.happy||50)-0.5); e.happy=Math.min(cap, e.happy); } });
      });
    }
  }

  // Advance game time: previously 0.5 minutes per frame at 60fps = 30 minutes per second.
  timeMin = (timeMin + 30 * dtSec) % (24*60);
  // Update weather timer measured in seconds.  Convert existing frame-based values to seconds by dividing by 60.
  weatherTimer -= dtSec;
  if(weatherTimer<=0){
    if(scene==='meadow'||scene==='forest'){ weather = Math.random()<0.25 ? WEATHER.RAIN : WEATHER.CLEAR; }
    else if(scene==='desert'){ weather = Math.random()<0.25 ? WEATHER.SAND : WEATHER.CLEAR; }
    else { weather = Math.random()<0.15 ? WEATHER.RAIN : WEATHER.CLEAR; }
    // Reset weather timer: previous 900–1500 frames becomes 15–25 seconds
    weatherTimer = 15 + Math.random()*10;
  }

  // Legendary event timer: spawn a rare legendary animal when timer expires
  legendaryTimer -= dtSec;
  if(legendaryTimer<=0){
    spawnLegendaryEvent();
    // Next legendary event occurs after 90–180 seconds
    legendaryTimer = 90 + Math.random()*90;
  }
}
function passable(t){
  if(scene==='house') return t!==TYPES.WALL;
  // Determine companion info and rarity for flight handling
  const comp = info(activePetName);
  const compTag = comp?.tag || null;
  const compRarity = comp?.rarity || 1;
  // Lava behaves like mountains: only powerful flight companions can traverse
  if(t===TYPES.LAVA){
    // Allow if climb or high‑rarity flight
    return tag()==='CLIMB' || (compTag==='FLIGHT' && compRarity>=4);
  }
  // Ice behaves like water: treat as water
  if(t===TYPES.ICE){
    return ['SWIM','SWIM+','SWIFT_SWIM','MOUNT'].includes(tag()) || compTag==='FLIGHT';
  }
  // Mountains: require climb or high‑rarity flight (rarity >=4)
  if(t===TYPES.MOUNTAIN){
    if(tag()==='CLIMB') return true;
    return compTag==='FLIGHT' && compRarity>=4;
  }
  // Water: allow swim abilities or any flight companion (even low rarity)
  if(t===TYPES.WATER){
    if(['SWIM','SWIM+','SWIFT_SWIM','MOUNT'].includes(tag())) return true;
    return compTag==='FLIGHT';
  }
  return true;
}
function loop(ts){ const dt = ts - last; last = ts; update(dt); draw(); drawToast(); requestAnimationFrame(loop); }

/* ===== Toasts ===== */
let toastTimer=0, toastMsg='', toastBad=false;
function toast(msg,bad=false,ms=1500){ toastMsg=msg; toastBad=bad; toastTimer=ms/16; }
function drawToast(){
  if(toastTimer>0){ dbg.textContent = toastMsg + (toastBad ? ' ⚠️' : ''); toastTimer--; }
  else { dbg.textContent = `running — ${scene}`; }
}

/* ===== Save/Load/Reset ===== */
function doSave(){
  const enc={
    scene,
    map:Array.from(map), mapW, mapH,
    fog:Array.from(fog),
    player,
    housePos,
    portals,
    npcs,
    companions,
    activePetName,
    enclosures,
    decor,
    discovered:[...discovered],
    timeMin,
    weather,
    coins,
    quest,
    // Persist XP, upgrades, achievements, legendary timer and unlocked scenes
    companionXP,
    playerUpgrades,
    achievementsAwarded,
    legendaryTimer,
    unlocked,
    rareCollectedCount
  };
  localStorage.setItem(saveKey, JSON.stringify(enc));
  toast('Saved.');
}
function doLoad(){
  const raw=localStorage.getItem(saveKey); if(!raw){ toast('No save.', true); return; }
  try{
    const enc=JSON.parse(raw);
    scene=enc.scene||'meadow'; mapW=enc.mapW; mapH=enc.mapH; map=new Uint8Array(enc.map); fog=new Uint8Array(enc.fog);
    player=enc.player; housePos=enc.housePos||housePos; portals=enc.portals||{back:null,forward:null}; npcs=enc.npcs||[];
    companions=enc.companions||[];
    activePetName=enc.activePetName||null;
    enclosures=enc.enclosures||{water:[],land:[],air:[]};
    decor=enc.decor||{water:0,land:0,air:0};
    discovered=new Set(enc.discovered||[]);
    timeMin=enc.timeMin||360;
    weather=enc.weather||WEATHER.CLEAR;
    coins=enc.coins||0;
    quest=enc.quest||quest;
    // Restore XP, upgrades, achievements, legendary timer and unlocked scenes
    companionXP = enc.companionXP || {};
    playerUpgrades = enc.playerUpgrades || { boots:false, lantern:false, cloak:false };
    achievementsAwarded = enc.achievementsAwarded || {};
    legendaryTimer = enc.legendaryTimer || 0;
    if(enc.unlocked){ Object.assign(unlocked, enc.unlocked); }
    rareCollectedCount = enc.rareCollectedCount || 0;
    // refresh procedural assets for current scene to avoid blank map artifacts
    genScene(scene);
    syncInventoryUI(); toast('Loaded.');
  }catch(e){ console.error(e); toast('Load failed.', true); }
}
function doReset(){
  localStorage.removeItem(saveKey);
  companions=[];
  activePetName=null;
  enclosures={water:[],land:[],air:[]};
  decor={water:0,land:0,air:0};
  discovered=new Set();
  coins=0;
  timeMin=360;
  weather=WEATHER.CLEAR;
  weatherTimer=0;
  // Reset XP, upgrades, achievements and legendary timer
  companionXP = {};
  playerUpgrades = { boots:false, lantern:false, cloak:false };
  achievementsAwarded = {};
  legendaryTimer = 0;
  // Reset unlocked scenes
  Object.assign(unlocked, { meadow:true, forest:false, desert:false, wetlands:false, volcano:false, glacier:false, mystic:false });
  // Reset rare animal progress
  rareCollectedCount = 0;
  genScene('meadow');
  syncInventoryUI();
  toast('New world.');
}

/* ===== Sidebars ===== */
const sbInventory=document.getElementById('sbInventory'), sbJournal=document.getElementById('sbJournal'), sbQuests=document.getElementById('sbQuests'), sbCare=document.getElementById('sbCare'), sbMarket=document.getElementById('sbMarket');
const toggleInventory=document.getElementById('toggleInventory'), toggleJournal=document.getElementById('toggleJournal'), toggleQuests=document.getElementById('toggleQuests'), toggleCare=document.getElementById('toggleCare');
const scrim=document.getElementById('scrim');
function openSidebar(sb,btn){ closeAllSidebars(); sb.classList.add('open'); scrim.classList.add('open'); if(btn) btn.setAttribute('aria-pressed','true'); }
function closeSidebar(sb,btn){ sb.classList.remove('open'); if(btn) btn.setAttribute('aria-pressed','false'); maybeHideScrim(); }
function closeAllSidebars(){
  [sbInventory,sbJournal,sbQuests,sbCare,sbMarket].forEach(el=>el.classList.remove('open'));
  [toggleInventory,toggleJournal,toggleQuests,toggleCare].forEach(b=>b.setAttribute('aria-pressed','false'));
  scrim.classList.remove('open');
}
function maybeHideScrim(){
  if(!sbInventory.classList.contains('open') && !sbJournal.classList.contains('open') && !sbQuests.classList.contains('open') && !sbCare.classList.contains('open') && !sbMarket.classList.contains('open')){
    scrim.classList.remove('open');
  }
}
toggleInventory.onclick=()=> sbInventory.classList.contains('open') ? closeSidebar(sbInventory,toggleInventory) : openSidebar(sbInventory,toggleInventory);
toggleJournal.onclick =()=> sbJournal.classList.contains('open')  ? closeSidebar(sbJournal,toggleJournal)   : openSidebar(sbJournal,toggleJournal);
toggleQuests.onclick  =()=> sbQuests.classList.contains('open')   ? closeSidebar(sbQuests,toggleQuests)    : openSidebar(sbQuests,toggleQuests);
toggleCare.onclick    =()=> sbCare.classList.contains('open')     ? closeSidebar(sbCare,toggleCare)        : openSidebar(sbCare,toggleCare);
document.querySelectorAll('.sbClose').forEach(btn=> btn.addEventListener('click', ()=>{ const id=btn.getAttribute('data-close'); const el=document.getElementById(id); if(el){ el.classList.remove('open'); maybeHideScrim(); } [toggleInventory,toggleJournal,toggleQuests,toggleCare].forEach(b=>b.setAttribute('aria-pressed','false')); }));
scrim.addEventListener('click', closeAllSidebars);

/* ===== Start Menu ===== */
const startMenu=document.getElementById('startMenu');
const startSave=document.getElementById('startSave');
const startLoad=document.getElementById('startLoad');
const startReset=document.getElementById('startReset');
const startClose=document.getElementById('startClose');
const startInstructions=document.getElementById('startInstructions');
const instructionsMenu=document.getElementById('instructionsMenu');
const instructionsClose=document.getElementById('instructionsClose');
const startShop=document.getElementById('startShop');
const shopMenu=document.getElementById('shopMenu');
const shopClose=document.getElementById('shopClose');

// Cheat menu elements
const startCheats=document.getElementById('startCheats');
const cheatMenu=document.getElementById('cheatMenu');
const cheatInput=document.getElementById('cheatInput');
const cheatSubmit=document.getElementById('cheatSubmit');
const cheatClose=document.getElementById('cheatClose');
const cheatList=document.getElementById('cheatList');

// Define all cheat codes along with a description and an action.  When a
// code is entered, its action will be executed.  All codes are case
// insensitive and must be entered exactly as listed.  Unlock codes set
// the corresponding biome to unlocked; spawn codes place an animal
// near the player; coin/stat cheats modify coins and upgrades; and
// fun codes adjust time, weather or visuals.
const cheatDefs={
  'MEADOWOPEN':{ desc:'Unlock Meadow portal', action:()=>{ unlocked.meadow=true; toast('Meadow unlocked!'); } },
  'FORESTOPEN':{ desc:'Unlock Forest portal', action:()=>{ unlocked.forest=true; toast('Forest unlocked!'); } },
  'DESERTOPEN':{ desc:'Unlock Desert portal', action:()=>{ unlocked.desert=true; toast('Desert unlocked!'); } },
  'WETLANDSOPEN':{ desc:'Unlock Wetlands portal', action:()=>{ unlocked.wetlands=true; toast('Wetlands unlocked!'); } },
  'VOLCANO':{ desc:'Unlock Volcano biome', action:()=>{ unlocked.volcano=true; toast('Volcano unlocked!'); } },
  'GLACIER':{ desc:'Unlock Glacier biome', action:()=>{ unlocked.glacier=true; toast('Glacier unlocked!'); } },
  'MYSTIC':{ desc:'Unlock Mystic biome', action:()=>{ unlocked.mystic=true; toast('Mystic unlocked!'); } },
  'SKYREALM':{ desc:'Unlock Sky biome (secret)', action:()=>{ unlocked.skyrealm=true; toast('Sky Realm unlocked!'); } },
  'UNDERSEA':{ desc:'Unlock Ocean biome (secret)', action:()=>{ unlocked.undersea=true; toast('Undersea unlocked!'); } },
  // Spawn animals
  'MYTHIC':{ desc:'Spawn a mythic animal (Phoenix/Dragon)', action:()=>{
    const mythics=['Phoenix','Dragon']; const nm=mythics[rand(0,mythics.length-1)]; spawnAnimalNear(nm); toast('Spawned '+nm+'!'); } },
  'LEGENDARY':{ desc:'Spawn a legendary animal', action:()=>{
    const legends=['Phoenix','Dragon']; const nm=legends[rand(0,legends.length-1)]; spawnAnimalNear(nm); toast('Spawned '+nm+'!'); } },
  'RARE':{ desc:'Spawn a rare animal', action:()=>{
    // Choose a random animal from the animals list with rarity >=3; fallback to random if none
    const rares=animals.filter(a=>(a.rarity||1)>=3).map(a=>a.name);
    const pool=rares.length?rares:animals.map(a=>a.name);
    const nm=pool[rand(0,pool.length-1)]; spawnAnimalNear(nm); toast('Spawned '+nm+'!'); } },
  'AXOLOTL':{ desc:'Spawn an Axolotl', action:()=>{ spawnAnimalNear('Axolotl'); toast('Spawned Axolotl!'); } },
  'PACMAN':{ desc:'Spawn a Pacman Frog', action:()=>{ spawnAnimalNear('Pacman Frog'); toast('Spawned Pacman Frog!'); } },
  'TREEFROG':{ desc:'Spawn a Tree Frog', action:()=>{ spawnAnimalNear('Tree Frog'); toast('Spawned Tree Frog!'); } },
  'LEOGECKO':{ desc:'Spawn a Leopard Gecko', action:()=>{ spawnAnimalNear('Leopard Gecko'); toast('Spawned Leopard Gecko!'); } },
  'CRESTIE':{ desc:'Spawn a Crested Gecko', action:()=>{ spawnAnimalNear('Crested Gecko'); toast('Spawned Crested Gecko!'); } },
  'BETTA':{ desc:'Spawn a Betta Fish', action:()=>{ spawnAnimalNear('Koi Fish'); toast('Spawned Koi Fish!'); } },
  // Coins and stats
  'RICHIE':{ desc:'+1000 coins', action:()=>{ coins+=1000; toast('+1000 coins'); syncInventoryUI(); } },
  'MONEYRAIN':{ desc:'+5000 coins', action:()=>{ coins+=5000; toast('+5000 coins'); syncInventoryUI(); } },
  'BUFFME':{ desc:'Speed boost (temporary)', action:()=>{ cheatSpeedMult=1.5; toast('Speed boost!'); } },
  'TANK':{ desc:'Defense boost (cosmetic)', action:()=>{ toast('You feel tougher!', false); } },
  'ULTRASPEED':{ desc:'Maximum speed', action:()=>{ cheatSpeedMult=2; toast('Ultra speed activated!'); } },
  // Enclosures and care
  'HAPPYHOME':{ desc:'Max happiness for all animals in house', action:()=>{
    ['water','land','air'].forEach(k=>{
      (enclosures[k]||[]).forEach(e=>{ if(e) e.happy=100; });
    }); toast('All enclosures happy!'); } },
  'PLANTUP':{ desc:'Add plants to each enclosure', action:()=>{
    decor.water=(decor.water||0)+3; decor.land=(decor.land||0)+3; decor.air=(decor.air||0)+3;
    toast('Added decor to enclosures'); } },
  'CLEANHOUSE':{ desc:'Clean all enclosures', action:()=>{
    ['water','land','air'].forEach(k=>{ (enclosures[k]||[]).forEach(e=>{ if(e) e.happy=Math.min(100,(e.happy||50)+10); }); }); toast('House cleaned!'); } },
  'FULLFEED':{ desc:'Feed all animals', action:()=>{
    ['water','land','air'].forEach(k=>{ (enclosures[k]||[]).forEach(e=>{ if(e) e.happy=Math.min(100,(e.happy||50)+10); }); }); toast('All animals fed!'); } },
  // Fun codes
  'MARKETMADNESS':{ desc:'Triple market prices temporarily', action:()=>{ marketMultiplier=3; toast('Markets are booming!'); } },
  'NIGHTOWL':{ desc:'Set time to midnight', action:()=>{ timeMin=0; toast('It is now midnight.'); } },
  'SUNSHINE':{ desc:'Set time to midday and clear weather', action:()=>{ timeMin=12*60; weather=WEATHER.CLEAR; toast('It is now midday.'); } },
  'RAINRAIN':{ desc:'Toggle rain', action:()=>{ weather=(weather===WEATHER.RAIN?WEATHER.CLEAR:WEATHER.RAIN); toast(weather===WEATHER.RAIN?'Rain started':'Rain stopped'); } },
  'SANDSTORM':{ desc:'Toggle sandstorm', action:()=>{ weather=(weather===WEATHER.SAND?WEATHER.CLEAR:WEATHER.SAND); toast(weather===WEATHER.SAND?'Sandstorm!':'Sandstorm cleared'); } },
  'FROGFEST':{ desc:'Spawn a swarm of frogs', action:()=>{
    const frogs=['Frog','Tree Frog','Pacman Frog']; for(let i=0;i<10;i++){ const nm=frogs[rand(0,frogs.length-1)]; spawnAnimalNear(nm); } toast('Frog Fest!'); } },
  'INVISIBLE':{ desc:'Toggle player invisibility', action:()=>{ playerInvisible = !playerInvisible; toast(playerInvisible?'You are invisible!':'You are visible again.'); } },
  'PARTYTIME':{ desc:'Confetti party for 20 seconds', action:()=>{ partyTimeTimer=20; toast('Party time!'); } }
};

// Spawn an animal near the player.  Chooses a nearby tile that is passable.  If
// no suitable tile is found after several attempts, the animal is spawned at
// the player's position.
function spawnAnimalNear(name){
  let placed=false; let px=Math.floor(player.x); let py=Math.floor(player.y);
  for(let attempt=0; attempt<20; attempt++){
    const dx=rand(-4,4), dy=rand(-4,4);
    const x=clamp(px+dx,0,mapW-1), y=clamp(py+dy,0,mapH-1);
    if(inBounds(x,y) && passable(map[idx(x,y)]) ){
      wildSpawns.push({x,y,name:name,rare:false}); placed=true; break;
    }
  }
  if(!placed){ wildSpawns.push({x:px,y:py,name:name,rare:false}); }
}

// Populate the cheat list with descriptions.  Called when opening the cheat menu.
function populateCheatList(){
  cheatList.innerHTML='';
  Object.keys(cheatDefs).forEach(code=>{
    const item=document.createElement('div');
    item.style.marginBottom='4px';
    item.innerHTML='<b>'+code+'</b> — '+cheatDefs[code].desc;
    cheatList.appendChild(item);
  });
}
// Show the cheat overlay
function showCheats(){
  hideStartMenu(); hideInstructions(); hideShop();
  populateCheatList();
  cheatMenu.style.display='block';
  scrim.classList.add('open');
}
// Hide the cheat overlay
function hideCheats(){
  cheatMenu.style.display='none';
  scrim.classList.remove('open');
}
// Execute a cheat code by uppercase string
function executeCheat(code){
  const def=cheatDefs[code];
  if(def){
    try{ def.action(); }catch(err){ console.error(err); toast('Cheat failed.', true); }
  } else {
    toast('Invalid code: '+code, true);
  }
}

// Definition of shop items with costs and display names
const shopItems={
  boots:{ cost:8, name:'Speed Boots' },
  lantern:{ cost:8, name:'Lantern' },
  cloak:{ cost:8, name:'Sand Cloak' }
};

// Show the shop overlay: hide start menu, update buttons, show scrim
function showShop(){
  hideStartMenu();
  shopMenu.style.display='block';
  updateShopButtons();
  scrim.classList.add('open');
}
// Hide the shop overlay
function hideShop(){
  shopMenu.style.display='none';
  scrim.classList.remove('open');
}
// Purchase an upgrade
function purchaseUpgrade(upg){
  const item=shopItems[upg];
  if(!item) return;
  if(playerUpgrades[upg]){ toast('Already purchased '+item.name+'.', true); return; }
  if(coins < item.cost){ toast('Not enough coins.', true); return; }
  coins -= item.cost;
  playerUpgrades[upg] = true;
  toast('Purchased '+item.name+'!');
  syncInventoryUI();
  updateShopButtons();
}
// Update shop button states based on ownership and coins
function updateShopButtons(){
  const btns = document.querySelectorAll('.purchaseBtn');
  btns.forEach(btn=>{
    const upg = btn.getAttribute('data-upgrade');
    const item = shopItems[upg];
    if(!item) return;
    if(playerUpgrades[upg]){
      btn.textContent='Owned';
      btn.disabled=true;
    } else {
      btn.textContent='Buy ('+item.cost+'c)';
      btn.disabled = (coins < item.cost);
    }
  });
}

function showStartMenu(){
  startMenu.style.display='block';
  scrim.classList.add('open');
}
function hideStartMenu(){
  startMenu.style.display='none';
  scrim.classList.remove('open');
}
function toggleStartMenu(){
  if(startMenu.style.display==='block') hideStartMenu();
  else { closeAllSidebars(); showStartMenu(); }
}

// Hook up start menu buttons to save/load/reset
startSave.onclick=()=>{ doSave(); hideStartMenu(); };
startLoad.onclick=()=>{ doLoad(); hideStartMenu(); };
startReset.onclick=()=>{ doReset(); hideStartMenu(); };
startClose.onclick=()=>{ hideStartMenu(); };
// Show instructions overlay when selected from the start menu
function showInstructions(){
  hideStartMenu();
  instructionsMenu.style.display='block';
  scrim.classList.add('open');
}
function hideInstructions(){
  instructionsMenu.style.display='none';
  scrim.classList.remove('open');
}
startInstructions.onclick=()=>{ showInstructions(); };
instructionsClose.onclick=()=>{ hideInstructions(); };

// Hook up the Shop button
startShop.onclick=()=>{ showShop(); };
// Close Shop when the close button is pressed
shopClose.onclick=()=>{ hideShop(); };
// Purchase buttons inside the shop: delegate purchase behaviour
document.querySelectorAll('.purchaseBtn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const upg = btn.getAttribute('data-upgrade');
    purchaseUpgrade(upg);
  });
});
// Hide overlays when scrim is tapped
scrim.addEventListener('click', ()=>{ hideStartMenu(); hideInstructions(); hideShop(); hideCheats(); });

// Save/Load/Reset controls are now accessible via the Start menu; inventory buttons removed
document.getElementById('btnFeedAll_sb').onclick=()=>{ ['water','land','air'].forEach(k=>{ (enclosures[k]||[]).forEach(e=>{ if(e) e.happy=Math.min(100,(e.happy||50)+10); }); }); toast('Fed all.'); };
document.getElementById('btnCleanAll_sb').onclick=()=>{ ['water','land','air'].forEach(k=>{ (enclosures[k]||[]).forEach(e=>{ if(e) e.happy=Math.min(100,(e.happy||50)+10); }); }); toast('Cleaned all.'); };
document.getElementById('btnAddDecorLand_sb').onclick =()=>{ decor.land=(decor.land||0)+1; toast('Added land decor.'); };
document.getElementById('btnAddDecorWater_sb').onclick=()=>{ decor.water=(decor.water||0)+1; toast('Added water decor.'); };
document.getElementById('btnAddDecorAir_sb').onclick  =()=>{ decor.air=(decor.air||0)+1; toast('Added air decor.'); };

/* ===== Cheat Codes ===== */
// When the cheat button is pressed in the start menu, show the cheat overlay
startCheats.onclick=()=>{ showCheats(); };
// Handle cheat submission
cheatSubmit.onclick=()=>{
  const code = (cheatInput.value||'').trim().toUpperCase();
  if(code) executeCheat(code);
  cheatInput.value='';
};
// Close the cheat overlay
cheatClose.onclick=()=>{ hideCheats(); };

/* ===== Boot ===== */
function boot(){
  genScene('meadow'); // fresh
  syncInventoryUI();
  requestAnimationFrame(loop);
  ctaEnter.onclick=()=>actionButton(); ctaExit.onclick =()=>actionButton();

  // Initialize legendary event timer at start
  legendaryTimer = 90 + Math.random()*90;

  // Reset cheat-related state on boot
  cheatSpeedMult = 1;
  playerInvisible = false;
  marketMultiplier = 1;
  partyTimeTimer = 0;
}
if(document.readyState==='complete' || document.readyState==='interactive'){ boot(); }
else { window.addEventListener('DOMContentLoaded', boot); }
})();
</script>
</body>
</html>