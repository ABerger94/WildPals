<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<title>Wild Pals — Shell v1 (Clean GBC/GBA UI)</title>
<style>
  :root{
    --ink:#e9f1ff; --bg:#0b1020;
    /* GBC palette */
    --gbc-aqua:#54C9C1; --gbc-aqua-dark:#3CA79F; --gbc-aqua-light:#7EDDD7;
    --gbc-bezel:#0b0b0b; --gbc-screen:#222; --gbc-shadow:rgba(0,0,0,.45);
    /* GBA palette */
    --gba-body1:#5860A3; --gba-body2:#3F447D; --gba-body3:#2B2E57;
    /* Buttons */
    --btnA:#6C38FF; --btnB:#FF3B5C; --btnStart:#4a4a4a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial}

  /* ===== Shared topbar ===== */
  .topbar{display:flex;align-items:center;justify-content:space-between;
    font-weight:800;letter-spacing:.08em;margin-bottom:10px;color:#dfe8ff}
  .topbar .power{display:flex;gap:6px;align-items:center;color:#ddd;font-size:12px}
  .topbar .led{width:10px;height:10px;border-radius:999px;
    background:radial-gradient(circle at 30% 30%,#f66,#a11414);
    box-shadow:0 0 10px #f33,inset 0 0 2px #fff}

  /* ===== GBC Portrait Shell ===== */
  .gbc-shell{
    max-width:min(920px,96vw);
    margin:14px auto;
    padding:18px 18px 24px;
    background:linear-gradient(160deg,var(--gbc-aqua-light),var(--gbc-aqua) 40%,var(--gbc-aqua-dark) 100%);
    border-radius:22px;
    box-shadow:0 18px 36px var(--gbc-shadow), inset 0 6px 0 rgba(255,255,255,.08), inset 0 -6px 0 rgba(0,0,0,.12);
    border:2px solid rgba(0,0,0,.2);
  }
  .gbc-face{
    background:linear-gradient(180deg,#1b1b1b,#111);
    border-radius:16px; padding:16px;
    box-shadow:inset 0 6px 14px rgba(0,0,0,.55);
    color:#dfe8ff;
  }
  .gb-screen{
    background:var(--gbc-bezel); border-radius:14px; padding:14px;
    box-shadow: inset 0 0 0 2px rgba(255,255,255,.05), inset 0 0 24px rgba(0,0,0,.8);
  }
  #canvasBox{background:var(--gbc-screen); border:1px solid rgba(255,255,255,.06); border-radius:10px; box-shadow: inset 0 0 24px rgba(0,0,0,.65); overflow:hidden}
  #game{display:block; width:100%; height:auto; image-rendering:pixelated; background:#20314f}
  .gb-screen::after{
    content:""; display:block; width:120px; height:40px; margin:10px 0 0 auto;
    background:
      radial-gradient(circle at 6px 6px, rgba(0,0,0,.8) 3px, transparent 4px) 0 0/16px 16px,
      radial-gradient(circle at 14px 14px, rgba(0,0,0,.8) 3px, transparent 4px) 0 0/16px 16px;
    opacity:.45; filter:drop-shadow(0 1px 0 rgba(255,255,255,.05)); border-radius:6px;
  }

  /* Portrait controls */
  #mobileControls{
    display:grid;
    grid-template-columns: 160px 1fr 160px;
    grid-template-rows: auto auto;
    gap:12px;
    background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.15));
    border:1px solid rgba(255,255,255,.06); border-radius:14px;
    box-shadow: inset 0 8px 22px rgba(0,0,0,.5), 0 10px 22px rgba(0,0,0,.35);
    padding:16px; margin-top:12px;
  }
  .dpad{grid-column:1; grid-row:1 / span 2; width:160px; height:160px; position:relative;
        background:#0e0e14; border:1px solid #232323; border-radius:16px; box-shadow:inset 0 8px 14px rgba(0,0,0,.6)}
  .dpad .cross{position:absolute; inset:0; margin:auto; width:120px; height:120px; background:#1a1a1a; border-radius:14px}
  .dpad .cross::before,.dpad .cross::after{content:""; position:absolute; background:#1a1a1a; border-radius:12px}
  .dpad .cross::before{left:0; right:0; top:50%; height:40px; transform:translateY(-50%)}
  .dpad .cross::after{top:0; bottom:0; left:50%; width:40px; transform:translateX(-50%)}
  .dpad button{position:absolute; width:60px; height:60px; background:#111; border:1px solid #2a2a2a; border-radius:14px; color:#98a4b9; font-weight:900; font-size:18px; touch-action:manipulation}
  #btnUp{left:50%; top:6px; transform:translateX(-50%)}
  #btnDown{left:50%; bottom:6px; transform:translateX(-50%)}
  #btnLeft{left:6px; top:50%; transform:translateY(-50%)}
  #btnRight{right:6px; top:50%; transform:translateY(-50%)}

  .actCluster{grid-column:3; grid-row:1; width:140px; height:120px; position:relative; margin:auto}
  .actCluster .btn{position:absolute; width:56px; height:56px; border-radius:999px; border:1px solid #1b2a52; color:#e9f1ff; font-weight:800; font-size:16px; box-shadow:inset 0 8px 18px rgba(0,0,0,.45); touch-action:manipulation}
  #btnA{background:var(--btnA); right:6px; top:8px}
  #btnB{background:var(--btnB); left:16px; bottom:6px}
  #btnZ{background:#3ECBA3; right:10px; bottom:6px; width:46px; height:46px; font-size:14px}
  .startRow{grid-column:3; grid-row:2; display:flex; justify-content:center; gap:12px; align-items:center}
  .startRow .tiny{min-width:auto; width:72px; height:32px; border-radius:999px; background:var(--btnStart); border:1px solid #222; color:white; font-weight:800; letter-spacing:.06em; font-size:12px; touch-action:manipulation}

  /* ===== GBA Landscape Shell ===== */
  .gba-shell{ display:none; }
  .gba-body{
    width:min(98vw,1200px);
    margin:10px auto;
    padding:18px;
    border-radius:42px;
    background:linear-gradient(160deg,var(--gba-body1),var(--gba-body2) 55%,var(--gba-body3));
    box-shadow: 0 20px 40px rgba(0,0,0,.55), inset 0 12px 22px rgba(255,255,255,.08), inset 0 -14px 28px rgba(0,0,0,.35);
    border:2px solid rgba(0,0,0,.28);
  }
  .gba-topbar{margin-bottom:12px;}
  .gba-tray{
    background:rgba(0,0,0,.18);
    border-radius:28px;
    padding:14px;
    box-shadow: inset 0 8px 24px rgba(0,0,0,.45), inset 0 -6px 18px rgba(255,255,255,.05);
  }
  #landscapeRow{
    display:grid;
    grid-template-columns: 172px 1fr 160px;
    gap:14px;
    align-items:center;
  }

  .land-dpad{ width:172px; height:172px; position:relative; margin:auto;
              background:#0e0e14; border:1px solid #232323; border-radius:18px; box-shadow:inset 0 8px 14px rgba(0,0,0,.6)}
  .land-dpad .cross{position:absolute; inset:0; margin:auto; width:128px; height:128px; background:#1a1a1a; border-radius:14px}
  .land-dpad .cross::before,.land-dpad .cross::after{content:""; position:absolute; background:#1a1a1a; border-radius:12px}
  .land-dpad .cross::before{left:0; right:0; top:50%; height:42px; transform:translateY(-50%)}
  .land-dpad .cross::after{top:0; bottom:0; left:50%; width:42px; transform:translateX(-50%)}
  .land-dpad button{position:absolute; width:68px; height:68px; background:#111; border:1px solid #2a2a2a; border-radius:14px; color:#98a4b9; font-weight:900; font-size:20px; touch-action:manipulation}
  #lUp{left:50%; top:6px; transform:translateX(-50%)}
  #lDown{left:50%; bottom:6px; transform:translateX(-50%)}
  #lLeft{left:6px; top:50%; transform:translateY(-50%)}
  #lRight{right:6px; top:50%; transform:translateY(-50%)}

  .land-screen-bezel{background:#0f1116;border-radius:18px;padding:12px;
    box-shadow: inset 0 0 0 2px rgba(255,255,255,.05), inset 0 0 28px rgba(0,0,0,.75);}
  .land-screen{ background:#141824; border-radius:12px; padding:8px; box-shadow: inset 0 0 24px rgba(0,0,0,.55); }
  #gameLandscape{display:block; width:100%; height:auto; image-rendering:pixelated; background:#20314f; border:1px solid #2a2a2a; border-radius:8px}

  .land-actions{ display:flex; flex-direction:column; align-items:center; gap:14px; }
  .land-actions .ab{ position:relative; width:160px; height:132px; }
  .land-actions .ab .btn{ position:absolute; width:60px; height:60px; border-radius:999px; border:1px solid #1b2a52; color:#e9f1ff; font-weight:800; font-size:16px; box-shadow:inset 0 8px 18px rgba(0,0,0,.45); touch-action:manipulation }
  #lA{ background:var(--btnA); right:6px; top:6px }
  #lB{ background:var(--btnB); left:14px; bottom:8px }
  #lZ{background:#3ECBA3; right:14px; bottom:8px; width:50px; height:50px; font-size:14px}
  .land-actions .start{ display:flex; gap:10px; }
  .land-actions .start .tiny{ min-width:auto; width:72px; height:32px; border-radius:999px; background:var(--btnStart); border:1px solid #222; color:white; font-weight:800; font-size:12px; touch-action:manipulation }

  /* ===== Mode switching ===== */
  @media (orientation: landscape) and (max-width: 940px){
    .gbc-shell{ display:none !important; }
    .gba-shell{ display:block; }
  }
  @media (min-width: 941px){
    .gba-shell{ display:none !important; }
    #mobileControls{ display:none; }
  }

  /* Debug overlay */
  #debug{
    position:fixed; left:10px; top:10px; z-index:9999;
    background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.12);
    border-radius:8px; padding:6px 8px; font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    color:#cfe6ff; pointer-events:none; min-width:180px;
  }
</style>

<style id="introOverlayStyles">
#introOverlay{cursor:pointer; touch-action: manipulation; -webkit-user-select:none; user-select:none;
  position:fixed; inset:0; z-index:999999;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  background:rgba(0,0,0,0.82); color:#e9f1ff; text-align:center;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
}
#introOverlay .box{ pointer-events:none; max-width:min(820px, 92vw); padding:24px 28px; border:1px solid rgba(255,255,255,.15); border-radius:12px; background:rgba(16,24,40,.55); box-shadow:0 18px 36px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06); }
#introOverlay h1{ margin:0 0 12px; font-size:22px; letter-spacing:.06em; color:#cfe6ff; }
#introOverlay p{ margin:8px 0; font-size:16px; opacity:.95 }
#introOverlay .hint{ margin-top:14px; font-size:12px; color:#bcd1ff; opacity:.9 }
#introOverlay .cta{ margin-top:20px; font-weight:800; font-size:13px; color:#dfe8ff; letter-spacing:.04em }
</style>

</head>
<body>
  <!-- PORTRAIT -->
  <div class="gbc-shell">
    <div class="gbc-face">
      <div class="topbar">
        <span>WILD&nbsp;PALS</span>
        <span class="power"><span class="led"></span>POWER</span>
      </div>
      <div class="gb-screen">
        <div id="canvasBox">
          <canvas id="game" width="960" height="528"></canvas>
        </div>
      </div>
      <div id="mobileControls">
        <div class="dpad">
          <div class="cross"></div>
          <button id="btnUp">▲</button>
          <button id="btnDown">▼</button>
          <button id="btnLeft">◀</button>
          <button id="btnRight">▶</button>
        </div>
        <div></div>
        <div class="actCluster">
          <button class="btn" id="btnA">A</button>
          <button class="btn" id="btnB">B</button>
          <button class="btn" id="btnZ">Z</button>
        </div>
        <div></div>
        <div class="startRow">
          <button class="tiny" id="btnStart">START</button>
          <button class="tiny" id="btnSelect">SELECT</button>
        </div>
      </div>
    </div>
  </div>

  <!-- LANDSCAPE -->
  <div class="gba-shell">
    <div class="gba-body">
      <div class="topbar gba-topbar">
        <span>WILD&nbsp;PALS</span>
        <span class="power"><span class="led"></span>POWER</span>
      </div>
      <div class="gba-tray">
        <div id="landscapeRow">
          <!-- D-pad -->
          <div class="land-dpad">
            <div class="cross"></div>
            <button id="lUp">▲</button>
            <button id="lDown">▼</button>
            <button id="lLeft">◀</button>
            <button id="lRight">▶</button>
          </div>
          <!-- Screen -->
          <div class="land-screen-bezel">
            <div class="land-screen">
              <canvas id="gameLandscape" width="960" height="528"></canvas>
            </div>
          </div>
          <!-- Actions -->
          <div class="land-actions">
            <div class="ab">
              <button class="btn" id="lA">A</button>
              <button class="btn" id="lB">B</button>
              <button class="btn" id="lZ">Z</button>
            </div>
            <div class="start">
              <button class="tiny" id="lStart">START</button>
              <button class="tiny" id="lSelect">SELECT</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="debug">booting…</div>

<script>


// === Ground-blended, individualized icons for Items & Pals ====================
function R(ctx,x,y,w,h,c){ ctx.fillStyle=c; ctx.fillRect(x|0,y|0,w|0,h|0); }
function O(ctx,x,y,w,h,c){ ctx.strokeStyle=c; ctx.strokeRect((x|0)+0.5,(y|0)+0.5,(w|0)-1,(h|0)-1); }
function _rgb(hex){ if(!hex||hex[0]!=='#'||hex.length!==7) return [32,49,79]; return [parseInt(hex.slice(1,3),16),parseInt(hex.slice(3,5),16),parseInt(hex.slice(5,7),16)]; }
function _mix(hex, k){ const [r,g,b]=_rgb(hex); return 'rgb('+((r*(1-k))|0)+','+((g*(1-k))|0)+','+((b*(1-k))|0)+')'; }
function _plateColors(tx,ty){
  try{
    tx=Math.max(0,Math.min(W-1,tx|0)); ty=Math.max(0,Math.min(H-1,ty|0));
    const idx = ty*W + tx; const base = (COLORS && COLORS[ground[idx]]) || '#20314f';
    return { fill:_mix(base, 0.12), edge:_mix(base, 0.22) }; // lighter than before
  }catch(_){ return {fill:'#2a3a54', edge:'#1e2b42'}; }
}
function plate(ctx, x, y){
  const tx=(x/32)|0, ty=(y/32)|0;
  let base = '#20314f';
  try{
    const idx = Math.max(0,Math.min(H-1,ty))*W + Math.max(0,Math.min(W-1,tx));
    if (COLORS && ground) base = COLORS[ground[idx]] || base;
  }catch(_){}
  const r=parseInt(base.slice(1,3),16), g=parseInt(base.slice(3,5),16), b=parseInt(base.slice(5,7),16);
  ctx.fillStyle = `rgba(${r},${g},${b},0.05)`; // 5% alpha — blends into biome
  ctx.fillRect(x+4, y+4, 24, 24);
}
// ---- Items ----

// === Desert structure painters (posts, shrines, vault) ===
function drawDesertPost(ctx, obj, vx, vy){
  const x = (obj.x - vx)|0, y = (obj.y - vy)|0;
  const w = obj.w || TILE || 28, h = obj.h || TILE || 28;
  // base plate
  ctx.fillStyle = 'rgba(90,59,30,0.10)'; ctx.fillRect(x+3,y+h-5,w-6,3);
  // vertical beam
  ctx.fillStyle = '#5a3b1e'; ctx.fillRect(x + ((w*0.36)|0), y + 2, Math.max(4,(w*0.14)|0), h - 6);
  // slanted cross-beam
  ctx.strokeStyle = '#2d1b0c'; ctx.lineWidth = Math.max(2,(w*0.08)|0);
  ctx.beginPath();
  const yMid = y + ((h*0.38)|0);
  ctx.moveTo(x + 4, yMid);
  ctx.lineTo(x + w - 4, yMid + 4);
  ctx.stroke();
  // bolts
  ctx.fillStyle = '#2d1b0c';
  ctx.fillRect(x + ((w*0.34)|0), y + 2, 2, 3);
  ctx.fillRect(x + ((w*0.34)|0), y + h - 7, 2, 3);
}

function drawDesertShrine(ctx, obj, vx, vy){
  const x = (obj.x - vx)|0, y = (obj.y - vy)|0;
  const w = obj.w || TILE || 28, h = obj.h || TILE || 28;
  // plinth layers
  ctx.fillStyle = '#d2b48c'; ctx.fillRect(x, y + (h*0.55)|0, w, (h*0.45)|0);
  ctx.fillStyle = '#c2a476'; ctx.fillRect(x+4, y + (h*0.55 - 6)|0, w-8, 6);
  ctx.fillStyle = '#a98b60'; ctx.fillRect(x+8, y + (h*0.55 - 12)|0, w-16, 6);
  // rune disk + subtle glow
  const cx = x + (w>>1), cy = y + ((h*0.55 - 16)|0);
  ctx.save();
  ctx.globalAlpha = 0.35; ctx.fillStyle = 'rgba(84,201,193,0.45)';
  ctx.beginPath(); ctx.arc(cx, cy, Math.max(8,(w*0.22)|0), 0, Math.PI*2); ctx.fill();
  ctx.restore();
  ctx.fillStyle = '#54C9C1';
  ctx.beginPath(); ctx.arc(cx, cy, Math.max(5,(w*0.16)|0), 0, Math.PI*2); ctx.fill();
  // rune mark
  ctx.strokeStyle = '#126e82'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(cx, cy-4); ctx.lineTo(cx-4, cy+3); ctx.lineTo(cx+4, cy+3); ctx.closePath(); ctx.stroke();
}

function drawDesertVault(ctx, obj, vx, vy){
  const x = (obj.x - vx)|0, y = (obj.y - vy)|0;
  const w = obj.w || (TILE*1.25) || 40, h = obj.h || (TILE*1.25) || 40;
  // facade
  ctx.fillStyle = '#d2b48c'; ctx.fillRect(x, y, w, h);
  // shadowed arch
  const r = Math.max(10,(w*0.33)|0), cx = x + (w>>1), cy = y + ((h*0.48)|0);
  ctx.fillStyle = '#3a2f00';
  ctx.beginPath(); ctx.arc(cx, cy, r, Math.PI, 0, false); ctx.fill();
  ctx.fillRect(cx - r, cy, r*2, Math.max(10,(h*0.32)|0));
}

function drawItemIcon(ctx, vx, vy, it){
  const x=(it.x-vx)|0, y=(it.y-vy)|0, cx=x+4, cy=y+4;
  plate(ctx, x, y);
  const id=(it.id||it.type||it.name||'').toLowerCase();
  if (id==='wood'){ R(ctx,cx+6,cy+14,16,10,'#7b4f2a'); O(ctx,cx+6,cy+14,16,10,'#4e2f18'); R(ctx,cx+8,cy+12,12,3,'#4e2f18'); }
  else if (id==='stone'){ R(ctx,cx+6,cy+10,18,14,'#9aa3ad'); O(ctx,cx+6,cy+10,18,14,'#5f6974'); R(ctx,cx+12,cy+12,6,3,'#5f6974'); }
  else if (id==='berry'){ R(ctx,cx+10,cy+12,10,10,'#c93d5b'); O(ctx,cx+10,cy+12,10,10,'#7a1d34'); R(ctx,cx+14,cy+8,4,4,'#3ea55e'); }
  else if (id==='herb'){ R(ctx,cx+8,cy+10,14,12,'#68c56e'); O(ctx,cx+8,cy+10,14,12,'#2c7d34'); R(ctx,cx+15,cy+8,2,4,'#2c7d34'); }
  else if (id==='reed'){ R(ctx,cx+8,cy+8,3,18,'#89c06e'); R(ctx,cx+12,cy+6,3,20,'#89c06e'); R(ctx,cx+16,cy+9,3,17,'#89c06e'); R(ctx,cx+8,cy+8,1,18,'#3a7a2c'); }
  else if (id==='mushroom'){ R(ctx,cx+9,cy+16,10,6,'#e7d2a8'); O(ctx,cx+9,cy+16,10,6,'#7a1d1d'); R(ctx,cx+6,cy+8,16,8,'#d84f4f'); O(ctx,cx+6,cy+8,16,8,'#7a1d1d'); }
  else if (id==='fiber'){ R(ctx,cx+6,cy+16,16,6,'#d3c2a0'); O(ctx,cx+6,cy+16,16,6,'#8e7a50'); R(ctx,cx+8,cy+12,12,3,'#d3c2a0'); }
  else if (id==='cactus'){ R(ctx,cx+8,cy+8,12,16,'#3aa66a'); O(ctx,cx+8,cy+8,12,16,'#1c6b42'); R(ctx,cx+4,cy+12,6,10,'#3aa66a'); R(ctx,cx+20,cy+12,6,10,'#3aa66a'); R(ctx,cx+12,cy+6,4,3,'#ffd34a'); }
  else if (id==='sandstone'){ R(ctx,cx+6,cy+12,18,12,'#c9b386'); O(ctx,cx+6,cy+12,18,12,'#8c7a55'); R(ctx,cx+10,cy+10,10,3,'#8c7a55'); }
  else if (id==='aloe'){ R(ctx,cx+10,cy+18,4,8,'#256a54'); R(ctx,cx+6,cy+10,8,10,'#6cc4a6'); R(ctx,cx+14,cy+12,8,8,'#6cc4a6'); O(ctx,cx+6,cy+10,16,10,'#256a54'); }
  else if (id==='net_basic'||id==='net_fine'){ R(ctx,cx+8,cy+8,10,10,'#eaeaea'); O(ctx,cx+8,cy+8,10,10,'#8e7a50'); R(ctx,cx+12,cy+6,3,18,'#d3c2a0'); R(ctx,cx+9,cy+10,8,1,'#8e7a50'); R(ctx,cx+9,cy+12,8,1,'#8e7a50'); R(ctx,cx+9,cy+14,8,1,'#8e7a50'); if(id==='net_fine'){ R(ctx,cx+9,cy+16,8,1,'#c0b090'); } }
  else if (id==='pot_heal_s'){ R(ctx,cx+8,cy+6,8,2,'#ff6ba0'); R(ctx,cx+8,cy+8,8,10,'#cbe8ff'); R(ctx,cx+8,cy+8,8,1,'#8fb2cc'); R(ctx,cx+8,cy+14,8,4,'#ff6ba0'); }
  else if (id==='axe_basic'){ R(ctx,cx+15,cy+8,3,16,'#7b4f2a'); R(ctx,cx+8,cy+8,8,6,'#b7c0c8'); O(ctx,cx+8,cy+8,8,6,'#d8dee7'); R(ctx,cx+14,cy+14,4,2,'#4a2a1a'); }
  else if (id==='weapon_stick'){ R(ctx,cx+8,cy+10,16,4,'#7b4f2a'); O(ctx,cx+8,cy+10,16,4,'#4e2f18'); }
  else if (id==='boots_desert'){ R(ctx,cx+7,cy+16,9,6,'#6e4b2e'); R(ctx,cx+15,cy+16,9,6,'#6e4b2e'); O(ctx,cx+7,cy+16,9,6,'#3e2a18'); O(ctx,cx+15,cy+16,9,6,'#3e2a18'); }
  else if (id==='relic_feather'){ R(ctx,cx+8,cy+10,12,10,'#e8e0ff'); O(ctx,cx+8,cy+10,12,10,'#9d86ff'); R(ctx,cx+12,cy+8,2,4,'#9d86ff'); }
  else if (id.includes('coin')){ R(ctx,cx+6,cy+6,12,12,'#ffd34a'); O(ctx,cx+6,cy+6,12,12,'#b78c24'); R(ctx,cx+10,cy+10,4,4,'#ffffff55'); }
  else if (id.includes('key')){ R(ctx,cx+5,cy+10,14,4,'#d4b86a'); R(ctx,cx+5,cy+7,6,6,'#d4b86a'); O(ctx,cx+5,cy+10,14,4,'#7c6a36'); R(ctx,cx+6,cy+8,4,4,'#20314f'); R(ctx,cx+16,cy+8,3,2,'#7c6a36'); R(ctx,cx+16,cy+13,3,1,'#7c6a36'); }
  else if (id.includes('chest')){ R(ctx,cx+6,cy+10,16,10,'#8a5a2f'); O(ctx,cx+6,cy+10,16,10,'#5a3a1f'); R(ctx,cx+13,cy+14,2,4,'#d9c36a'); }
  else { R(ctx,cx+6,cy+6,16,16,'#70757a'); O(ctx,cx+6,cy+6,16,16,'#4a4d52'); }
}

// ---- Pals ----
const PAL_STYLE = {
  rabbit:{ body:'#e9f1ff', trim:'#7a9ad6', ear:'#ffb7c8' },  sparrow:{ body:'#c9a46a', trim:'#6a4b2a' },
  frog:{ body:'#77d36a', trim:'#2a7d3d' },                  boar:{ body:'#8a5a3a', trim:'#4e2f1b' },
  stag:{ body:'#a6784a', trim:'#5a3a1e' },                  owl:{ body:'#bfbba8', trim:'#6b685a', eye:'#2b2b2b' },
  squirrel:{ body:'#b16e3a', trim:'#6a3a1a' },              fox:{ body:'#ff8c4a', trim:'#7a3d16', ear:'#ffc6a6' },
  sprite:{ body:'#a86bff', trim:'#532a9e', eye:'#ffffff' }, owllet:{ body:'#d6d2c0', trim:'#6b685a' },
  scarab:{ body:'#4aa3a3', trim:'#1d6b6b' },                vulture:{ body:'#c0b090', trim:'#6a5850' },
  fennec:{ body:'#f2c88a', trim:'#8c5a2b', ear:'#ffe6b7' }, phoenix:{ body:'#ff6b6b', trim:'#7a0000' },
  dragon:{ body:'#66a3ff', trim:'#1b4d9e' },                gryphon:{ body:'#d9c36a', trim:'#7a6a2a' },
  lynx:{ body:'#c09070', trim:'#6b4a2a' },                  eagle:{ body:'#c9c9c9', trim:'#3a3a3a' }
};
function palStyleFor(p){ const k=(p.id||p.type||p.kind||'').toLowerCase(); return PAL_STYLE[k] || { body:'#55c66f', trim:'#2a7d3d' }; }

function drawPalIcon(ctx, vx, vy, p){
  const x=(p.x-vx)|0, y=(p.y-vy)|0, cx=x+4, cy=y+4, s=palStyleFor(p);
  plate(ctx, x, y);
  R(ctx, cx+6, cy+8, 12, 12, s.body);
  R(ctx, cx+6, cy+8, 12, 1,  s.trim);
  R(ctx, cx+6, cy+8, 1,  12, s.trim);
  R(ctx, cx+8, cy+4, 8, 6, s.body);
  R(ctx, cx+10, cy+6, 2, 2, s.eye || '#000');
  R(ctx, cx+8, cy+20, 3, 3, s.trim);
  R(ctx, cx+13, cy+20, 3, 3, s.trim);
  const id=(p.id||'').toLowerCase();
  if (id==='rabbit'){ R(ctx,cx+8,cy+1,2,4,s.ear||'#ffdbe6'); R(ctx,cx+14,cy+1,2,4,s.ear||'#ffdbe6'); }
  if (id==='fox'){ R(ctx,cx+16,cy+12,3,2,s.trim); }
  if (id==='boar'){ R(ctx,cx+6,cy+12,2,2,s.trim); R(ctx,cx+16,cy+12,2,2,s.trim); }
  if (id==='stag'){ R(ctx,cx+8,cy+1,2,3,s.trim); R(ctx,cx+12,cy+1,2,3,s.trim); }
  if (id==='owl'||id==='owllet'){ R(ctx,cx+9,cy+6,2,2,'#000'); R(ctx,cx+13,cy+6,2,2,'#000'); }
  if (id==='sparrow'||id==='eagle'){ R(ctx,cx+14,cy+6,3,2,s.trim); }
  if (id==='scarab'){ R(ctx,cx+7,cy+10,10,2,s.trim); }
  if (id==='sprite'){ R(ctx,cx+7,cy+7,2,3,'#fff'); R(ctx,cx+17,cy+7,2,3,'#fff'); }
  if (id==='fennec'){ R(ctx,cx+6,cy+2,3,4,s.ear||'#ffe6b7'); R(ctx,cx+17,cy+2,3,4,s.ear||'#ffe6b7'); }
  if (id==='phoenix'){ R(ctx,cx+16,cy+8,5,3,'#ffd34a'); }
  if (id==='dragon'){ R(ctx,cx+6,cy+6,3,2,'#1b4d9e'); R(ctx,cx+17,cy+6,3,2,'#1b4d9e'); }
}

// === NPC renderer (ported from safe file) ===
function drawNPC(ctx, vx, vy, n){

  try{
    if(!n) return;
    const ax = (n.x - vx) | 0, ay = (n.y - vy) | 0;
    const type = n.type || n.role || n.kind || null;
    // Sand Lynx Guardian (NPC render)
    if (type==='guardian' || type==='guardian_lynx' || type==='sand_lynx'){
      const t = (performance.now?performance.now():Date.now())*0.004;
      const bob = Math.sin(t)*1.5;
      // golden plate
      ctx.save(); ctx.globalAlpha=0.30; ctx.fillStyle='rgba(255,211,74,0.85)';
      ctx.beginPath(); ctx.arc(ax+16, ay+22, 14, 0, Math.PI*2); ctx.fill(); ctx.restore();
      // lynx
      ctx.fillStyle='#c09070'; ctx.fillRect(ax+8,  ay+8 + bob, 20, 12);
      ctx.fillStyle='#6b4a2a'; ctx.fillRect(ax+10, ay+20 + bob, 4, 4); ctx.fillRect(ax+18, ay+20 + bob, 4, 4);
      ctx.fillStyle='#c09070'; ctx.fillRect(ax+18, ay+4 + bob, 8, 6);
      ctx.fillStyle='#6b4a2a'; ctx.fillRect(ax+18, ay+2 + bob, 2, 3); ctx.fillRect(ax+24, ay+2 + bob, 2, 3);
      return;
    }

    if(type==='market'){
      if (typeof TILE === 'number') { ctx.fillStyle = '#5a3b7a'; ctx.fillRect(ax, ay, TILE, TILE); }
      ctx.fillStyle = '#f2d3a0'; ctx.fillRect(ax+8, ay+6, 8, 8);
      ctx.fillStyle = '#ff8c00'; ctx.fillRect(ax+6, ay+14, 12, 8);
    } else {
      ctx.fillStyle='#f2d3a0'; ctx.fillRect(ax+8,ay+6,8,8);
      ctx.fillStyle='#6a3a1a'; ctx.fillRect(ax+6,ay+14,12,8);
    }
    ctx.fillStyle='#000'; ctx.fillRect(ax+11,ay+9,2,2);
    ctx.fillStyle='#fff'; ctx.font='10px monospace'; ctx.fillText('!', ax+12, ay+4);
  }catch(e){
    // Fallback to original rectangle
    try{ rectOutline(ctx, n.x-vx, n.y-vy, n.w, n.h, '#e3d180','#3a2f00'); }catch(_){}
  }
}

/* Wild Pals — Iteration C+ (Meadow + Forest, questline + economy + traversal + portal VFX):
   A) Forest v1 questline (Ranger): fiber+mushroom, craft fine net, capture 1 forest pal → coins + Wetlands key flag
   B) Traversal: new BRUSH tile (blocks unless brush_break); new items fiber & mushroom; new recipe net_fine (wood+fiber+berry)
      New perks that matter now: boar:brush_break, stag:speed+0.15, owl:glide:"long" (groundwork), squirrel:forage bonus
   C) Weighted forest spawns (boar, stag, owl, squirrel + a couple classics)
   D) Economy: forest trader (buy/sell); simple sell values for mats; coin sinks (fine net, potions)
   E) UX: minimap tint per biome; Start menu controls line switches on touch
   F) Save/Load: persists brush tiles + new items/recipes and fog
   G) Portals: vivid purple swirl with pulsing glow + cheat alias FORESTOPEN
*/
(function(){

  // === Guardian dynamic placement (robust) ===
  try{
    Game.flags = Game.flags || {};
    var shrinesDone = !!(Game.flags.desert_shrine_wind_done && Game.flags.desert_shrine_sun_done && Game.flags.desert_shrine_sand_done);
    if (shrinesDone && !Game.flags.desert_oasis_guardian_awake){ Game.flags.desert_oasis_guardian_awake = true; }
    if (Game.flags.desert_oasis_guardian_awake){
      var LM = (Game.D && Game.D.DESERT_LANDMARKS) ? Game.D.DESERT_LANDMARKS
              : (typeof DESERT_LANDMARKS!=='undefined' ? DESERT_LANDMARKS : (Game.flags.DESERT_LANDMARKS||[]));
      var hasG=false;
      for (var i=0;i<LM.length;i++){ if (LM[i] && LM[i].type==='guardian'){ hasG=true; break; } }
      if (!hasG){
        var T = (typeof TILE!=='undefined'?TILE:32);
        var ptx = 70, pty = 58; // default near oasis-ish
        try{
          if (typeof player!=='undefined' && player && player.x!=null && player.y!=null){
            ptx = (player.x/T)|0; pty = (player.y/T)|0;
          }
        }catch(_){}
        Game.flags.desert_guardian_tx = ptx;
        Game.flags.desert_guardian_ty = pty;
        LM.push({type:'guardian', tx:ptx, ty:pty});
        if (typeof toast==='function') toast('A guardian stirs nearby…');
      }
      // write back
      if (Game.D && Game.D.DESERT_LANDMARKS) Game.D.DESERT_LANDMARKS = LM;
      else if (typeof DESERT_LANDMARKS!=='undefined') DESERT_LANDMARKS = LM;
      else Game.flags.DESERT_LANDMARKS = LM;
    }
  }catch(_){}



  // === Desert Guardian / Wetlands portal: safe pin ensure ===
  try{
    Game.flags = Game.flags || {};
    var shrOK = !!(Game.flags.desert_shrine_wind_done && Game.flags.desert_shrine_sun_done && Game.flags.desert_shrine_sand_done);
    if (shrOK && !Game.flags.desert_oasis_guardian_awake) Game.flags.desert_oasis_guardian_awake = true;

    var LM = (Game.D && Game.D.DESERT_LANDMARKS) ? Game.D.DESERT_LANDMARKS
            : (typeof DESERT_LANDMARKS!=='undefined' ? DESERT_LANDMARKS : (Game.flags.DESERT_LANDMARKS||[]));
    var hasG=false, hasP=false;
    for (var i=0;i<LM.length;i++){ var t=LM[i]&&LM[i].type; if (t==='guardian') hasG=true; if (t==='portal_wetlands') hasP=true; }
    if (Game.flags.desert_oasis_guardian_awake && !hasG){
      LM.push({type:'guardian', tx:72, ty:58});
      if (typeof toast==='function') toast('A guardian stirs by the oasis…');
    }
    if ((Game.flags.desert_guardian_portal_ready || (Game.unlocked&&Game.unlocked.wetlands)) && !hasP){
      LM.push({type:'portal_wetlands', tx:40, ty:36});
    }
    if (Game.D && Game.D.DESERT_LANDMARKS) Game.D.DESERT_LANDMARKS = LM;
    else if (typeof DESERT_LANDMARKS!=='undefined') DESERT_LANDMARKS = LM;
    else Game.flags.DESERT_LANDMARKS = LM;
  }catch(_){}



  // === Desert Guardian & Wetlands portal pins (boot-time augment) ===
  try{
    Game.flags = Game.flags || {};
    var LM = (Game.D && Game.D.DESERT_LANDMARKS) ? Game.D.DESERT_LANDMARKS
            : (typeof DESERT_LANDMARKS!=='undefined' ? DESERT_LANDMARKS : (Game.flags.DESERT_LANDMARKS||[]));
    // Choose stable coordinates near oasis if not already present (tweak tx/ty if you want exact tiles)
    var hasGuardian = !!Game.flags.desert_oasis_guardian_awake;
    var hasGuardianPin = false, hasPortalPin = false;
    for (var i=0;i<LM.length;i++){
      if (LM[i].type==='guardian') hasGuardianPin = true;
      if (LM[i].type==='portal_wetlands') hasPortalPin = true;
    }
    if (hasGuardian && !hasGuardianPin){
      LM.push({type:'guardian', tx:72, ty:58}); // near oasis default
    }
    // Portal pin appears only after guardian turn-in preps it OR when globally unlocked
    var portalReady = !!(Game.flags.desert_guardian_portal_ready || (Game.unlocked && Game.unlocked.wetlands));
    if (portalReady && !hasPortalPin){
      LM.push({type:'portal_wetlands', tx:40, ty:36}); // a clear desert tile
    }
    // write back
    if (Game.D && Game.D.DESERT_LANDMARKS) Game.D.DESERT_LANDMARKS = LM;
    else if (typeof DESERT_LANDMARKS!=='undefined') DESERT_LANDMARKS = LM;
    else Game.flags.DESERT_LANDMARKS = LM;
  }catch(_){}


  // === safe inventory consume helper ===
  function _takeItem(id, qty){
    try{
      qty = qty|0; if (qty<=0) qty=1;
      var inv = Game.inventory || [];
      for (var i=0;i<inv.length;i++){
        var it = inv[i]; if (it && it.id===id && (it.qty||1) >= qty){
          it.qty = (it.qty||1) - qty;
          if (it.qty<=0){ inv.splice(i,1); }
          return true;
        }
      }
    }catch(_){}
    return false;
  }

  // === Crafting unlock helper (sets flags the crafting tab understands) ===
  function _unlockRecipeCompat(id){
    try{
      Game.flags = Game.flags || {};
      Game.flags['recipe_'+id] = true;
      // Also set alias form for + <-> _plus
      if (id.indexOf('+')>=0){
        Game.flags['recipe_'+id.replace('+','_plus')] = true;
      }else if (id.indexOf('_plus')>=0){
        Game.flags['recipe_'+id.replace('_plus','+')] = true;
      }
    }catch(_){}
  }

  // ---------- Status / Toast ----------
  const debugEl = document.getElementById('debug');
  function status(msg){ if(debugEl) debugEl.textContent = msg; }
  let toastMsg="", toastUntil=0;
  function toast(msg, ms=1600){ toastMsg=msg; toastUntil=performance.now()+ms; }
  // --- Stage 11e: Oasis resource spawner (reeds + herbs, clustered) ---
  function oasisSpawn(){
    try{
      if (typeof W==='undefined' || typeof H==='undefined' || !ground) return;
      if (!Array.isArray(items)) return;
      // remove old reed/herb to prevent runaway growth on reseed
      for (let k=items.length-1;k>=0;k--){
        const id=(items[k].id||''); if (id==='reed'||id==='herb') items.splice(k,1);
      }
      const isWater=(x,y)=> ground[y*W + x]===4;
      const T = (typeof TILE==='number') ? TILE : 32;

      // collect shoreline and fringe tiles
      const bank=[], fringe=[];
      for (let y=2;y<H-2;y++) for (let x=2;x<W-2;x++){
        if (isWater(x,y)) continue;
        const n4 = (isWater(x+1,y)?1:0)+(isWater(x-1,y)?1:0)+(isWater(x,y+1)?1:0)+(isWater(x,y-1)?1:0);
        if (n4>0){ bank.push({x,y}); continue; }
        // fringe within radius 3
        let near=false;
        for (let dy=-3;dy<=3 && !near;dy++) for (let dx=-3;dx<=3 && !near;dx++){
          const nx=x+dx, ny=y+dy; if (nx<1||ny<1||nx>=W-1||ny>=H-1) continue;
          if (isWater(nx,ny)) near=true;
        }
        if (near) fringe.push({x,y});
      }
      if (!bank.length && !fringe.length) return;

      // clustering utility
      function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; const t=a[i]; a[i]=a[j]; a[j]=t; } }
      shuffle(bank); shuffle(fringe);

      // Determine counts (boosted)
      const reedsCount = Math.max(24, Math.floor(bank.length*0.20));   // 20% of bank, min 24
      const herbsCount = Math.max(14, Math.floor(fringe.length*0.06)); // 6% of fringe, min 14

      // Spawn reeds in clusters
      for (let i=0;i<reedsCount && i<bank.length;i+=1){
        const t = bank[i];
        // spawn a small clump (1 + up to 3 neighbors)
        const cluster = 1 + ((Math.random()*3)|0);
        for (let c=0;c<cluster;c++){
          const dx = (Math.random()<0.5? -1:1) * ((Math.random()*2)|0);
          const dy = (Math.random()<0.5? -1:1) * ((Math.random()*2)|0);
          const xx = Math.max(2, Math.min(W-3, t.x+dx));
          const yy = Math.max(2, Math.min(H-3, t.y+dy));
          // ensure still near water
          if (isWater(xx+1,yy)||isWater(xx-1,yy)||isWater(xx,yy+1)||isWater(xx,yy-1)){
            items.push({id:'reed', x:xx*T + (T>>1), y:yy*T + (T>>1), w:20, h:20});
          }
        }
      }

      // Spawn herbs scattered but denser than before
      for (let i=0;i<herbsCount && i<fringe.length;i+=1){
        const t = fringe[i];
        items.push({id:'herb', x:t.x*T + (T>>1), y:t.y*T + (T>>1), w:20, h:20});
      }
    }catch(_){}
  }

// === Desert module (quick-fix: seedLandmarks only) ===
const DESERT = (function(){
  function ensureData(){
    if (!Game.flags) Game.flags = {};
    if (!Array.isArray(Game.flags.desert_landmarks)) Game.flags.desert_landmarks = [];
    return Game.flags.desert_landmarks;
  }
  function seedLandmarks(){
    const a = ensureData();
    if (a.length) return a;
    function isWater(tx,ty){
      try{ return ground[ty*W+tx]===4; }catch(_){ return false; }
    }
    function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
    const cand = [
      {tx: Math.floor(W*0.60), ty: Math.floor(H*0.45), type:'scout'},
      {tx: Math.floor(W*0.72), ty: Math.floor(H*0.58), type:'scout'},
      {tx: Math.floor(W*0.48), ty: Math.floor(H*0.66), type:'scout'},
      {tx: Math.floor(W*0.64), ty: Math.floor(H*0.35), type:'shrine_wind'},
      {tx: Math.floor(W*0.76), ty: Math.floor(H*0.50), type:'shrine_sun'},
      {tx: Math.floor(W*0.52), ty: Math.floor(H*0.72), type:'shrine_sand'},
      {tx: Math.floor(W*0.68), ty: Math.floor(H*0.62), type:'vault'}
    ];
    for (let i=0;i<cand.length;i++){
      let tx=clamp(cand[i].tx,6,W-7), ty=clamp(cand[i].ty,6,H-7);
      if (isWater(tx,ty)){
        let found=false;
        outer: for (let r=1;r<=8;r++){
          for (let dx=-r;dx<=r;dx++){
            for (let dy=-r;dy<=r;dy++){
              const nx=clamp(tx+dx,6,W-7), ny=clamp(ty+dy,6,H-7);
              if (!isWater(nx,ny)){ tx=nx; ty=ny; found=true; break outer; }
            }
          }
        }
      }
      a.push({type:cand[i].type, tx, ty, activated:false});
    }
    return a;
  }
  
 // Stage 7: basic interactions near player (1-tile proximity)
function interactNearby(){

  // --- Guardian feather turn-in (Desert) ---
  try{
    if (Game && Game.currentBiome==='desert' && Game.flags && Game.flags.desert_oasis_guardian_awake && !Game.flags.desert_guardian_portal_ready){
      var T = (typeof TILE==='number')?TILE:32;
      var gx = ((Game.flags.desert_guardian_tx|0)*T)|0, gy=((Game.flags.desert_guardian_ty|0)*T)|0;
      var dx = Math.abs((player.x|0) - gx), dy = Math.abs((player.y|0) - gy);
      if (dx<=40 && dy<=40){
        // consume relic feather if present
        var inv = Game.inventory||[]; var idx = -1;
        for (var ii=0; ii<inv.length; ii++){ var it=inv[ii]; if (it && it.id==='relic_feather' && (it.qty||1)>0){ idx=ii; break; } }
        if (idx>=0){
          inv[idx].qty = (inv[idx].qty||1) - 1; if (inv[idx].qty<=0) inv.splice(idx,1);
          Game.flags.desert_guardian_portal_ready = true;
          if (!Game.unlocked) Game.unlocked = {};
          Game.unlocked.wetlands = true;
          if (typeof toast==='function') toast('The Sand Lynx parts the dunes… a portal stirs to the west.');
          if (typeof rebuildPortals==='function') rebuildPortals();
          return true;
        }
      }
    }
  }catch(_){}

  if (Game.currentBiome!=='desert') return false;
    
    

    // on-demand guardian placement (when interacting)
    try{
      if (Game.currentBiome==='desert'){
        Game.flags = Game.flags || {};
        var shrOK = !!(Game.flags.desert_shrine_wind_done && Game.flags.desert_shrine_sun_done && Game.flags.desert_shrine_sand_done);
        if (shrOK){ if (!Game.flags.desert_oasis_guardian_awake) Game.flags.desert_oasis_guardian_awake = true; }
        if (Game.flags.desert_oasis_guardian_awake){
          var LM = (Game.D && Game.D.DESERT_LANDMARKS) ? Game.D.DESERT_LANDMARKS
                  : (typeof DESERT_LANDMARKS!=='undefined' ? DESERT_LANDMARKS : (Game.flags.DESERT_LANDMARKS||[]));
          var hasG=false; for (var i=0;i<LM.length;i++){ if (LM[i] && LM[i].type==='guardian'){ hasG=true; break; } }
          if (!hasG && typeof player!=='undefined' && player){
            var T = (typeof TILE!=='undefined'?TILE:32);
            var ptx = (player.x/T)|0, pty = (player.y/T)|0;
            LM.push({type:'guardian', tx:ptx, ty:pty});
            Game.flags.desert_guardian_tx = ptx; Game.flags.desert_guardian_ty = pty;
            if (typeof toast==='function') toast('A guardian stirs nearby…');
            if (Game.D && Game.D.DESERT_LANDMARKS) Game.D.DESERT_LANDMARKS = LM;
            else if (typeof DESERT_LANDMARKS!=='undefined') DESERT_LANDMARKS = LM;
            else Game.flags.DESERT_LANDMARKS = LM;
          }
        }
        // Portal pin ensure when ready
        if (Game.flags.desert_guardian_portal_ready || (Game.unlocked && Game.unlocked.wetlands)){
          var LM2 = (Game.D && Game.D.DESERT_LANDMARKS) ? Game.D.DESERT_LANDMARKS
                  : (typeof DESERT_LANDMARKS!=='undefined' ? DESERT_LANDMARKS : (Game.flags.DESERT_LANDMARKS||[]));
          var hasP=false; for (var j=0;j<LM2.length;j++){ if (LM2[j] && LM2[j].type==='portal_wetlands'){ hasP=true; break; } }
          if (!hasP){ LM2.push({type:'portal_wetlands', tx:40, ty:36});
            if (Game.D && Game.D.DESERT_LANDMARKS) Game.D.DESERT_LANDMARKS = LM2;
            else if (typeof DESERT_LANDMARKS!=='undefined') DESERT_LANDMARKS = LM2;
            else Game.flags.DESERT_LANDMARKS = LM2;
          }
        }
      }
    }catch(_){}

/* guardian dynamic coord read */
    var __gx = (Game.flags && typeof Game.flags.desert_guardian_tx==='number') ? Game.flags.desert_guardian_tx : 72;
    var __gy = (Game.flags && typeof Game.flags.desert_guardian_ty==='number') ? Game.flags.desert_guardian_ty : 58;
/* guardian proximity safe fallback */
    try{
      if (Game.currentBiome==='desert' && Game.flags && Game.flags.desert_oasis_guardian_awake){
        var T = (typeof TILE!=='undefined'?TILE:32);
        var ptx = (player.x/T)|0, pty = (player.y/T)|0;
        var gx = __gx, gy = __gy;
        if (Math.abs(ptx-gx)<=1 && Math.abs(pty-gy)<=1){
          var inv = Game.inventory||[]; var hasFeather=false;
          for (var k=0;k<inv.length;k++){ if (inv[k].id==='relic_feather' && (inv[k].qty||1)>0){ hasFeather=true; break; } }
          if (!Game.flags.desert_guardian_met){ Game.flags.desert_guardian_met=true; toast('A sand lynx of light watches the dunes…'); return true; }
          if (hasFeather && !Game.flags.desert_guardian_portal_ready){
            if (_takeItem('relic_feather',1)){
              Game.flags.desert_guardian_portal_ready = true;
              Game.unlocked = Game.unlocked || {}; Game.unlocked.wetlands = true;
              toast('The Sand Lynx parts the dunes… a path to Wetlands stirs.');
            } else {
              toast('The lynx blinks slowly. Something featherlight is missing.');
            }
            return true;
          }
          if (Game.unlocked && Game.unlocked.wetlands){ toast('The path lies open. Wetlands awaits.'); return true; }
          toast('Three trials wake the oasis. Bring what the vault returned.'); return true;
        }
      }
    }catch(_){}

  try{
    const T = (typeof TILE!=='undefined'?TILE:32);
    const ptx = (player.x/T)|0, pty = (player.y/T)|0;
    const arr = (Game.flags && Array.isArray(Game.flags.desert_landmarks)) ? Game.flags.desert_landmarks : [];

    function _checkShrineSet(){
      const done = Game.flags.desert_shrine_wind_done && Game.flags.desert_shrine_sun_done && Game.flags.desert_shrine_sand_done;
      if (done && !Game.flags.desert_oasis_guardian_awake){
        Game.flags.desert_oasis_guardian_awake = true;
        _addItem('sandstone_key',1);
        
      // Shrine set check => ensure guardian awakens
      (function(){
        try{
          if (Game.flags.desert_shrine_wind_done && Game.flags.desert_shrine_sun_done && Game.flags.desert_shrine_sand_done){
            if (!Game.flags.desert_oasis_guardian_awake){ Game.flags.desert_oasis_guardian_awake = true; toast('Oasis Guardian stirs…'); }
          }
        }catch(_){}
      })();
toast('Oasis Guardian awakens! (Key gained + recipe)');
      }
    }

    // Landmarks first
for (let i=0; i < arr.length; i++) {
  const L = arr[i];
  if (Math.abs(L.tx-ptx) <= 1 && Math.abs(L.ty-pty) <= 1) {
    if (L.type === 'scout') {
      if (!L.activated) { L.activated = true; toast('Scout post activated!'); return true; 
        if (L.type==='guardian'){
          // Sand Lynx — Desert Guardian
          if (!Game.flags.desert_guardian_met){
            Game.flags.desert_guardian_met = true;
            toast('A sand lynx of light watches the dunes…');
            return true;
          }
          // Turn-in: relic_feather -> prepare wetlands portal
          var inv = Game.inventory||[];
          var hasFeather = false;
          for (var k=0;k<inv.length;k++){ if (inv[k].id==='relic_feather' && (inv[k].qty||1)>0){ hasFeather=true; break; } }
          if (hasFeather && !Game.flags.desert_guardian_portal_ready){
            if (_takeItem('relic_feather',1)){
              Game.flags.desert_guardian_portal_ready = true;
              Game.unlocked = Game.unlocked || {};
              Game.unlocked.wetlands = true; // rebuildPortals() reads this to expose the portal
              toast('The Sand Lynx parts the dunes… a path to Wetlands stirs.');
            }else{
              toast('The lynx blinks slowly. Something featherlight is missing.');
            }
            return true;
          }
          if (Game.unlocked && Game.unlocked.wetlands){
            toast('The path lies open. Wetlands awaits.');
          }else{
            toast('Three trials wake the oasis. Bring what the vault returned.');
          }
          return true;
        }
        if (L.type==='portal_wetlands'){
          if (Game.unlocked && Game.unlocked.wetlands){
            toast('The portal hums with riverlight…');
            // instant travel to wetlands
            try{ if (typeof switchBiome==='function') { switchBiome('wetlands'); return true; } }catch(_){}
            // fallback flag if switchBiome differs
            try{ Game.currentBiome='wetlands'; }catch(_){}
            return true;
          }else{
            toast('A sealed portal. The guardian has not yet opened the way.');
            return true;
          }
        }
    
      }
      if (Game.flags.desert_caravan_pass) { if (_fastTravelFrom(L)) return true; }
      toast('A marked post.'); return true;
    }
    if (L.type === 'shrine_wind') {
      if (!Game.flags.desert_shrine_wind_done) { _startWindTrial(); return true; }
      toast('Wind Shrine - completed.'); return true;
    }
    if (L.type === 'shrine_sun') {
      if (!Game.flags.desert_shrine_sun_done) { _startSunTrial(); return true; }
      toast('Sun Shrine — completed.'); return true;
    }
    if (L.type === 'shrine_sand') {
      if (!Game.flags.desert_shrine_sand_done) { _startSandTrial(); return true; }
      toast('Sand Shrine — completed.'); return true;
    }
    if (L.type === 'vault') {
      const all = Game.flags.desert_shrine_wind_done &&
                  Game.flags.desert_shrine_sun_done &&
                  Game.flags.desert_shrine_sand_done;
      if (all) {
        if (!Game.flags.desert_vault_opened) {
          Game.flags.desert_vault_opened = true;
          _addItem('relic_feather', 1);
          toast('Sand Vault opened! (Relic Feather)');
        } else {
          toast('Vault cleared.');
        }
      } else {
        toast('A sealed vault… three sigils are dark.');
      }
      return true;
    }
  }
}
    // NPC placeholders (very light — just toast)
    // Find nearest NPC within ~48px
    let best=-1, bd=1e9;
    for (let i=0;i<npcs.length;i++){
      const n=npcs[i];
      const dx = (n.x+13)-(player.x+13), dy=(n.y+13)-(player.y+13);
      const d = Math.hypot(dx,dy);
      if (d<bd){ bd=d; best=i; }
    }
    if (best!==-1 && bd<48){
      const n=npcs[best];
      if (n.role==='nomad_chief'){
        if (!Game.flags.desert_caravan_started){
        Game.flags.desert_caravan_started = true;
        try{
          Game.quests = Game.quests || {};
          if (!Game.quests['q_desert_main'] || Game.quests['q_desert_main']==='locked'){
            Game.quests['q_desert_main'] = 'active';
          }
        }catch(_){}
        toast('Caravan Circuit started');
        return true;
      }
        if (!Game.flags.desert_caravan_pass && _postsActive()>=3){ Game.flags.desert_caravan_pass=true; Game.flags.desert_caravan_done=true; toast('Caravan Pass granted!'); return true; }
        if (Game.flags.desert_caravan_pass){ toast('Chief: fast-travel unlocked at posts.'); return true; }
        toast('Nomad Chief: prove the route (activate 3 posts).'); return true;
      }
      if (n.role==='market'){
      if (!Game.flags.desert_caravan_pass){ toast('Fennec Trader: come back with a Caravan Pass.'); return true; }
      UI.quick = true; openShop('desert_fennec');
      return true;
    }
      
      if (n.role==='workbench'){
        // Scarab Artisan — dialog + gated recipe unlocks
        var f = Game.flags||{};
        var shr = 0; if (f.desert_shrine_wind_done) shr++; if (f.desert_shrine_sun_done) shr++; if (f.desert_shrine_sand_done) shr++;
        var havePass = !!f.desert_caravan_pass;

        // Forest completion & desert portal open per actual code:
        // forest is considered complete when owl trial passed + q_forest_main_done
        var forestDone = !!((f.owl_trial_pass||f.owl_trial_passed) && f.q_forest_main_done);
        // desert portal open is tracked on Game.unlocked.desert in rebuildPortals()
        var desertPortalOpen = !!(Game.unlocked && Game.unlocked.desert);

        function _hasAny(id){
          try{ var inv=Game.inventory||[]; for(var i=0;i<inv.length;i++){ var it=inv[i]; if(it && it.id===id && (it.qty||1)>0) return true; } }catch(_){}
          return false;
        }

        if (!havePass){
          toast('Scarab Artisan: Prove the route. Earn a Caravan Pass, then I\'ll work my bench.');
          return true;
        }

        // Unlock Boots+ only when forest is completed AND desert portal is open AND you've progressed in desert (2+ shrines)
        if (!f.recipe_boots_desert_plus && forestDone && desertPortalOpen && shr>=2){
          toast('Scarab Artisan: Bring stone and reed—I\'ll set Desert Boots + under your soles.');
          _unlockRecipeCompat('boots_desert_plus');
          return true;
        }

        // Unlock Sandstone Blade once Sun shrine is done (or if the player has seen reeds as a hint)
        if (!f.recipe_sandstone_blade && (f.desert_shrine_sun_done || _hasAny('reed'))){
          toast('Scarab Artisan: With reed bindings and sandstone I can fashion a Sandstone Blade.');
          _unlockRecipeCompat('sandstone_blade');
          return true;
        }

        // Flavor rations line (no unlock here)
        if (_hasAny('aloe') || _hasAny('reed')){
          toast('Scarab Artisan: Oasis fare travels well. With aloe and reeds, I\'ll pack you rations.');
          return true;
        }

        toast('Scarab Artisan: Sand cuts keen. Bring sandstone and reeds—I\'ll set a blade for you.');
        return true;
      }

      if (n.role==='scout'){ toast('Vulture Scout: posts mark safe paths.'); return true; }
    }
  }catch(_){}
  return false;
}


  // Stage 8 helpers: count active posts & fast travel
  function _postsActive(){
    const arr = (Game.flags && Array.isArray(Game.flags.desert_landmarks)) ? Game.flags.desert_landmarks : [];
    let c=0; for (let i=0;i<arr.length;i++){ const L=arr[i]; if (L.type==='scout' && L.activated) c++; }
    return c;
  }
  function _fastTravelFrom(current){
    const T = (typeof TILE!=='undefined'?TILE:32);
    const arr = (Game.flags && Array.isArray(Game.flags.desert_landmarks)) ? Game.flags.desert_landmarks : [];
    const posts = [];
    for (let i=0;i<arr.length;i++){ const L=arr[i]; if (L.type==='scout' && L.activated) posts.push({i,tx:L.tx,ty:L.ty}); }
    if (posts.length<2) return false;
    // pick destination: farthest from current
    let best=null, bd=-1;
    for (let k=0;k<posts.length;k++){
      const p=posts[k];
      if (p.tx===current.tx && p.ty===current.ty) continue;
      const d = Math.hypot(p.tx-current.tx, p.ty-current.ty);
      if (d>bd){ bd=d; best=p; }
    }
    if (!best) return false;
    player.x = best.tx*T + (T>>1);
    player.y = best.ty*T + (T>>1);
    toast('Fast-traveled');
    return true;
  }

  function _addItem(id, qty){
    try{
      qty = qty||1;
      if (!Array.isArray(Game.inventory)) Game.inventory=[];
      // merge into stacks if possible
      let s = Game.inventory.find(x=>x.id===id);
      if (s){ s.qty=(s.qty||1)+qty; } else { Game.inventory.push({id, qty}); }
      return true;
    }catch(_){ return false; }
  }

  // === Wind Shrine Trial — Stage 1 (overlay only; close with B or Select) ===
  let __trial = null;

  

function _startWindTrial(){
  // Stage 2 (hard): rotating gust shove + 3 blocks + 3 goals
  __trial = {
    type:'wind',
    t:0,
    gw:7, gh:5, cell:28,
    px:1, py:2,
    blocks:[{x:3,y:2},{x:5,y:1},{x:2,y:1}],           // three blocks
    goals: [{x:5,y:3},{x:6,y:2},{x:2,y:3}],           // three goals
    gustOff: 1.4,   // calm
    gustOn:  2.0,   // gust
    gustActive:false,
    preWarn:false,
    gustDirIndex:0,
    gustDirs:[[1,0],[0,1],[-1,0],[0,-1]],            // E,S,W,N
    gustTick:0,
    msg:'Wind Trial',
    note:'D-Pad to move. B/Select: close.'
  };
  if (typeof toast==='function') toast('Wind Trial');
}
// Launch the Sun Trial overlay using the same single overlay pipeline
function _startSunTrial(){
  // Stage 2 (beam + mirrors): layout that REQUIRES >= 4 reflections
  __trial = {
    type:'sun',
    t:0,
    msg:'Sun Trial',
    note:'←/→ select • A/↑ rotate • B/Select close',
    // 7x5 puzzle grid
    gw:7, gh:5, cell:28,
    // Source at left-center, beam heading east
    source:{ x:0, y:2, dir:[1,0] },
    // Goal placed off the direct line so bounces are required
    goal:{ x:1, y:3 },
    // Mirrors (r: 0='/', 1='\') positioned to force 4 bounces:
    // Path: E to (2,2) '/' -> N -> (2,0) '/' -> E -> (5,0) '\' -> S -> (5,3) '/' -> W -> goal (1,3)
    mirrors:[
      {x:2, y:2, r:0},  // bounce 1
      {x:2, y:0, r:0},  // bounce 2
      {x:5, y:0, r:1},  // bounce 3
      {x:5, y:3, r:0}   // bounce 4
    ],
    sel:0,
    path:[],
    lit:false
  };
  
  // Randomize a few mirrors so it never starts solved but remains solvable.
  // Flip 2-4 unique mirrors.
  try {
    var flips = 2 + ((Math.random()*3)|0);
    var idxs = [];
    while (idxs.length < flips && idxs.length < __trial.mirrors.length){
      var k = (Math.random()*__trial.mirrors.length)|0;
      if (idxs.indexOf(k) === -1) idxs.push(k);
    }
    for (var ii=0; ii<idxs.length; ii++){
      var m = __trial.mirrors[idxs[ii]];
      m.r = (m.r^1); // toggle '/' <-> '\'
    }
  } catch(_){}
if (typeof toast==='function') toast('Sun Trial');
}
// === Sand Shrine Trial — Stage 1 (overlay stub; close with B or Select) ===
function _startSandTrial(){
  // Stage 2: Falling-sand prototype with temporary net platforms
  __trial = {
    type:'sand',
    t:0,
    msg:'Sand Trial — Stage 2',
    note:'D-Pad move • A place net • B/Select close',
    // Grid
    gw:7, gh:7, cell:28,
    // Player start
    px:1, py:5,
    // Goal chest
    goal:{x:5, y:1},
    // Sand emitters (top row columns)
    emit:[{x:1},{x:3},{x:4},{x:6}],
    // State
    sand:[],
    nets:[], netMax:3, netTTL:3.2,
    fallTick:0, fallEvery:0.22
  };
  for (var yy=0; yy<__trial.gh; yy++){ __trial.sand[yy] = Array(__trial.gw).fill(0); }
  if (typeof toast==='function') toast('Sand Trial — Stage 2');
}





  

function _updateTrial(dt, state){
  // === Sand trial logic (Stage 2) ===
  if (__trial && __trial.type === 'sand'){
    __trial.t += (dt||0);
    const peSand = (state && state.pressEdge && typeof state.pressEdge.has==='function') ? state.pressEdge : null;
    // Close overlay
    if (peSand && (peSand.has('B') || peSand.has('Select'))){ __trial = null; return; }

    // Helpers
    const inB = (x,y)=> (x>=0 && x<__trial.gw && y>=0 && y<__trial.gh);
    const occSand = (x,y)=> inB(x,y) ? (__trial.sand[y][x] ? 1 : 0) : 1;
    const occNet  = (x,y)=> inB(x,y) && __trial.nets.findIndex(n=>n.x===x && n.y===y)>=0;
    const solidAt = (x,y)=> occSand(x,y) || occNet(x,y);

    // Movement (1 tile per press)
    if (peSand){
      let mx=0,my=0;
      if (peSand.has('Left'))  mx=-1; else if (peSand.has('Right')) mx=1;
      else if (peSand.has('Up')) my=-1; else if (peSand.has('Down')) my=1;
      if (mx||my){
        const nx = __trial.px + mx, ny = __trial.py + my;
        if (inB(nx,ny) && !solidAt(nx,ny)){ __trial.px = nx; __trial.py = ny; }
      }
      // Place temporary net with A
      if (peSand.has('A')){
        const nx = __trial.px, ny = __trial.py;
        if (!occNet(nx,ny) && __trial.nets.length < __trial.netMax){
          __trial.nets.push({x:nx, y:ny, t:__trial.netTTL});
        }
      }
    }

    // Nets TTL
    for (let i=__trial.nets.length-1; i>=0; i--){
      __trial.nets[i].t -= (dt||0);
      if (__trial.nets[i].t <= 0) __trial.nets.splice(i,1);
    }

    // Sand falling step
    __trial.fallTick += (dt||0);
    if (__trial.fallTick >= __trial.fallEvery){
      __trial.fallTick = 0;

      // spawn from emitters
      for (let e=0; e<__trial.emit.length; e++){
        const ex = __trial.emit[e].x, ey = 0;
        if (!solidAt(ex,ey)) __trial.sand[ey][ex] = 1;
      }
      // fall bottom-up
      for (let y=__trial.gh-2; y>=0; y--){
        for (let x=0; x<__trial.gw; x++){
          if (__trial.sand[y][x] && !solidAt(x, y+1)){
            __trial.sand[y][x] = 0;
            __trial.sand[y+1][x] = 1;
          }
        }
      }
      // nudge player upward if buried
      if (solidAt(__trial.px, __trial.py)){
        if (inB(__trial.px, __trial.py-1) && !solidAt(__trial.px, __trial.py-1)) __trial.py -= 1;
      }
    }
    
    // Victory: reach chest tile
    if (__trial.px === __trial.goal.x && __trial.py === __trial.goal.y){
      if (typeof Game!=='undefined' && Game.flags){ Game.flags.desert_shrine_sand_done = true; }
      if (typeof toast==='function') toast('Sand Shrine complete!');
      __trial = null;

      // Mirror Wind/Sun: if all shrines done, awaken Guardian and grant key + recipe
      try{
        var allDone = Game && Game.flags && Game.flags.desert_shrine_wind_done && Game.flags.desert_shrine_sun_done && Game.flags.desert_shrine_sand_done;
        if (allDone && !Game.flags.desert_oasis_guardian_awake){
          Game.flags.desert_oasis_guardian_awake = true;
          if (typeof _addItem==='function') _addItem('sandstone_key',1);
          if (typeof unlockRecipe==='function'){ unlockRecipe('pot_heal_s_plus'); }
          else {
            if (!Game.recipes) Game.recipes = {};
            Game.recipes['pot_heal_s_plus'] = true;
          }
          if (typeof toast==='function') toast('Oasis Guardian awakens! (Key gained + recipe)');
        }
      }catch(_){}
      return;
    }
return;
  }

if (!__trial) return;
  // Branch by type to avoid altering Wind's logic or frame plumbing
  if (__trial.type === 'sun'){

  __trial.t += (dt||0);

  // Inputs (scoped)
  const peSun = (state && state.pressEdge && typeof state.pressEdge.has==='function') ? state.pressEdge : null;
  if (peSun){
    // Close
    if (peSun.has('B') || peSun.has('Select')){ __trial = null; return; }
    // Select mirror
    if (peSun.has('Left'))  { __trial.sel = (__trial.sel + __trial.mirrors.length - 1) % __trial.mirrors.length; }
    if (peSun.has('Right')) { __trial.sel = (__trial.sel + 1) % __trial.mirrors.length; }
    // Rotate selected
    if (peSun.has('A') || peSun.has('Up')){
      const m = __trial.mirrors[__trial.sel];
      m.r = (m.r + 1) & 1; // '/' <-> '\'
    }
  }

  // Reflect helper (no shared names)
  function reflectSun(sdx, sdy, r){
    if (r===0){ // '/'
      if (sdx=== 1 && sdy===0) return [0,-1];
      if (sdx===-1 && sdy===0) return [0, 1];
      if (sdx=== 0 && sdy===-1) return [1, 0];
      if (sdx=== 0 && sdy=== 1) return [-1,0];
    }else{      // '\'
      if (sdx=== 1 && sdy===0) return [0, 1];
      if (sdx===-1 && sdy===0) return [0,-1];
      if (sdx=== 0 && sdy===-1) return [-1,0];
      if (sdx=== 0 && sdy=== 1) return [1, 0];
    }
    return [sdx,sdy];
  }

  const gwSun = __trial.gw, ghSun = __trial.gh;
  const occMirrorSun = (mx,my)=> __trial.mirrors.findIndex(mm=>mm.x===mx && mm.y===my);

  let sx = __trial.source.x, sy = __trial.source.y;
  let sdx = __trial.source.dir[0], sdy = __trial.source.dir[1];
  const pathSun = [];
  let litSun = false;
  let stepsSun = 0, maxStepsSun = 256;

  while (stepsSun++ < maxStepsSun){
    const nx = sx + sdx, ny = sy + sdy;
    if (nx < 0 || nx >= gwSun || ny < 0 || ny >= ghSun) break;
    pathSun.push({x:nx, y:ny});

    if (nx===__trial.goal.x && ny===__trial.goal.y){ litSun = true; break; }

    const mi = occMirrorSun(nx, ny);
    if (mi !== -1){
      const m = __trial.mirrors[mi];
      const out = reflectSun(sdx, sdy, m.r);
      sdx = out[0]; sdy = out[1];
    }

    sx = nx; sy = ny;
  }

  __trial.path = pathSun;
  __trial.lit  = litSun;
  
  // --- Stage 3: auto-complete when lit ---
  if (__trial.lit){
    __trial.victoryT = (__trial.victoryT||0) + (dt||0);
    if (__trial.victoryT > 0.18){
      try{
        if (typeof Game!=='undefined' && Game && Game.flags){
          if (!Game.flags.desert_shrine_sun_done){
            Game.flags.desert_shrine_sun_done = true;
            if (typeof toast==='function') toast('Sun Shrine complete!');
          }
          // Guardian + key + recipe if all shrines now done
          var allDone = !!(Game.flags.desert_shrine_wind_done && Game.flags.desert_shrine_sand_done && Game.flags.desert_shrine_sun_done);
          if (allDone && !Game.flags.desert_oasis_guardian_awake){
            Game.flags.desert_oasis_guardian_awake = true;
            if (typeof _addItem==='function') _addItem('sandstone_key',1);
            // Try to unlock crafting recipe in whichever system exists
            if (typeof unlockRecipe==='function'){ unlockRecipe('pot_heal_s_plus'); }
            else {
              Game.flags.recipe_pot_heal_s_plus = true;
              if (Game.recipesUnlocked) Game.recipesUnlocked['pot_heal_s_plus'] = true;
            }
            if (typeof toast==='function') toast('Oasis Guardian awakens! (Key gained + recipe)');
          }
        }
      }catch(_){}
      __trial = null; // close overlay
      return;
    }
  } else {
    __trial.victoryT = 0;
  }
return;
}


  if (!__trial) return;
  __trial.t += (dt||0);

  // Gust phase
  var off = __trial.gustOff||0, on = __trial.gustOn||0;
  var per = (off+on)>0 ? (off+on) : 1;
  var phase = __trial.t % per;
  var wasActive = __trial.gustActive;
  __trial.gustActive = phase >= off;
  __trial.preWarn    = (!__trial.gustActive) && (phase >= Math.max(0, off - 0.35));

  function cellFree(x,y){
    if (x<0||x>=__trial.gw||y<0||y>=__trial.gh) return false;
    for (var i=0;i<__trial.blocks.length;i++){ var b=__trial.blocks[i]; if (b.x===x && b.y===y) return false; }
    return true;
  }
  function allBlocksOnGoals(){
    var ok = 0;
    for (var g=0; g<__trial.goals.length; g++){
      var gx = __trial.goals[g].x, gy = __trial.goals[g].y, hit=false;
      for (var b=0; b<__trial.blocks.length; b++){ var bl=__trial.blocks[b]; if (bl.x===gx && bl.y===gy){ hit=true; break; } }
      if (hit) ok++;
    }
    return ok === __trial.goals.length;
  }

  // rotate wind and shove once on gust start
  if (!wasActive && __trial.gustActive){
    __trial.gustDirIndex = (__trial.gustDirIndex + 1) % __trial.gustDirs.length;
    var d0 = __trial.gustDirs[__trial.gustDirIndex];
    var sx = __trial.px + d0[0], sy = __trial.py + d0[1];
    if (cellFree(sx,sy)){ __trial.px = sx; __trial.py = sy; }
    __trial.gustTick = 0;
  }

  // continuous shove every ~0.45s during gust
  if (__trial.gustActive){
    __trial.gustTick += (dt||0);
    if (__trial.gustTick >= 0.45){
      __trial.gustTick = 0;
      var d = __trial.gustDirs[__trial.gustDirIndex];
      var tx = __trial.px + d[0], ty = __trial.py + d[1];
      if (cellFree(tx,ty)){ __trial.px = tx; __trial.py = ty; }
    }
  }

  // input
  var pe = (state && state.pressEdge && typeof state.pressEdge.has==='function') ? state.pressEdge : null;
  if (!pe) return;

  // Close overlay
  if (pe.has('B') || pe.has('Select')){ __trial = null; return; }

  // No manual movement during gust
  if (__trial.gustActive) return;

  // Movement
  var dx=0, dy=0;
  if (pe.has('Left')) dx=-1; else if (pe.has('Right')) dx=1;
  else if (pe.has('Up')) dy=-1; else if (pe.has('Down')) dy=1;
  if (!(dx||dy)) return;

  var nx = __trial.px + dx, ny = __trial.py + dy;
  if (nx<0 || nx>=__trial.gw || ny<0 || ny>=__trial.gh) return;

  var bi=-1;
  for (var i=0;i<__trial.blocks.length;i++){ var bb=__trial.blocks[i]; if (bb.x===nx && bb.y===ny){ bi=i; break; } }

  if (bi===-1){
    __trial.px = nx; __trial.py = ny;
  }else{
    var bx2 = nx + dx, by2 = ny + dy;
    if (bx2<0 || bx2>=__trial.gw || by2<0 || by2>=__trial.gh) return;
    var occ=false;
    for (var j=0;j<__trial.blocks.length;j++){ var bc=__trial.blocks[j]; if (bc.x===bx2 && bc.y===by2){ occ=true; break; } }
    if (!occ){
      __trial.blocks[bi].x = bx2; __trial.blocks[bi].y = by2;
      __trial.px = nx; __trial.py = ny;
    }
  }

  // Victory check
  if (allBlocksOnGoals()){
    if (typeof Game!=='undefined' && Game.flags){ Game.flags.desert_shrine_wind_done = true; }
    if (typeof toast==='function') toast('Wind Shrine - completed.');
    __trial = null;
  }


}



  

function _drawTrial(ctx){
  if (__trial && __trial.type === 'sand'){
    var ui = ctx;
    if (ui && typeof ui.setTransform==='function') ui.setTransform(1,0,0,1,0,0);
    var cw = (ui && ui.canvas && ui.canvas.width) ? ui.canvas.width : 960;
    var ch = (ui && ui.canvas && ui.canvas.height) ? ui.canvas.height : 528;

    // Backdrop
    ui.save(); ui.globalAlpha = 0.60; ui.fillStyle = '#000'; ui.fillRect(0,0,cw,ch); ui.restore();

    // Panel
    var W=520, H=320, px=(cw-W)/2, py=(ch-H)/2;
    ui.fillStyle = 'rgba(46,36,18,.94)'; ui.fillRect(px,py,W,H);
    ui.strokeStyle = 'rgba(255,230,160,.85)'; ui.lineWidth = 2; ui.strokeRect(px+1,py+1,W-2,H-2);

    // Header
    ui.font = '16px ui-monospace'; ui.fillStyle = '#ffe9b8';
    ui.fillText(__trial.msg || 'Sand Trial — Stage 2', px+16, py+28);
    ui.fillText(__trial.note || 'D-Pad move • A place net • B/Select close', px+16, py+48);

    // Grid background
    var gCell = __trial.cell, gw = __trial.gw, gh = __trial.gh;
    var gx = px + 24, gy = py + 72;
    ui.fillStyle = 'rgba(32,24,12,0.85)'; ui.fillRect(gx-6, gy-6, gw*gCell+12, gh*gCell+12);
    ui.strokeStyle = 'rgba(255,255,255,0.22)'; ui.strokeRect(gx-6+0.5, gy-6+0.5, gw*gCell+12-1, gh*gCell+12-1);

    for (var yy=0; yy<gh; yy++){
      for (var xx=0; xx<gw; xx++){
        var cx = gx + xx*gCell, cy = gy + yy*gCell;
        ui.fillStyle = 'rgba(120,96,42,0.12)'; ui.fillRect(cx, cy, gCell-2, gCell-2);
        ui.strokeStyle = 'rgba(255,255,255,0.08)'; ui.strokeRect(cx+0.5, cy+0.5, gCell-3, gCell-3);
      }
    }

    // Goal chest
    (function(){
      var gx2 = gx + __trial.goal.x*gCell, gy2 = gy + __trial.goal.y*gCell;
      ui.fillStyle = '#8a5a2f'; ui.fillRect(gx2+6, gy2+10, gCell-12, gCell-10);
      ui.strokeStyle = '#5a3a1f'; ui.strokeRect(gx2+6+0.5, gy2+10+0.5, gCell-12-1, gCell-10-1);
      ui.fillStyle = '#d9c36a'; ui.fillRect(gx2 + gCell/2 - 1, gy2 + 14, 2, 6);
    })();

    // Nets
    for (var ni=0; ni<__trial.nets.length; ni++){
      var n = __trial.nets[ni];
      var cx = gx + n.x*gCell, cy = gy + n.y*gCell;
      ui.fillStyle = 'rgba(220,220,220,0.85)'; ui.fillRect(cx+4, cy+12, gCell-8, 6);
      ui.strokeStyle = 'rgba(140,116,70,0.85)'; ui.lineWidth = 1;
      ui.strokeRect(cx+4+0.5, cy+12+0.5, gCell-8-1, 6-1);
      ui.beginPath();
      ui.moveTo(cx+6, cy+12); ui.lineTo(cx+gCell-6, cy+18);
      ui.moveTo(cx+6, cy+18); ui.lineTo(cx+gCell-6, cy+12);
      ui.stroke();
    }

    // Sand
    for (var sy=0; sy<__trial.gh; sy++){
      for (var sx=0; sx<__trial.gw; sx++){
        if (__trial.sand[sy][sx]){
          var cx = gx + sx*gCell, cy = gy + sy*gCell;
          ui.fillStyle = '#d4b86a'; ui.fillRect(cx+4, cy+4, gCell-8, gCell-8);
          ui.strokeStyle = '#7c6a36'; ui.strokeRect(cx+4+0.5, cy+4+0.5, gCell-9, gCell-9);
        }
      }
    }

    // Emitters hint
    for (var ei=0; ei<__trial.emit.length; ei++){
      var ex = __trial.emit[ei].x;
      var cx = gx + ex*gCell, cy = gy + 0*gCell;
      ui.fillStyle = 'rgba(212,184,106,0.55)'; ui.fillRect(cx+6, cy+2, gCell-12, 6);
    }

    // Player
    (function(){
      var px2 = gx + __trial.px*gCell, py2 = gy + __trial.py*gCell;
      ui.fillStyle = '#dfe8ff'; ui.fillRect(px2+8, py2+8, gCell-16, gCell-16);
      ui.strokeStyle = '#4a5a7a'; ui.strokeRect(px2+8+0.5, py2+8+0.5, gCell-17, gCell-17);
    })();

    return;
  }

if (!__trial) return;
  if (__trial.type === 'sun'){

  var ui = ctx;
  if (ui && typeof ui.setTransform==='function') ui.setTransform(1,0,0,1,0,0);
  var cw = (ui && ui.canvas && ui.canvas.width) ? ui.canvas.width : 960;
  var ch = (ui && ui.canvas && ui.canvas.height) ? ui.canvas.height : 528;

  // Backdrop
  ui.save(); ui.globalAlpha = 0.60; ui.fillStyle = '#000'; ui.fillRect(0,0,cw,ch); ui.restore();

  // Panel
  var W=520, H=300, px=(cw-W)/2, py=(ch-H)/2;
  ui.fillStyle = 'rgba(60,44,16,.92)'; ui.fillRect(px,py,W,H);
  ui.strokeStyle = 'rgba(255,230,160,.92)'; ui.lineWidth = 2; ui.strokeRect(px+1,py+1,W-2,H-2);

  // Header
  ui.font = '16px ui-monospace'; ui.fillStyle = '#ffe9b8';
  ui.fillText(__trial.msg || 'Sun Trial — Stage 2', px+16, py+28);
  ui.fillText(__trial.note || '←/→ select • A/↑ rotate • B/Select close', px+16, py+48);

  // Grid
  var gCell = __trial.cell, gw = __trial.gw, gh = __trial.gh;
  var gx = px + 24, gy = py + 74;
  ui.fillStyle = 'rgba(26,22,12,0.85)'; ui.fillRect(gx-6, gy-6, gw*gCell+12, gh*gCell+12);
  ui.strokeStyle = 'rgba(255,255,255,0.22)'; ui.strokeRect(gx-6+0.5, gy-6+0.5, gw*gCell+12-1, gh*gCell+12-1);

  for (var yy=0; yy<gh; yy++){
    for (var xx=0; xx<gw; xx++){
      var cx = gx + xx*gCell, cy = gy + yy*gCell;
      ui.fillStyle = 'rgba(80,64,26,0.18)'; ui.fillRect(cx, cy, gCell-2, gCell-2);
      ui.strokeStyle = 'rgba(255,255,255,0.08)'; ui.strokeRect(cx+0.5, cy+0.5, gCell-3, gCell-3);
    }
  }

  // Goal
  (function(){
    var sx = gx + __trial.goal.x*gCell, sy = gy + __trial.goal.y*gCell;
    ui.strokeStyle = __trial.lit ? '#fff3c2' : 'rgba(255,240,180,0.6)';
    ui.lineWidth = 2;
    ui.strokeRect(sx+5.5, sy+5.5, gCell-11, gCell-11);
    if (__trial.lit){
      ui.font = '14px ui-monospace'; ui.fillStyle = '#fff3c2';
      ui.fillText('LIT', sx + 6, sy + gCell - 8);
    }
  })();

  // Source (sun)
  (function(){
    var sx = gx + __trial.source.x*gCell + gCell/2;
    var sy = gy + __trial.source.y*gCell + gCell/2;
    ui.fillStyle = '#ffd34a';
    ui.beginPath(); ui.arc(sx,sy, gCell*0.28, 0, Math.PI*2); ui.fill();
    ui.strokeStyle = '#7a5a12'; ui.lineWidth = 2; ui.stroke();
  })();

  // Mirrors
  for (var m=0; m<__trial.mirrors.length; m++){
    var mm = __trial.mirrors[m];
    var cx = gx + mm.x*gCell, cy = gy + mm.y*gCell;
    if (m===__trial.sel){
      ui.strokeStyle = 'rgba(255,230,160,0.9)'; ui.lineWidth = 2;
      ui.strokeRect(cx+2.5, cy+2.5, gCell-5, gCell-5);
    }
    ui.strokeStyle = '#ffeabf'; ui.lineWidth = 2.5;
    if (mm.r===0){ // '/'
      ui.beginPath(); ui.moveTo(cx+5, cy+gCell-5); ui.lineTo(cx+gCell-5, cy+5); ui.stroke();
    }else{         // '\'
      ui.beginPath(); ui.moveTo(cx+5, cy+5); ui.lineTo(cx+gCell-5, cy+gCell-5); ui.stroke();
    }
  }

  // Beam
  if (__trial.path && __trial.path.length){
    ui.strokeStyle = __trial.lit ? '#fff3c2' : '#ffd98a';
    ui.lineWidth = 3;
    ui.beginPath();
    var sx0 = gx + __trial.source.x*gCell + gCell/2;
    var sy0 = gy + __trial.source.y*gCell + gCell/2;
    ui.moveTo(sx0, sy0);
    for (var p=0; p<__trial.path.length; p++){
      var cell = __trial.path[p];
      var cx = gx + cell.x*gCell + gCell/2;
      var cy = gy + cell.y*gCell + gCell/2;
      ui.lineTo(cx, cy);
    }
    ui.stroke();
  }
  return;
}


  if (!__trial) return;
  var ui = ctx;
  if (ui && typeof ui.setTransform==='function') ui.setTransform(1,0,0,1,0,0);

  var cw = (ui && ui.canvas && ui.canvas.width) ? ui.canvas.width : 960;
  var ch = (ui && ui.canvas && ui.canvas.height) ? ui.canvas.height : 528;

  // backdrop
  ui.save();
  ui.globalAlpha = 0.60; ui.fillStyle = '#000'; ui.fillRect(0,0,cw,ch);
  ui.restore();

  // panel
  var W=480, H=242, px = (cw - W)/2, py = (ch - H)/2;
  ui.fillStyle = 'rgba(20,30,50,.92)'; ui.fillRect(px, py, W, H);
  ui.strokeStyle = 'rgba(255,255,255,.85)'; ui.lineWidth = 2; ui.strokeRect(px+1, py+1, W-2, H-2);

  // header
  ui.font = '16px ui-monospace'; ui.fillStyle = '#dfe8ff';
  ui.fillText(__trial.msg || 'Wind Trial — Stage 2',  px + 16, py + 26);
  // moved help text left to avoid overlap on small screens
  ui.fillText(__trial.note || 'D-Pad move. B/Select close.', px + 16, py + 46);

  // chimes moved to top-right to avoid the help line
  function chime(x,y,s,lit){ ui.fillStyle = lit ? '#bde6ff' : '#6e88a8'; ui.fillRect(x, y, s, 3); ui.fillRect(x+s+2, y, s, 3); ui.fillRect(x+2*s+4, y, s, 3); }
  var chX = px + W - 120, chY = py + 18;
  chime(chX,     chY, 18, __trial.preWarn && !__trial.gustActive);
  chime(chX, chY+ 6, 18, __trial.gustActive);

  // explicit wind label (avoids arrow confusion on mobile)
  var d = __trial.gustDirs[__trial.gustDirIndex] || [1,0];
  var windLabel = (d[0]===1?'E': d[0]===-1?'W': d[1]===1?'S':'N');
  ui.font = '14px ui-monospace'; ui.fillStyle = __trial.gustActive ? '#ff9a9a' : '#9acbff';
  ui.fillText('Wind: ' + windLabel, px + W - 92, py + 44);

  // grid
  var gCell = __trial.cell, gw = __trial.gw, gh = __trial.gh;
  var gx = px + 24, gy = py + 70;
  ui.fillStyle = 'rgba(10,16,26,0.85)'; ui.fillRect(gx-6, gy-6, gw*gCell+12, gh*gCell+12);
  ui.strokeStyle = 'rgba(255,255,255,0.25)'; ui.strokeRect(gx-6+0.5, gy-6+0.5, gw*gCell+12-1, gh*gCell+12-1);

  for (var yy=0; yy<gh; yy++){
    for (var xx=0; xx<gw; xx++){
      var cx = gx + xx*gCell, cy = gy + yy*gCell;
      ui.fillStyle = 'rgba(32,49,79,0.20)'; ui.fillRect(cx, cy, gCell-2, gCell-2);
      ui.strokeStyle = 'rgba(255,255,255,0.08)'; ui.strokeRect(cx+0.5, cy+0.5, gCell-3, gCell-3);
    }
  }

  // goals (three)
  for (var k=0; k<__trial.goals.length; k++){
    var g = __trial.goals[k];
    var gcx = gx + g.x*gCell, gcy = gy + g.y*gCell;
    ui.strokeStyle = 'rgba(190,220,255,0.9)'; ui.lineWidth = 2;
    ui.strokeRect(gcx+4.5, gcy+4.5, gCell-9, gCell-9);
  }

  // blocks (three)
  for (var b=0; b<__trial.blocks.length; b++){
    var bl = __trial.blocks[b];
    var bcx = gx + bl.x*gCell, bcy = gy + bl.y*gCell;
    ui.fillStyle = '#9aaad0'; ui.fillRect(bcx+4, bcy+4, gCell-10, gCell-10);
    ui.strokeStyle = '#3d4f77'; ui.strokeRect(bcx+4.5, bcy+4.5, gCell-10, gCell-10);
  }

  // player cursor
  var pcx = gx + __trial.px*gCell, pcy = gy + __trial.py*gCell;
  ui.fillStyle = '#ffd34a';
  ui.beginPath();
  ui.moveTo(pcx + gCell/2, pcy + 4);
  ui.lineTo(pcx + gCell - 6, pcy + gCell/2);
  ui.lineTo(pcx + gCell/2, pcy + gCell - 6);
  ui.lineTo(pcx + 6, pcy + gCell/2);
  ui.closePath(); ui.fill();
  ui.strokeStyle = '#7a5a12'; ui.lineWidth = 2; ui.stroke();

  // gust label
  ui.font = '14px ui-monospace';
  if (__trial.gustActive){ ui.fillStyle = '#ff8c8c'; ui.fillText('GUST!', px + W - 72, py + 64); }
  else if (__trial.preWarn){ ui.fillStyle = '#ffd34a'; ui.fillText('…chimes…', px + W - 120, py + 64); }

  // Optional success ribbon if already complete and still visible (rare)
  if (typeof Game!=='undefined' && Game.flags && Game.flags.desert_shrine_wind_done){
    ui.font = '14px ui-monospace'; ui.fillStyle = '#bdf5c8';
    ui.fillText('✓ Completed', px + 16, py + H - 12);
  }

}


return { interactNearby,  ensureData, seedLandmarks ,
    _trialUpdate:(dt,st)=>_updateTrial(dt,st),
    _trialDraw:(ctx)=>_drawTrial(ctx)
  };
})();
// === end Desert module ===



// === Patch: Cheats UI registry ===
const CheatsUI = { idx:0, list:[
  {code:'CHESTHERE',desc:'Spawn chest here'},
  {code:'CHESTME',desc:'Spawn chest one tile ahead'},
  {code:'FORESTOPEN',desc:'Unlock Forest'}, {code:'DESERTOPEN',desc:'Unlock Desert'},
  {code:'WETLANDSOPEN',desc:'Unlock Wetlands'}, {code:'VOLCANOOPEN',desc:'Unlock Volcano'},
  {code:'GLACIEROPEN',desc:'Unlock Glacier'}, {code:'MYSTICOPEN',desc:'Unlock Mystic'},
  {code:'SKYREALMOPEN',desc:'Unlock Sky Realm'}, {code:'UNDERSEAOPEN',desc:'Unlock Undersea'},
  {code:'MYTHIC',desc:'Spawn mythic pal'}, {code:'LEGENDARY',desc:'Spawn legendary pal'},
  {code:'RARE',desc:'Spawn rare pal'}, {code:'RICHIE',desc:'+1000 coins'}, {code:'MONEYRAIN',desc:'+5000 coins'},
  {code:'BUFFME',desc:'Defense buff'}, {code:'ULTRASPEED',desc:'Speed buff'}, {code:'PARTYTIME',desc:'Confetti'},
  {code:'ALLOPEN',desc:'Unlock main biomes'}, {code:'SECRETSOPEN',desc:'Unlock secret biomes'}
,
    {code:'SPRITEHERE', desc:'Spawn a sprite at your position'},
    {code:'CLEARSPRITE', desc:'Remove any sprite on map'},
    {code:'CLEARBOSS', desc:'Remove boar mini-boss'}]};
let CheatsHistory = [];

  // ---------- Canvases / Ctx ----------
  const cvsP = document.getElementById('game');
  const cvsL = document.getElementById('gameLandscape');
  const ctxP = cvsP.getContext('2d'), ctxL = cvsL.getContext('2d');
  ctxP.imageSmoothingEnabled = false; ctxL.imageSmoothingEnabled = false;

  // ---------- Mode & Input ----------
  const state = { pressed:new Set(), pressEdge:new Set(), taps:[], mode:'portrait' };
// === Patch: directional memory + chest/particle arrays ===
const lastDir = { x:0, y:1 }; // track last facing (default down)
// use globalThis to avoid TDZ on self-referential typeof checks
let chests = Array.isArray(globalThis.chests) ? globalThis.chests : [];
let particles = Array.isArray(globalThis.particles) ? globalThis.particles : [];



  function activeCanvas(){ return state.mode==='portrait'? cvsP : cvsL; }
  function activeCtx(){ return state.mode==='portrait'? ctxP : ctxL; }
  function setModeFromMedia(){
    const isLandscapeMobile = matchMedia('(orientation: landscape) and (max-width: 940px)').matches;
    state.mode = isLandscapeMobile ? 'landscape' : 'portrait';
  }
  setModeFromMedia(); addEventListener('resize', setModeFromMedia);

  const keyMap = {
    ArrowUp:'Up', ArrowDown:'Down', ArrowLeft:'Left', ArrowRight:'Right',
    KeyW:'Up', KeyS:'Down', KeyA:'Left', KeyD:'Right',
    KeyE:'A', KeyJ:'A',
    KeyQ:'B', KeyK:'B',
    Enter:'Start', Escape:'Start',
    Space:'Select', Tab:'Select',
    KeyZ:'Z'
  };
  addEventListener('keydown', e=>{ const n=keyMap[e.code]; if(n){ e.preventDefault(); if(!state.pressed.has(n)) state.pressEdge.add(n); state.pressed.add(n); pulse(n);} });
  addEventListener('keyup',   e=>{ const n=keyMap[e.code]; if(n){ e.preventDefault(); state.pressed.delete(n);} });

  function bindBtn(id, name){
    const el=document.getElementById(id); if(!el) return;
    const down=(ev)=>{ev.preventDefault(); if(!state.pressed.has(name)) state.pressEdge.add(name); state.pressed.add(name); pulse(name);};
    const up  =(ev)=>{ev.preventDefault(); state.pressed.delete(name);};
    el.addEventListener('touchstart',down,{passive:false});
    el.addEventListener('touchend',up,{passive:false});
    el.addEventListener('touchcancel',up,{passive:false});
    el.addEventListener('mousedown',down); el.addEventListener('mouseup',up); el.addEventListener('mouseleave',up);
  }
  ['btnUp:Up','btnDown:Down','btnLeft:Left','btnRight:Right','btnA:A','btnB:B','btnZ:Z','btnStart:Start','btnSelect:Select',
   'lUp:Up','lDown:Down','lLeft:Left','lRight:Right','lA:A','lB:B','lZ:Z','lStart:Start','lSelect:Select']
   .forEach(p=>{ const [id,n]=p.split(':'); bindBtn(id,n); });
  function pulse(name){ state.taps.push({name, t: performance.now()}); if(state.taps.length>24) state.taps.shift(); }

  // ---------- RNG ----------

function drawQuickPanel(ctx,w,h){
  const body = document.getElementById('quickBody') || {innerHTML:''};
  if (QUICK_TABS && QUICK_TABS[quickTab]==='Cheats'){
    const rows = CheatsUI.list.map((c,i)=>`<div class="row ${i===CheatsUI.idx?'active':''}"><h4>${c.code}</h4><p>${c.desc}</p></div>`).join('');
    body.innerHTML = `<div class="cheatsTab">${rows}</div>`;
  }
}



  function mulberry32(seed){ return function(){ let t=seed+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; }; }
  const RNG = {
    _f: mulberry32(0xC0FFEE),
    reseed(s){ this._f = mulberry32((s>>>0) || 0xC0FFEE); },
    f(){ return this._f(); },
    i(a,b){ return a + ((this.f()*((b+1)-a))|0); },
    chance(p){ return this.f() < p; }
  };

  // ---------- Map / Terrain ----------
  const TILE=32, W=128, H=96; // world tiles
  const ground = new Uint8Array(W*H), deco = new Uint8Array(W*H);
  const seen  = new Uint8Array(W*H); // minimap fog-of-war (1=seen)
  function gi(x,y){ return y*W + x; }

  // ground codes: 0,1,2=grass; 3=path; 4=water; 5=BRUSH (forest blocking)
  const BRUSH=5;
  const COLORS={ 0:'#1b4d2b',1:'#2f7a3f',2:'#57a35c',3:'#8a6a44',4:'#3a78b8',5:'#144925' };
// === Patch: draw chests helper ===
function drawChests(gb, vx, vy){ { for(const c of chests){ const cx=(c.x - vx)|0, cy=(c.y - vy)|0; gb.fillStyle = c.opened ? '#b79a36' : '#ffd04a'; gb.fillRect(cx, cy, (c.w||TILE-12), (c.h||TILE-12)); gb.strokeStyle='#6a4b00'; gb.strokeRect(cx+0.5, cy+0.5, (c.w||TILE-12)-1, (c.h||TILE-12)-1); } } }


  function perlinish(x,y,sx,sy){ return (Math.sin(x*sx)+Math.cos(y*sy)+2)/4; }

  
  // === Desert color helpers (visual-only) ===
  function mixRGB(a,b,t){ const r=(a[0]*(1-t)+b[0]*t)|0, g=(a[1]*(1-t)+b[1]*t)|0, bl=(a[2]*(1-t)+b[2]*t)|0; return 'rgb('+r+','+g+','+bl+')'; }
  // Base sand: #bdae80
  const SAND_BASE=[189,174,128], SAND_LIGHT=[230,216,170], SAND_DARK=[158,144,104];
  function desertTone(tx,ty){
    // subtle bands like dunes; combine two slow waves
    const k1 = (Math.sin(tx*0.09)+1)*0.5;
    const k2 = (Math.cos(ty*0.07)+1)*0.5;
    const t = 0.25 + 0.5*((k1*0.6 + k2*0.4)); // 0.25..0.75
    // bias around SAND_BASE
    const mid = mixRGB(SAND_DARK, SAND_LIGHT, t);
    return mid;
  }


function wetlandsTone(tx,ty){
  var g = ground[gi(tx,ty)];
  var base =
    (g===4) ? '#2a3b3b' :   // water - murky teal
    (g===3) ? '#32412c' :   // brush - swampy dark green
    (g===2) ? '#3a2e24' :   // mud - deep brown-olive
    (g===1) ? '#2e4b2f' :   // grass - moss green
              '#2b2f26';    // default - peat earth
  var n = _hashNoise(tx,ty);
  var k = 0.10 + (n*0.08);  // darken 10–18%
  return _shade(base, k);
}
// Meadow gen
  function regenMeadow(){
    ground.fill(0); deco.fill(0); seen.fill(0);
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){
      const k = perlinish(x,y,0.09,0.07);
      ground[gi(x,y)] = k<0.28?0 : k<0.55?1 : 2;
    }
    // path
    let py=(H*0.55)|0, wigg=0;
    for(let x=2;x<W-2;x++){
      wigg+=(RNG.f()-0.5)*0.8; py=Math.max(4,Math.min(H-5, py+(wigg|0)));
      for(let yy=-1; yy<=1; yy++) ground[gi(x,py+yy)]=3;
      if(RNG.f()<0.08) ground[gi(x,py+2)]=3;
    }
    // ponds + reeds
    for(let n=0;n<6;n++){
      const cx=RNG.i(10,W-10), cy=RNG.i(10,H-10), r=RNG.i(3,6);
      for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){
        if(x*x+y*y<=r*r){ const gx=cx+x, gy=cy+y; if(gx>1&&gy>1&&gx<W-2&&gy<H-2) ground[gi(gx,gy)]=4; }
      }
      for(let y=-r-1;y<=r+1;y++) for(let x=-r-1;x<=r+1;x++){
        const gx=cx+x, gy=cy+y; if(gx<1||gy<1||gx>=W-1||gy>=H-1) continue;
        if(ground[gi(gx,gy)]!==4){
          const n4 = (ground[gi(gx+1,gy)]===4)+(ground[gi(gx-1,gy)]===4)+(ground[gi(gx,gy+1)]===4)+(ground[gi(gx,gy-1)]===4);
          if(n4 && RNG.f()<0.25) deco[gi(gx,gy)]=4; // reeds
        }
      }
    }
    // scatter (flowers/bush/rock)
    for(let y=2;y<H-2;y++) for(let x=2;x<W-2;x++){
      if(ground[gi(x,y)]<=2){
        const r=RNG.f();
        deco[gi(x,y)] = r<0.04?1 : r<0.065?2 : r<0.075?3 : deco[gi(x,y)];
      }
    }
  }

  // Forest gen (adds BRUSH)
  
function regenMeadow(){
  ground.fill(0); deco.fill(0); seen.fill(0);
  // gentle grass bands
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const k = perlinish(x,y,0.09,0.07);
    ground[gi(x,y)] = k<0.28?0 : k<0.55?1 : 2;
  }
  // path
  let py=(H*0.55)|0, w=0;
  for(let x=2;x<W-2;x++){
    w+=(RNG.f()-0.5)*0.8; py=Math.max(4,Math.min(H-5, py+(w|0)));
    for(let yy=-1; yy<=1; yy++) ground[gi(x,py+yy)]=3;
  }
  // ponds
  for(let n=0;n<5;n++){
    const cx=RNG.i(10,W-10), cy=RNG.i(10,H-10), r=RNG.i(3,6);
    for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){
      if(x*x+y*y<=r*r){ const gx=cx+x, gy=cy+y; if(gx>1&&gy>1&&gx<W-2&&gy<H-2) ground[gi(gx,gy)]=4; }
    }
  }
}

function regenForest(){
  ground.fill(1); deco.fill(0); seen.fill(0);
  // mix of grass tones
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const k = perlinish(x,y,0.07,0.09);
    ground[gi(x,y)] = k<0.18?0 : k<0.45?1 : 2;
    if (RNG.f()<0.02) deco[gi(x,y)] = 2; // bushes (visual)
    if (RNG.f()<0.015) deco[gi(x,y)] = 5; // tree chunk (visual)
  }
  // path
  let py=(H*0.60)|0, w=0;
  for(let x=2;x<W-2;x++){
    w+=(RNG.f()-0.5)*0.6; py=Math.max(5,Math.min(H-6, py+(w|0)));
    for(let yy=-1; yy<=1; yy++) ground[gi(x,py+yy)]=3;
  }
  // small ponds
  for(let n=0;n<4;n++){
    const cx=RNG.i(12,W-12), cy=RNG.i(12,H-12), r=RNG.i(3,7);
    for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){
      if(x*x+y*y<=r*r){ const gx=cx+x, gy=cy+y; if(gx>1&&gy>1&&gx<W-2&&gy<H-2) ground[gi(gx,gy)]=4; }
    }
  }
  // BRUSH patches
  for(let y=2;y<H-2;y++) for(let x=2;x<W-2;x++){
    if (ground[gi(x,y)]<=2 && RNG.f()<0.045){
      for(let yy=-1; yy<=1; yy++) for(let xx=-1; xx<=1; xx++){
        const gx=x+xx, gy=y+yy; if (gx>1&&gy>1&&gx<W-2&&gy<H-2 && ground[gi(gx,gy)]!==4) ground[gi(gx,gy)]=BRUSH;
      }
    }
  }
}

function regenDesert(){
  ground.fill(0); deco.fill(0); seen.fill(0);
  // Place 1-2 oases
  const ponds = 1 + (RNG.f()<0.35?1:0);
  for(let n=0;n<ponds;n++){
    const cx=RNG.i(12,W-12), cy=RNG.i(10,H-10), r=RNG.i(4,7);
    for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){
      if(x*x+y*y<=r*r){ const gx=cx+x, gy=cy+y; if(gx>1&&gy>1&&gx<W-2&&gy<H-2) ground[gi(gx,gy)]=4; }
    }
  }
  // Sparse deco: cactus(10), rock(11), dry shrub(12)
  for(let y=2;y<H-2;y++) for(let x=2;x<W-2;x++){
    if (ground[gi(x,y)]===4) continue; // keep water clear
    const r=RNG.f();
    deco[gi(x,y)] = (r<0.008)?10 : (r<0.013)?11 : (r<0.018)?12 : 0;
  }

  // ensure oasis mats exist
  oasisSpawn();
}


  // ---------- Registries ----------
  const ITEMS = { cactus:{cat:"material"}, sandstone:{cat:"material"}, aloe:{cat:"material"},
    wood:{cat:"material"}, stone:{cat:"material"}, berry:{cat:"material"}, herb:{cat:"material"},
    reed:{cat:"material"}, mushroom:{cat:"material"}, fiber:{cat:"material"},
    net_basic:{cat:"tool", chargesMax:3}, net_fine:{cat:"tool"},
    pot_heal_s:{cat:"consumable"},
      axe_basic:{cat:"tool"},
    weapon_stick:{cat:"weapon", chargesMax:10, dmg:8},
    relic_feather:{cat:"quest"},
    boots_desert:{cat:"armor"}
,
    sandstone_key:{cat:"quest"}
,
    pot_heal_s_plus:{cat:"consumable"}

  , desert_rations: { kind:'consumable', label:'Desert Rations', desc:'+5 HP', use:function(game){
      try{
        var hpMax = (game.hpMax||20);
        game.hp = Math.min(hpMax, (game.hp||hpMax) + 5);
        return true;
      }catch(_){ return false; }
    } }
,
  sandstone_blade:{ name:'Sandstone Blade', cat:'weapon', dmg:12, desc:'Rough but sharp desert blade.' , chargesMax:20},
  aloe_bundle:{ name:'Aloe Bundle', cat:'material', desc:'Bundle of desert aloe leaves.' },
  reed_bundle:{ name:'Reed Bundle', cat:'material', desc:'Bundle of desert reeds.' }
};
  const RECIPES = [
    {out:"weapon_stick", needs:[{id:"wood",qty:3},{id:"fiber",qty:2}], bench:"work"},
    {out:"net_basic", needs:[{id:"wood",qty:3},{id:"berry",qty:2}], bench:"work"},
    {out:"net_fine",  needs:[{id:"wood",qty:4},{id:"fiber",qty:4},{id:"berry",qty:2}], bench:"work"}
  ,
    {out:"boots_desert", needs:[{id:"fiber",qty:6, biome:"desert"},{id:"mushroom",qty:4}], bench:"work", requiresFlag:"q_forest_main_done"}
  ,
    {out:"pot_heal_s_plus", needs:[{id:"aloe",qty:2, biome:"desert"},{id:"reed",qty:2},{id:"herb",qty:1}], bench:"work", requiresFlag:"desert_oasis_guardian_awake"}

  ,{out:"sandstone_blade",
     title:"Sandstone Blade",
     needs:[{id:"sandstone",qty:6},{id:"reed",qty:2}],
     bench:"work",
     requiresFlag:"recipe_sandstone_blade"}
  ,{out:"boots_desert_plus",
     title:"Desert Boots +",
     needs:[{id:"boots_desert",qty:1},{id:"sandstone",qty:4},{id:"reed",qty:3}],
     bench:"work",
     requiresFlag:"recipe_boots_desert_plus"}
];
  const SHOPS = {
    meadow_village:{ items:[{id:"net_basic",price:30},{id:"pot_heal_s",price:10}] },
    forest_camp:{   items:[{id:"net_fine",price:60},{id:"pot_heal_s",price:14}]} // coin sinks
  
    , desert_fennec:{ items:[{id:'sandstone_blade', price:60},
{id:'sandstone',       qty:3,   price:24},
{id:'desert_rations',  price:12},
{id:'boots_desert',    price:80},
      {id:'aloe', qty:3, price:12},
      {id:'reed', qty:3, price:12}
    ] }};
  // Simple sell values (materials only)
  const SELL_VALUE = { wood:1, stone:2, berry:1, herb:2, reed:1, mushroom:2, fiber:2, cactus:2, sandstone:2, aloe:3 , aloe_bundle:6, reed_bundle:5, sandstone_blade:30, sandstone_key:40, boots_desert:40,
  desert_rations:6
};

  // Pals + passive perks (functional: speed, water_walk, forage_bonus, brush_break; glide is groundwork)
  const PALS = {
    // Meadow
    rabbit:{biome:"meadow", perks:{speed:+0.10, forage_bonus:0.20}},
    sparrow:{biome:"meadow", perks:{glide:"mini", speed:+0.05}},
    frog:{biome:"meadow", perks:{water_walk:true}},
    // Forest
    boar:{biome:"forest", perks:{brush_break:true}},
    stag:{biome:"forest", perks:{speed:+0.15}},
    owl:{biome:"forest",  perks:{glide:"long"}},
    squirrel:{biome:"forest", perks:{forage_bonus:0.30}},
    fox:{biome:"forest", perks:{speed:+0.10}},
    sprite:{biome:"forest", perks:{speed:0.10}},
    owllet:{biome:"forest", perks:{glide:"short"}},
    scarab:{biome:"desert", perks:{speed:+0.08}},
    vulture:{biome:"desert", perks:{glide:"mini"}},
    fennec:{biome:"desert", perks:{speed:+0.10}}
};
  // Spawns
  
// === Rarity pools + mythic/legendary helpers ===
const RARITY_POOLS = {
  MYTHIC:    ['phoenix','dragon'],
  LEGENDARY: ['gryphon'],
  RARE:      ['lynx','eagle']
};
// Extend PALS with minimal entries (safe: adds if not present)
Object.assign(PALS, {
  phoenix:{biome:"mystic",   perks:{speed:+0.25}},
  dragon:{ biome:"volcano",  perks:{speed:+0.20}},
  gryphon:{biome:"glacier",  perks:{speed:+0.18}},
  lynx:{   biome:"forest",   perks:{speed:+0.12}},
  eagle:{  biome:"glacier",  perks:{speed:+0.12, glide:"long"}}
});
function spawnPalAt(x,y,id){ pals.push({x:x, y:y, w:26,h:26, id}); }
function spawnRandomPalAt(x,y,rarity){
  const pool = RARITY_POOLS[rarity] || [];
  if (!pool.length) return;
  const id = pool[(Math.random()*pool.length)|0];
  spawnPalAt(x,y,id);
}
const SPAWNS = {
    meadow:{ pals:[{id:'rabbit',w:30},{id:'sparrow',w:22},{id:'frog',w:22},{id:'squirrel',w:14},{id:'fox',w:12}] },
    forest:{ pals:[{id:'boar',w:28},{id:'stag',w:22},{id:'owl',w:18},{id:'squirrel',w:20},{id:'fox',w:12},{id:'sprite',w:6},{id:'owllet',w:4}] },
    desert:{ pals:[{id:'scarab',w:40},{id:'vulture',w:28},{id:'fennec',w:22}] }
  };
  function pickWeighted(list){
    let sum=0; for(const it of list) sum+=it.w||1;
    let r=RNG.f()*sum;
    for(const it of list){ r-=it.w||1; if(r<=0) return it.id; }
    return list[list.length-1].id;
  }

  // ---------- Game state ----------
  const MAX_PARTY=25;
  const Game = {
    coins:0, inventory:[], companions:[{id:'rabbit', isActive:true}],
    equipped:{ tool:null, weapon:null, armor:null },
    stats:{hpMax:100,hp:100,stamMax:100,stam:100,atk:5,def:2,crit:0.05,speed:1.0,speedMult:1.0},
    quests:{}, flags:{}, unlocked:{meadow:true}, discovered:new Set(),
    settings:{seedEnabled:true,music:false,sfx:true},
    currentBiome:'meadow'
  };
// === Patch: ensure Game.buffs/stats after Game is declared ===
if (!Game.buffs) Game.buffs = {defUntil:0, speedUntil:0, partyUntil:0};
if (!Game.stats) Game.stats = {};
if (Game.stats.speedMult == null) Game.stats.speedMult = 1;


  // ---------- Entities & Portals ----------
  const player = { x:(W*TILE)/2, y:(H*TILE)/2, w:26, h:26, baseSpeed:160 };

function currentSpeed(){ return player.baseSpeed * (1 + ((Game.companions.find(p=>p.isActive && PALS?.[p.id]?.perks?.speed)||0))) * (Game.stats && Game.stats.speedMult ? Game.stats.speedMult : 1); }


  const items=[], npcs=[], pals=[];

// -- Guardian NPC ensure (non-invasive) --
function __ensureGuardianNPC(){
  // --- Desert-only guardian enforcement (added) ---
  try{
    if (typeof Game !== 'undefined' && Game && Game.currentBiome && Game.currentBiome !== 'desert'){
      // Remove any guardian/lynx variants from npcs while off-desert
      try{
        if (Array.isArray(window.npcs)){
          for (var i = npcs.length - 1; i >= 0; i--){
            var n = npcs[i];
            var t = n && (n.role || n.type || n.kind || n.id || n.name) || '';
            t = (''+t).toLowerCase();
            if (t==='guardian' || t==='guardian_lynx' || t==='sand_lynx' || t.indexOf('lynx')!==-1){
              npcs.splice(i,1);
            }
          }
        }
      }catch(_){}
      return; // skip guardian ensure while not in desert
    }
  }catch(_){}
  // --- end added desert-only block ---

  try{
    if (!Game || !Game.flags || !Game.flags.desert_oasis_guardian_awake) return;
    const T = (typeof TILE==='number') ? TILE : 32;
    // Try flags first
    let tx = Game.flags.desert_guardian_tx|0, ty = Game.flags.desert_guardian_ty|0;
    // Fallback: scan known landmark arrays
    if (!(tx||ty)){
      try{
        const cands = [];
        if (Array.isArray(Game.flags && Game.flags.desert_landmarks)) cands.push(...Game.flags.desert_landmarks);
        if (Array.isArray(Game.flags && Game.flags.DESERT_LANDMARKS)) cands.push(...Game.flags.DESERT_LANDMARKS);
        if (Game.D && Array.isArray(Game.D.DESERT_LANDMARKS)) cands.push(...Game.D.DESERT_LANDMARKS);
        if (Array.isArray(window.DESERT_LANDMARKS)) cands.push(...window.DESERT_LANDMARKS);
        const g = cands.find(o=>o && o.type==='guardian');
        if (g){ tx = (g.tx!=null?g.tx:((g.x|0)/T)|0); ty = (g.ty!=null?g.ty:((g.y|0)/T)|0); }
      }catch(_){}
    }
    if (!(tx||ty)){
      // Last resort: place at player
      try{ tx=(player.x/T)|0; ty=(player.y/T)|0; }catch(_){ tx=12; ty=12; }
    }
    const gx = (tx|0)*T, gy = (ty|0)*T;
    // ensure one guardian npc
    let idx = -1;
    for (let i=0;i<npcs.length;i++){ const n=npcs[i]; if (n && (n.role==='guardian_lynx'||n.type==='guardian')) { idx=i; break; } }
    if (idx<0){ npcs.push({x:gx,y:gy,w:26,h:26,role:'guardian_lynx',name:'Sand Lynx',facing:1,solid:false}); }
    else { npcs[idx].x=gx; npcs[idx].y=gy; }
  }catch(_){}
}
try{ setInterval(__ensureGuardianNPC, 450); }catch(_){}

  const portals=[]; // {x,y,w,h,to:'forest'|'meadow'}
// --- Deferred Actions Queue (end-of-frame mutator) ---
const DefQ = [];
function deferAction(fn){ try{ DefQ.push(fn); }catch(e){} }

// === Guardian Owl Trial: state + helpers (camp-adjacent pedestal) ===
const GuardianTrial = {
  pedestal: { x:null, y:null, w:28, h:28 }, // pixel center + box
  wisps: [],                                 // {x,y,collected,t0}
  active:false,
  timeLeft:0,
  collected:0
};

function resetGuardianTrialForBiome(){
  GuardianTrial.active = false;
  GuardianTrial.timeLeft = 0;
  GuardianTrial.collected = 0;
  GuardianTrial.wisps.length = 0;
  // Keep pedestal position decision to seeding
}

function placeGuardianPedestalNearCamp(){
  // Forest camp is around x=12..16 tiles along the trackY (≈ H*0.575). Put pedestal nearby but a little east.
  const trackY = (H*0.575)|0;
  const tx = 18, ty = trackY - 2; // near camp, slightly to the right
  GuardianTrial.pedestal.x = tx*TILE + TILE/2;
  GuardianTrial.pedestal.y = ty*TILE + TILE/2;
  GuardianTrial.pedestal.w = 28; GuardianTrial.pedestal.h = 28;
}

function startGuardianTrial(){
  GuardianTrial.active = true;
  GuardianTrial.timeLeft = 180000; // 180s (3 minutes)
  GuardianTrial.collected = 0;
  GuardianTrial.wisps.length = 0;
  // spawn 5 wisps spaced around the forest
  let guard=0;
  while(GuardianTrial.wisps.length<5 && guard++<1200){
    const tx = RNG.i(6, W-6), ty = RNG.i(6, H-6);
    if (tileIsWater && tileIsWater(tx,ty)) continue;
    const x = tx*TILE + TILE/2, y = ty*TILE + TILE/2;
    // keep away from pedestal and other wisps
    const farP = Math.hypot(x-GuardianTrial.pedestal.x, y-GuardianTrial.pedestal.y) > TILE*6;
    const farW = GuardianTrial.wisps.every(w => Math.hypot(x-w.x, y-w.y) > TILE*6);
    if (farP && farW) GuardianTrial.wisps.push({x,y,collected:false,t0:performance.now()+Math.random()*800});
  }
  toast("Find 5 wisps! (3m)");
}

function endGuardianTrial(win){
  GuardianTrial.active = false;
  GuardianTrial.wisps.length = 0;
  if (win){
    Game.flags.owl_trial_pass = true;
    // Journal: show Great Owl Trial as done
    try{ Game.quests['q_forest_guardian_owl'] = 'done'; }catch(e){}
    rebuildPortals(); ensureDesertReturnPortal();
    toast("Trial complete!");
  }else{
    toast("Trial failed");
  }
}

// === Boar miniboss combat ===
const BoarBoss = { active:false, hp:60, hpMax:60, state:'idle', t:0, vx:0, vy:0, iframe:0, contactCD:0 };
function ensureBoarBoss(){
  if (Game.currentBiome!=='forest'){ BoarBoss.active=false; return; }
  if (!Game.flags.boar_miniboss_defeated && Game.flags.boarBossActive){
    BoarBoss.active=true;
    if (BoarBoss.hp==null || BoarBoss.hp===undefined || BoarBoss.hp>BoarBoss.hpMax) BoarBoss.hp=BoarBoss.hpMax;
    // keep hp==0 when downed so player can Calm
  } else { BoarBoss.active=false; }
}
function bossCenter(){
  const i = pals.findIndex(p=>p.id==='boar' && p.boss);
  if (i===-1) return null;
  const b = pals[i]; return {i,b, x:b.x + b.w/2, y:b.y + b.h/2};
}
function distToPlayer(px,py){ return Math.hypot((player.x+player.w/2)-px, (player.y+player.h/2)-py); }

  function tileIsWater(tx,ty){ return ground[gi(tx,ty)]===4; }
  function tileIsBrush(tx,ty){ return ground[gi(tx,ty)]===BRUSH; }

// --- Ensure spawn on land for wetlands ---
function ensurePlayerOnLand(){
  try{
    const tx0 = (player.x / TILE) | 0;
    const ty0 = (player.y / TILE) | 0;
    const isBad = (tx,ty)=> (tx<1||ty<1||tx>=W-1||ty>=H-1|| tileIsWater(tx,ty) || tileIsBrush(tx,ty));
    if (!isBad(tx0,ty0)) return; // already safe
    let best = null;
    for (let r=1; r<=20 && !best; r++){
      for (let dy=-r; dy<=r && !best; dy++){
        for (let dx=-r; dx<=r; dx++){
          if (Math.max(Math.abs(dx),Math.abs(dy))!==r) continue;
          const tx = tx0 + dx, ty = ty0 + dy;
          if (tx<=1||ty<=1||tx>=W-1||ty>=H-1) continue;
          if (!tileIsWater(tx,ty) && !tileIsBrush(tx,ty)){
            best = {tx,ty};
            break;
          }
        }
      }
    }
    if (best){ player.x = best.tx*TILE; player.y = best.ty*TILE; }
  }catch(e){}
}


  function safeCampSpawn(){
    const trackY=(H*0.575)|0; // camp strip
    const candidates = [
      {tx:12, ty:trackY-2}, {tx:13, ty:trackY-2}, {tx:14, ty:trackY-2},
      {tx:12, ty:trackY-1}, {tx:13, ty:trackY-1}, {tx:14, ty:trackY-1},
      {tx:12, ty:trackY},   {tx:13, ty:trackY},   {tx:14, ty:trackY}
    ];
    for (const c of candidates){ if (c.ty>1 && c.ty<H-1 && !tileIsWater(c.tx,c.ty) && !tileIsBrush(c.tx,c.ty)) return {x:c.tx*TILE, y:c.ty*TILE}; }
    return {x: (12*TILE), y: ((trackY-2)*TILE)}; // fallback near ranger
  }


  // Biome seeding wrappers
  
  // Biome seeding wrappers
  function seedByBiome(){
    items.length=0; npcs.length=0; pals.length=0; portals.length=0; chests.length=0; particles.length=0;
    if (Game.currentBiome==='forest'){ seedForest(); }
    else if (Game.currentBiome==='desert'){ seedDesert(); }
    else if (Game.currentBiome==='wetlands'){ seedWetlands();
      ensurePlayerOnLand(); }
    else { seedMeadow(); }
    rebuildPortals(); ensureDesertReturnPortal();
    if (typeof sanitizeBiomeEntities==='function') sanitizeBiomeEntities();
  }

// === Regen: Wetlands (marsh / fen) ===

function regenWetlands(){
  try{ ground.fill(1); deco.fill(0); seen.fill(0); }catch(_){}

  // Tiles: 0=bare,1=grass,2=mud,3=brush,4=water
  const T = (typeof TILE==='number')?TILE:32;

  // 1) Start with grass baseline
  for (let y=0;y<H;y++) for (let x=0;x<W;x++) ground[gi(x,y)] = 1;

  // 2) Meandering main channel across map (sine + jitter)
  const amp = Math.max(6, (H>>3));           // vertical swing of channel
  const half = Math.max(3, (W>>5));          // half-width of channel
  const f = (Math.PI*2) / Math.max(28, W);   // meander frequency
  for (let x=0; x<W; x++){
    const cy = (H>>1) + Math.floor(Math.sin((x + (Game.seed||1)*7)*f) * amp);
    for (let y=cy - half; y<=cy + half; y++){
      if (y<0||y>=H) continue;
      ground[gi(x,y)] = 4; // water
      // feather edges irregularly
      const k = ((x*928371 + y*192837) & 7);
      if (k<2){
        if (y-1>=0) ground[gi(x,y-1)] = 4;
        if (y+1<H) ground[gi(x,y+1)] = 4;
      }
    }
  }

  // 3) Oxbow ponds sprinkled around
  const ponds = 18;
  for (let i=0;i<ponds;i++){
    const px = (i*37 + ((Game.seed||1)*53)) % W;
    const py = (i*71 + ((Game.seed||1)*19)) % H;
    const r  = 3 + ((i*(Game.seed||3)) % 4); // radius 3..6
    for (let y=py-r; y<=py+r; y++){
      for (let x=px-r; x<=px+r; x++){
        if (x<0||y<0||x>=W||y>=H) continue;
        const dx=x-px, dy=y-py, d2=dx*dx+dy*dy;
        // noisy circle
        const jitter = (((x*73856093) ^ (y*19349663)) & 1023)/1023;
        if (d2 <= r*r * (0.75 + 0.55*jitter)) ground[gi(x,y)] = 4;
      }
    }
  }

  // 4) Mud belts ringing water
  function isWater(x,y){ return x>=0&&y>=0&&x<W&&y<H && ground[gi(x,y)]===4; }
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      if (ground[gi(x,y)]!==1) continue;
      const n4 = (isWater(x+1,y)?1:0) + (isWater(x-1,y)?1:0) + (isWater(x,y+1)?1:0) + (isWater(x,y-1)?1:0);
      if (n4>0) ground[gi(x,y)] = 2; // mud edge
    }
  }

  // 5) Sparse brush on drier grass patches, avoid water
  for (let y=2;y<H-2;y++) for (let x=2;x<W-2;x++){
    if (ground[gi(x,y)]===1 && Math.random()<0.045){
      for (let yy=-1; yy<=1; yy++) for (let xx=-1; xx<=1; xx++){
        const gx=x+xx, gy=y+yy;
        if (gx>1&&gy>1&&gx<W-2&&gy<H-2 && ground[gi(gx,gy)]!==4) ground[gi(gx,gy)] = 3;
      }
    }
  }

  // 6) Lily pads: deco index 9 on calm/shallow (not too connected) water
  for (let y=2; y<H-2; y++) for (let x=2; x<W-2; x++){
    if (ground[gi(x,y)]===4){
      const n4=(ground[gi(x+1,y)]===4?1:0)+(ground[gi(x-1,y)]===4?1:0)+(ground[gi(x,y+1)]===4?1:0)+(ground[gi(x,y-1)]===4?1:0);
      if (n4<=2 && Math.random()<0.08) deco[gi(x,y)] = 9;
    }
  }
}



  // Ensure desert purity of spawns/forage after seeding
  function sanitizeBiomeEntities(){
    if (Game.currentBiome==='desert'){
      const desertPals = new Set(['scarab','vulture','fennec']);
      for (let i=0;i<pals.length;i++){
        const p = pals[i];
        if (!desertPals.has(p.id)){
          const nid = pickWeighted(SPAWNS.desert.pals);
          pals[i] = {x:p.x, y:p.y, w:p.w, h:p.h, id:nid};
        }
      }
      // convert stray meadow/forest forage to desert mats
      for (let i=0;i<items.length;i++){
        if (['wood','stone','berry','mushroom','fiber'].includes(items[i].id)){
          const roll = Math.random();
          items[i].id = roll<0.5 ? 'sandstone' : (roll<0.85 ? 'cactus' : 'aloe');
        }
      }
    }
  }

function seedMeadow(){
    const px=(player.x/TILE|0), py=(player.y/TILE|0);
    // starter drops near spawn
    [{dx:-3,dy:-1,id:'berry'},{dx:2,dy:-2,id:'stone'},{dx:-2,dy:2,id:'wood'},{dx:1,dy:1,id:'wood'}]
      .forEach(d=> items.push({x:(px+d.dx)*TILE+4, y:(py+d.dy)*TILE+4, w:24,h:24, id:d.id}));
    // forage
    for(let i=0;i<90;i++){
      const tx=RNG.i(4,W-5), ty=RNG.i(4,H-5); if(tileIsWater(tx,ty)) continue;
      const r=RNG.f(); const id = r<0.36?'berry' : r<0.72?'wood' : 'stone';
      items.push({x:tx*TILE+4, y:ty*TILE+4, w:24,h:24, id});
    }
    // pals
    const nPals=RNG.i(12,18);
    for(let i=0;i<nPals;i++){
      let tx,ty,tries=0;
      do{ tx=RNG.i(6,W-6); ty=RNG.i(6,H-6); tries++; }while(tileIsWater(tx,ty)&&tries<10);
      pals.push({x:tx*TILE, y:ty*TILE, w:26,h:26, id:pickWeighted(SPAWNS.meadow.pals)});
    }
    // Guarantee a quest-relevant sprite spawn near camp when quest is active and sprite not yet captured
    if (questState('q_forest_main')==='active' && !Game.flags.captured_sprite){
      const trackY=(H*0.575)|0;
      const sx = (15*TILE), sy = (trackY-3)*TILE;
      pals.push({x:sx, y:sy, w:24, h:24, id:'sprite'});
    }

    // NPCs
    npcs.push({x:(px+5)*TILE, y:(py+0)*TILE, w:28,h:28, name:'Elder', role:'elder'});
    npcs.push({x:(px+3)*TILE, y:(py+2)*TILE, w:28,h:28, name:'Craftsman', role:'workbench'});
    npcs.push({x:(px-5)*TILE, y:(py-1)*TILE, w:28,h:28, name:'Market', role:'market', shopId:'meadow_village'});
  }

  

  function seedDesert(){
    const px=(player.x/TILE|0), py=(player.y/TILE|0);
    // Starter desert materials near landing
    [{dx:2,dy:-1,id:'sandstone'},{dx:-1,dy:1,id:'cactus'}]
      .forEach(d=> items.push({x:(px+d.dx)*TILE+4, y:(py+d.dy)*TILE+4, w:24,h:24, id:d.id}));
    // Forage: sandstone/cactus/aloe (avoid water)
    for(let i=0;i<70;i++){
      const tx=RNG.i(4,W-5), ty=RNG.i(4,H-5); if(ground[gi(tx,ty)]===4) continue;
      const r=RNG.f(); const id = r<0.50?'sandstone' : r<0.85?'cactus' : 'aloe';
      items.push({x:tx*TILE+4, y:ty*TILE+4, w:24,h:24, id});
    }
    
    // Water-edge resources: reeds (banks) and herbs (fringe)
    try{
      const isWater=(tx,ty)=>ground[gi(tx,ty)]===4;
      // reeds on bank
      let placedR=0;
      for(let i=0;i<200;i++){
        const tx=RNG.i(3,W-4), ty=RNG.i(3,H-4);
        if (isWater(tx,ty)) continue;
        const touch = isWater(tx+1,ty)||isWater(tx-1,ty)||isWater(tx,ty+1)||isWater(tx,ty-1);
        if (touch && Math.random()<0.6){
          items.push({x:tx*TILE+4, y:ty*TILE+4, w:24,h:24, id:'reed'}); placedR++;
        }
      }
      if (placedR<8){ // guarantee
        for(let i=0;i<8-placedR;i++){
          const tx=RNG.i(3,W-4), ty=RNG.i(3,H-4);
          if (!isWater(tx,ty) && (isWater(tx+1,ty)||isWater(tx-1,ty)||isWater(tx,ty+1)||isWater(tx,ty-1))){
            items.push({x:tx*TILE+4, y:ty*TILE+4, w:24,h:24, id:'reed'});
          }
        }
      }
      // herbs near water within radius 3
      let placedH=0;
      for(let i=0;i<160;i++){
        const tx=RNG.i(3,W-4), ty=RNG.i(3,H-4);
        if (isWater(tx,ty)) continue;
        let near=false;
        for(let dy=-3;dy<=3 && !near;dy++) for(let dx=-3;dx<=3 && !near;dx++){
          const nx=tx+dx, ny=ty+dy; if(nx<1||ny<1||nx>=W-1||ny>=H-1) continue;
          if (isWater(nx,ny)) near=true;
        }
        if (near && Math.random()<0.4){
          items.push({x:tx*TILE+4, y:ty*TILE+4, w:24,h:24, id:'herb'}); placedH++;
        }
      }
      if (placedH<5){
        for(let i=0;i<5;i++){
          const tx=RNG.i(3,W-4), ty=RNG.i(3,H-4);
          if (!isWater(tx,ty) && (isWater(tx+2,ty)||isWater(tx-2,ty)||isWater(tx,ty+2)||isWater(tx,ty-2))){
            items.push({x:tx*TILE+4, y:ty*TILE+4, w:24,h:24, id:'herb'});
          }
        }
      }
    }catch(_){}

    // Pals: desert table
    const nPals = RNG.i(12,18);
    for(let i=0;i<nPals;i++){
      let tx,ty,tries=0;
      do{ tx=RNG.i(6,W-6); ty=RNG.i(6,H-6); tries++; }while(ground[gi(tx,ty)]===4 && tries<12);
      pals.push({x:tx*TILE, y:ty*TILE, w:26,h:26, id:pickWeighted(SPAWNS.desert.pals)});
    }
    // NPC: Caravaneer market near landing
    // (removed caravaneer near spawn)

  // Desert quick-fix: seed landmarks if needed
  try{ DESERT.seedLandmarks(); }catch(_){}

  // === Stage 6: Desert camp NPCs (visual-only) ===
  try{
    if (!Game.flags) Game.flags = {};
    if (!Game.flags.desert_npcs_added){
      const trackY = (H*0.40)|0;
      const T = (typeof TILE!=='undefined'?TILE:32);
      // Helper to push NPC safely
      function _pushNPC(tx, ty, role, name, shopId){
        try{
          npcs.push({ x: tx*T, y: ty*T, w: 26, h: 26, role, name, shopId });
        }catch(_){}
      }
      // Place the four camp roles near a central strip
      _pushNPC(16, trackY-2, 'nomad_chief', 'Nomad Chief', null);
      _pushNPC(12, trackY-2, 'market', 'Fennec Trader', 'desert_caravan');  // shopId unused for now
      _pushNPC(14, trackY-1, 'workbench', 'Scarab Artisan', null);
      _pushNPC(18, trackY-2, 'scout', 'Vulture Scout', null);

      Game.flags.desert_npcs_added = true;
    }
  }catch(_){}


  /* Stage 8c spread_v2: reposition posts (safe, inline) */
  try{
    if (Game && Game.flags && Array.isArray(Game.flags.desert_landmarks)){
      var arr = Game.flags.desert_landmarks;
      // Find first three scout posts
      var posts = [];
      for (var i=0;i<arr.length;i++){ if (arr[i] && arr[i].type==='scout') posts.push(arr[i]); if (posts.length===3) break; }
      if (posts.length===3){
        var W2 = (typeof W!=='undefined'?W:128), H2=(typeof H!=='undefined'?H:128);
        function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
        function isWater(tx,ty){ try{ return ground[ty*W2+tx]===4; }catch(_){ return false; } }
        function nudge(tx,ty){
          tx = clamp(tx, 6, W2-7); ty = clamp(ty, 6, H2-7);
          if (!isWater(tx,ty)) return {tx:tx,ty:ty};
          for (var r=1;r<=10;r++){
            for (var dx=-r;dx<=r;dx++){
              for (var dy=-r;dy<=r;dy++){
                var nx=clamp(tx+dx,6,W2-7), ny=clamp(ty+dy,6,H2-7);
                if (!isWater(nx,ny)) return {tx:nx,ty:ny};
              }
            }
          }
          return {tx:tx,ty:ty};
        }
        var T1=nudge(Math.floor(W2*0.20), Math.floor(H2*0.22));
        var T2=nudge(Math.floor(W2*0.82), Math.floor(H2*0.48));
        var T3=nudge(Math.floor(W2*0.50), Math.floor(H2*0.82));
        posts[0].tx=T1.tx; posts[0].ty=T1.ty;
        posts[1].tx=T2.tx; posts[1].ty=T2.ty;
        posts[2].tx=T3.tx; posts[2].ty=T3.ty;
      }
    }
  }catch(_){}


  // ensure oasis mats exist
  oasisSpawn();
}




function seedForest(){
  // --- Reset any per-biome local caches if needed (global arrays cleared by seedByBiome) ---

  // 1) Scatter forage items (avoid water; fiber more likely near brush)
  for(let i=0;i<110;i++){
    let tx=RNG.i(4,W-5), ty=RNG.i(4,H-5);
    if (tileIsWater(tx,ty)) continue;
    let id='wood';
    const nearBrush = (tileIsBrush(tx,ty) || [ [1,0],[-1,0],[0,1],[0,-1] ].some(d=>tileIsBrush(tx+d[0],ty+d[1])));
    const r=RNG.f();
    if (nearBrush && r<0.50) id='fiber';
    else if (r<0.25) id='wood';
    else if (r<0.55) id='berry';
    else if (r<0.80) id='mushroom';
    else id='stone';
    items.push({x:tx*TILE+4, y:ty*TILE+4, w:24, h:24, id});
  
  
}
  // Guardian pedestal near camp (visible until BOTH trial+errand complete)
  if (!Game.flags.owl_trial_pass || !Game.flags.q_forest_main_done){ placeGuardianPedestalNearCamp(); } else { GuardianTrial.pedestal.x=null; GuardianTrial.pedestal.y=null; }

  // 2) Place camp NPCs near the track
  const trackY=(H*0.575)|0;
  npcs.push({x:(12*TILE), y:(trackY-2)*TILE, w:26,h:26, name:'Ranger', role:'ranger'});
  npcs.push({x:(16*TILE), y:(trackY-2)*TILE, w:26,h:26, name:'Trader', role:'market', shopId:'forest_camp'});

  // 3) Forest pals — guarantee at least two of each species (sprite handled below)
  (function(){
    const table = (SPAWNS && SPAWNS.forest && SPAWNS.forest.pals) ? SPAWNS.forest.pals : [{id:'rabbit',w:1}];
    function drop(id){
      let tries=0, tx,ty;
      do{ tx=RNG.i(6,W-6); ty=RNG.i(6,H-6); tries++; }while(tileIsWater(tx,ty) && tries<24);
      pals.push({x:tx*TILE, y:ty*TILE, w:26, h:26, id});
    }
    // 3a) Ensure two of each (exclude 'sprite' so it stays special)
    const baseIds = table.map(t=>t.id).filter(id=>id!=='sprite');
    for (const id of baseIds){ drop(id); drop(id); }

    // 3b) Fill remainder with weighted picks for variety
    const minTotal = RNG.i(18,26);
    const toAdd = Math.max(0, minTotal - pals.length);
    for (let i=0;i<toAdd;i++){ drop(pickWeighted(table)); }
  })();

  // 4) Randomized special spawns (boss boar + sprite)
  function randSpot(){
    let tries=0;
    while(tries++<40){
      const tx = RNG.i(4, W-4), ty = RNG.i(4, H-4);
      if (tileIsWater(tx,ty)) continue;
      return { x: tx*TILE + ((TILE-24)>>1), y: ty*TILE + ((TILE-24)>>1) };
    }
    // fallback center-ish
    return { x:(W*TILE>>1), y:(H*TILE>>1) };
  }

  // Boar mini-boss: present until defeated (single instance)
  if (!Game.flags.boar_miniboss_defeated){
    const exists = pals.some(p=>p.id==='boar' && p.boss);
    if (!exists){
      const p = randSpot();
      pals.push({x:p.x, y:p.y, w:28, h:28, id:'boar', boss:true});
      Game.flags.boarBossActive = true;
    }
  } else {
    Game.flags.boarBossActive = false;
  }

  // Sprite: present until captured (single instance)
  if (!Game.flags.captured_sprite){
    const existsS = pals.some(p=>p.id==='sprite');
    if (!existsS){
      const q = randSpot();
      pals.push({x:q.x, y:q.y, w:24, h:24, id:'sprite'});
    }
  }

  // 5) Guards: ensure single instances after all spawns
  {
    let bossFound = false;
    for (let i=pals.length-1;i>=0;i--){
      const p = pals[i];
      if (p.id==='boar' && p.boss){
        if (bossFound) { pals.splice(i,1); } else bossFound = true;
      }
    }
  }
  {
    let spriteFound = false;
    for (let i=pals.length-1;i>=0;i--){
      const p = pals[i];
      if (p.id==='sprite'){
        if (spriteFound) { pals.splice(i,1); } else spriteFound = true;
      }
    }
  }
}

// === Seed: Wetlands (flora + ambience) ===
function seedWetlands(){
  const T = (typeof TILE==='number')?TILE:32;
  const isWater = (tx,ty)=> ground[gi(tx,ty)]===4;

  // Shoreline reeds/herbs
  for (let y=2;y<H-2;y++) for (let x=2;x<W-2;x++){
    if (!isWater(x,y)){
      const n4=(isWater(x+1,y)?1:0)+(isWater(x-1,y)?1:0)+(isWater(x,y+1)?1:0)+(isWater(x,y-1)?1:0);
      if (n4>0){
        const r=RNG.f();
        if (r<0.22) items.push({id:'reed', x:x*T+(T>>1), y:y*T+(T>>1), w:20, h:20});
        else if (r<0.32) items.push({id:'herb', x:x*T+(T>>1), y:y*T+(T>>1), w:20, h:20});
      } else if (RNG.f()<0.012){
        items.push({id:'mushroom', x:x*T+(T>>1), y:y*T+(T>>1), w:18, h:14});
      }
    }
  }

  // Friendly frog pal to telegraph biome life
  try{ pals.push({id:'frog', x:(W*0.5|0)*T, y:(H*0.58|0)*T, w:24, h:24, wander:1}); }catch(_){}

  // Fireflies ambience
  for (let i=0;i<36;i++){
    particles.push({x:RNG.i(0,W*T), y:RNG.i(0,H*T), vx:(RNG.f()-0.5)*0.2, vy:(RNG.f()-0.5)*0.15, life:180+RNG.i(0,180), c:'#a6ff8a'});
  }

  // --- Wetlands camp NPCs (quest + vendor + bench + scout) ---
  try{
    const T = (typeof TILE==='number')?TILE:32;
    const camp = (typeof safeCampSpawn==='function') ? safeCampSpawn() : {x:(12*T), y:(((H*0.575)|0)-2)*T};
    const cx = camp.x|0, cy = (camp.y|0) - 18*T;
    npcs.push({ x: cx + 0*T,  y: cy + 0*T,  w:26, h:26, role:'bog_hermit',  name:'Bog Hermit' });
    npcs.push({ x: cx - 2*T, y: cy + 0*T,  w:26, h:26, role:'market',      name:'Mud Trader',   shopId:'wetlands_outfitter' });
    npcs.push({ x: cx + 2*T, y: cy + 0*T,  w:26, h:26, role:'workbench',   name:'Reed Artisan' });
    npcs.push({ x: cx + 4*T, y: cy - 1*T,  w:26, h:26, role:'scout',       name:'Heron Scout' });
  }catch(_){}
}



  

// ---- Portal placement helper: find a shoreline tile near the oasis water mass ----
function findOasisPortalSpot(){
  try{
    if (typeof W!=='number' || typeof H!=='number' || !ground) return null;
    var WATER = 4; // water tile id in Desert (matches map gen)
    var pts = [];
    for (var y=2;y<H-2;y++){
      for (var x=2;x<W-2;x++){
        if (ground[y*W + x] === WATER) pts.push([x,y]);
      }
    }
    if (!pts.length) return null;

    // centroid of water mass (sample to keep it fast)
    var sx=0, sy=0, step=Math.max(1, Math.floor(pts.length/800));
    for (var i=0;i<pts.length;i+=step){ sx+=pts[i][0]; sy+=pts[i][1]; }
    var n=Math.ceil(pts.length/step), cx=Math.round(sx/n), cy=Math.round(sy/n);

    function isWater(x,y){ return ground[y*W + x] === WATER; }
    function inb(x,y){ return x>1 && y>1 && x<W-2 && y<H-2; }

    // search outward for shoreline land tile (has at least one water neighbor)
    for (var r=0; r<=18; r++){
      for (var dy=-r; dy<=r; dy++){
        for (var dx=-r; dx<=r; dx++){
          if (Math.abs(dx)!=r && Math.abs(dy)!=r) continue;
          var xx=cx+dx, yy=cy+dy;
          if (!inb(xx,yy)) continue;
          if (!isWater(xx,yy)){
            var n4=(isWater(xx+1,yy)?1:0)+(isWater(xx-1,yy)?1:0)+(isWater(xx,yy+1)?1:0)+(isWater(xx,yy-1)?1:0);
            if (n4>0) return {x:xx, y:yy};
          }
        }
      }
    }
    // fallback: nearest land on cardinal rays
    for (var r2=1; r2<=24; r2++){
      var cand=[[cx+r2,cy],[cx-r2,cy],[cx,cy+r2],[cx,cy-r2]];
      for (var k=0;k<cand.length;k++){
        var xx2=cand[k][0], yy2=cand[k][1];
        if (inb(xx2,yy2) && !isWater(xx2,yy2)) return {x:xx2, y:yy2};
      }
    }
  }catch(_){}
  return null;
}

function rebuildPortals(){
    portals.length=0;
    const trackY=(H*0.575)|0;
    if (Game.currentBiome==='meadow'){
      if (Game.flags.bridgeFixed){
        portals.push({x:(W-10)*TILE, y:trackY*TILE, w:28, h:28, to:'forest'});
      }
    } else if (Game.currentBiome==='forest'){
      portals.push({x:10*TILE, y:trackY*TILE, w:28, h:28, to:'meadow'});
      if ((Game.flags.owl_trial_pass||Game.flags.owl_trial_passed) && Game.flags.q_forest_main_done){
        portals.push({x:(W-10)*TILE, y:trackY*TILE, w:28, h:28, to:'desert'});
        Game.unlocked.desert = true;
      }
    } else if (Game.currentBiome==='desert'){
      const ptx=(player.x/TILE|0), py = trackY;
      let px = Math.max(3, Math.min(W-4, ptx-3));
      if (ground[gi(px,py)]===4){ if (px < W-5) px += 2; else px -= 2; }
      portals.push({x:(W-12)*TILE, y:trackY*TILE, w:32, h:32, to:'forest'});
      // Wetlands portal (appears after relic feather is given to the guardian) — LEFT edge
      if ((Game.flags && Game.flags.desert_guardian_portal_ready) || (Game.unlocked && Game.unlocked.wetlands)){
        portals.push({x:10*TILE, y:trackY*TILE, w:32, h:32, to:'wetlands'});
      }
// carve a clear 3x3 corridor around the portal
      for(let yy=-1; yy<=1; yy++) for(let xx=-1; xx<=1; xx++){
        const gx=px+xx, gy=py+yy;
        if (gx>1&&gy>1&&gx<W-2&&gy<H-2){
          deco[gi(gx,gy)]=0;
          if (ground[gi(gx,gy)]===BRUSH) ground[gi(gx,gy)]=0;
        }
      }
    }
  
    else if (Game.currentBiome==='wetlands'){
      const trackY=(H*0.575)|0;
      portals.push({x:10*TILE, y:trackY*TILE, w:28, h:28, to:'desert'});
    }
  }

  
  function ensureDesertReturnPortal(){
    if (Game.currentBiome!=='desert') return;
    // If a portal to forest already exists, keep it.
    if (portals.some(p => p.to==='forest')) return;

    // Place the portal NEAR THE PLAYER'S LANDING SPOT in the desert.
    const trackY=(H*0.575)|0;
    const ptx = (player.x / TILE) | 0;
    const pty = (player.y / TILE) | 0;

    // Try to put it a few tiles to the LEFT of the spawn so it's immediately visible.
    let px = ptx - 3;
    let py = trackY;

    // Clamp to safe bounds
    if (px < 3) px = 3;
    if (px > W-4) px = W-4;
    // Avoid placing on water; if water, nudge right.
    if (ground[gi(px,py)]===4) { if (px < W-5) px += 2; else px -= 2; }

    portals.push({x:px*TILE, y:py*TILE, w:32, h:32, to:'forest'});

    // Carve a 3x3 clear corridor around the portal for smooth access
    for(let yy=-1; yy<=1; yy++) for(let xx=-1; xx<=1; xx++){
      const gx=px+xx, gy=py+yy;
      if (gx>1&&gy>1&&gx<W-2&&gy<H-2){
        deco[gi(gx,gy)]=0;
        if (ground[gi(gx,gy)]===BRUSH) ground[gi(gx,gy)]=0;
      }
    }
  }


  // ---------- Quests ----------
  const QUESTS = {
    q_meadow_main:{
      name:"Bridge to the Forest", giver:"elder",
      objectives:[ {type:"collect",id:"wood",qty:5}, {type:"collect",id:"stone",qty:5}, {type:"craft",id:"net_basic",qty:1}, {type:"capture_any",qty:1} ]
    },
    q_forest_main:{
      name:"Errand of the Woods", giver:"ranger",
      objectives:[
        {type:"collect",id:"wood",qty:10},
        {type:"collect",id:"berry",qty:10},
        {type:"defeat",id:"boar_miniboss"},
        {type:"capture",id:"sprite",qty:1}
      ],
      reward:{coins:25, grantItem:"axe_basic", flag:"q_forest_main_done"}
    },
    q_forest_guardian_owl:{
      name:"Great Owl Trial", giver:"owl_guardian",
      objectives:[ {type:"solve",id:"owl_riddle",qty:2, of:3}, {type:"capture",id:"owllet",qty:1} ],
      reward:{item:"relic_feather", unlock:"desert", flag:"owl_trial_pass"}
    }

    , q_desert_main:{
      name:"Circuit of the Dunes", giver:"nomad_chief",
      objectives:[
        {type:"posts_active", qty:3},                // activate 3 scout posts
        {type:"shrine_count", qty:3},                // complete Wind, Sun, Sand
        {type:"flag", id:"desert_vault_opened"},     // open the Sand Vault
        {type:"flag", id:"desert_guardian_portal_ready"} // present Relic Feather to the Guardian
      ],
      reward:{coins:40, flag:"q_desert_main_done"}
    }
};
function questState(id){ return Game.quests[id]||"locked"; }
  function beginQuest(id){ if(questState(id)==="locked"){ Game.quests[id]="active"; toast("Quest started: "+QUESTS[id].name); } }
  function questProgress(id){
  const q = QUESTS[id]; if (!q) return null;
  const prog = [];
  for (const o of q.objectives){
    if (o.type === "collect"){
      const have = (Game.inventory.find(s=>s.id===o.id)?.qty) || 0;
      prog.push({ label: `${o.id} ${Math.min(have,o.qty)}/${o.qty}`, done: have >= o.qty });
    } else if (o.type === "craft"){
      const have = (Game.inventory.find(s=>s.id===o.id)?.qty) || 0;
      const need = o.qty || 1;
      prog.push({ label: `craft ${o.id} ${Math.min(have,need)}/${need}`, done: have >= need });
    } else if (o.type === "capture_any"){
      const need = o.qty || 1;
      // count current companions as captures; clamp to need
      const have = Math.max(0, Game.companions ? Game.companions.length : 0);
      prog.push({ label: `capture any ${Math.min(have,need)}/${need}`, done: have >= need });
    } else if (o.type === "posts_active" || o.type === "scout") {
  // Prefer the existing counter if present; otherwise fall back to a safe scout counter
  const have = (typeof _postsActive === 'function')
    ? _postsActive()
    : (function countScoutsActivated(){
        try {
          const arr = (Game.flags && Array.isArray(Game.flags.desert_landmarks))
            ? Game.flags.desert_landmarks : [];
          let c = 0;
          for (let i = 0; i < arr.length; i++) {
            const L = arr[i];
            if (L && L.type === 'scout' && L.activated) c++;
          }
          return c;
        } catch (_){ return 0; }
      })();

  const need = o.qty || 3;
  prog.push({
    label: `activate scout posts ${Math.min(have, need)}/${need}`,
    done: have >= need
  });
    } else if (o.type === "shrine_count"){
      let n = 0;
      try{
        n += Game.flags.desert_shrine_wind_done?1:0;
        n += Game.flags.desert_shrine_sun_done?1:0;
        n += Game.flags.desert_shrine_sand_done?1:0;
      }catch(_){}
      const need = o.qty || 3;
      prog.push({ label: `complete shrines ${Math.min(n,need)}/${need}`, done: n >= need });
    } else if (o.type === "flag"){
      const ok = !!Game.flags[o.id];
      prog.push({ label: `${(o.id||'flag').replace(/_/g,' ')} ${ok?1:0}/1`, done: ok });
    } else if (o.type === "capture"){
      const have = Game.companions && Game.companions.some(p=>p.id===o.id) ? 1 : 0;
      const need = o.qty || 1;
      prog.push({ label: `capture ${o.id} ${Math.min(have,need)}/${need}`, done: have >= need });
    } else if (o.type === "defeat"){
      const doneFlag = !!Game.flags[o.id + "_defeated"];
      prog.push({ label: `defeat ${o.id}`, done: doneFlag });
    } else if (o.type === "solve"){
      const n = Game.flags.owl_riddle_count || 0;
      const need = o.qty || 2;
      prog.push({ label: `solve riddles ${Math.min(n,need)}/${need}`, done: n >= need });
    }
  }
  const done = prog.every(p => p.done);
  return { prog, done }
// === Helper: buildQuestProgress() -> choose active biome quest ===
function buildQuestProgress(){
  try{
    const qid = (Game.currentBiome==='forest') ? 'q_forest_main'
              : (Game.currentBiome==='meadow') ? 'q_meadow_main'
              : (Game.currentBiome==='desert') ? 'q_desert_main'
              : null;
    if (!qid || questState(qid)==="locked") return { prog: [], done: false };
    return questProgress(qid) || { prog: [], done: false };
  }catch(_){ return { prog: [], done: false }; }
}
try{ if (typeof window!=='undefined') window.buildQuestProgress = window.buildQuestProgress || buildQuestProgress; }catch(_){}

;
}
  function tryTurnIn(id){
    const pr=questProgress(id); if(!pr || !pr.done) return toast("Not ready yet");
    Game.quests[id]="done";
    if (id==='q_meadow_main'){
      Game.coins+=20; Game.unlocked.forest=true; Game.flags.bridgeFixed=true;
      toast("Quest complete! +20c, Forest unlocked"); rebuildPortals(); ensureDesertReturnPortal();
    } else if (id==='q_forest_main'){
      Game.coins+=25; addItem('axe_basic',1); Game.flags.q_forest_main_done=true;
      toast("Errand complete! +25c +axe"); rebuildPortals(); ensureDesertReturnPortal();
    } else if (id==='q_forest_guardian_owl'){
  addItem('relic_feather',1);
  Game.flags.owl_trial_pass=true;
  if ((Game.flags.owl_trial_pass||Game.flags.owl_trial_passed) && Game.flags.q_forest_main_done===true) { Game.unlocked.desert=true; toast("Great Owl Trial complete! Desert unlocked"); }
  else { toast("Great Owl Trial complete!"); }
  rebuildPortals(); ensureDesertReturnPortal();
}
  }

  // ---------- Inventory / Crafting ----------
  function findStack(id){ return Game.inventory.find(s=>s.id===id); }
  function addItem(id, qty=1){
    if(!ITEMS[id]) return false;
    const s=findStack(id); if(s) s.qty+=qty; else Game.inventory.push({id,qty});
    Game.discovered.add(id); return true;
  }
  function hasItems(needs){ return needs.every(n=>(findStack(n.id)?.qty||0) >= n.qty); }
  function spendItems(needs){ for(const n of needs){ const s=findStack(n.id); s.qty-=n.qty; } Game.inventory = Game.inventory.filter(s=>s.qty>0); }
  function craft(id){ const rec=RECIPES.find(r=>r.out===id); if(!rec) return toast("Recipe missing"); if(!hasItems(rec.needs)) return toast("Need mats"); spendItems(rec.needs); addItem(rec.out,1); toast("Crafted "+rec.out); }

  

  function dropPalAt(index){
    if (!Array.isArray(Game.companions) || Game.companions.length<=1) return toast('Cannot drop last pal');
    const i = Math.max(0, Math.min(Game.companions.length-1, index|0));
    const dropped = Game.companions[i];
    // If dropping the active pal, make next one active
    const wasActive = !!dropped.isActive;
    Game.companions.splice(i,1);
    if (wasActive){
      if (Game.companions.length){
        Game.companions[0].isActive = true;
      }
    }
    // Clamp journal cursor
    if (JournalUI.idx >= Game.companions.length) JournalUI.idx = Math.max(0, Game.companions.length-1);
    toast('Dropped '+(dropped?.id||'pal'));
  }

// ---------- Shop (buy/sell) ----------
  function slotForItemId(id){
    const it = ITEMS[id]; if(!it) return null;
    if (it.cat==='tool') return 'tool';
    if (it.cat==='armor') return 'armor';
    if (it.cat==='weapon') return 'weapon';
    return null;
  }
  function equippedId(slot){ const e=Game.equipped?.[slot]; return e? e.id : null; }
  function canEquip(id){ return !!slotForItemId(id); }
  function isEquipped(id){ const s=slotForItemId(id); return s && equippedId(s)===id; }
  function equipFromInventory(idx){
    const s = Game.inventory[idx]; if(!s) return toast('No item');
    const id = s.id; const slot = slotForItemId(id); if (!slot) return toast('Cannot equip');
    const cur = Game.equipped[slot];
    // Toggle off if same item equipped
    if (cur && cur.id===id){
      if (ITEMS[id]?.chargesMax && cur.usesLeft && cur.usesLeft < (ITEMS[id].chargesMax||0)) return toast('Cannot unequip (partially used)');
      Game.equipped[slot] = null;
      const exist=findStack(id); if (exist) exist.qty+=1; else Game.inventory.push({id,qty:1});
      toast('Unequipped '+id);
      return;
    }
    // If another item in slot, unequip it first (unless partially used tool)
    if (cur){
      if (ITEMS[cur.id]?.chargesMax && cur.usesLeft && cur.usesLeft < (ITEMS[cur.id].chargesMax||0)) return toast('Cannot unequip current '+cur.id+' (partially used)');
      const back=findStack(cur.id); if (back) back.qty+=1; else Game.inventory.push({id:cur.id, qty:1});
      Game.equipped[slot]=null;
    }
    // Equip: consume one from inventory and instantiate charges if applicable
    if (!s.qty || s.qty<=0) return toast('Out of '+id);
    s.qty-=1; if (s.qty<=0) Game.inventory = Game.inventory.filter(x=>x.qty>0);
    const inst = { id };
    if (ITEMS[id]?.chargesMax) inst.usesLeft = ITEMS[id].chargesMax, inst.usesMax = ITEMS[id].chargesMax;
    Game.equipped[slot] = inst;
    toast('Equipped '+id);
  }

  const ShopUI = { open:false, idx:0, shopId:null, mode:'buy' }; // mode: 'buy' | 'sell'
  function openShop(shopId){ ShopUI.open=true; ShopUI.idx=0; ShopUI.shopId=shopId; ShopUI.mode='buy'; toast('Market open'); }
  function closeShop(){ ShopUI.open=false; }
  function shopItems(){
    if (ShopUI.mode==='buy'){
      const shop=SHOPS[ShopUI.shopId]; return shop? shop.items : [];
    } else {
      return Game.inventory.filter(s=> SELL_VALUE[s.id]>0).map(s=>({id:s.id, qty:s.qty, price:SELL_VALUE[s.id]}));
    }
  }
  function buySelected(){
    if (ShopUI.mode!=='buy') return;
    const shop=SHOPS[ShopUI.shopId]; if(!shop) return;
    const it=shop.items[ShopUI.idx]; if(!it) return;
    if(Game.coins < it.price) return toast('Not enough coins');
    Game.coins -= it.price; addItem(it.id,(it.qty||1)); if (Game.discovered) Game.discovered.add(it.id); toast('Bought '+it.id);
  }
  function sellSelected(){
    if (ShopUI.mode!=='sell') return;
    const list = shopItems(); const it=list[ShopUI.idx]; if(!it) return;
    const price = SELL_VALUE[it.id]||0; if (!price) return toast('Cannot sell');
    const s=findStack(it.id); if(!s) return; s.qty-=1; if(s.qty<=0){ Game.inventory = Game.inventory.filter(x=>x.qty>0); }
    Game.coins += price; toast('Sold '+it.id+' +'+price+'c');
  }

  // ---------- Save / Load / World reset ----------
  const SAVE_KEY='wildpals_slot1';
  function saveGame(){
    try{
      const GameSave={...Game, discovered:Array.from(Game.discovered)};
      localStorage.setItem(SAVE_KEY, JSON.stringify({
        Game:GameSave, player, items, npcs, pals, portals, chests,
        ground:Array.from(ground), deco:Array.from(deco), seen:Array.from(seen)
      }));
      toast('Saved (Slot 1)');
    }catch(e){ toast('Save failed'); }
  }
  function loadGame(){
    try{
      const raw=localStorage.getItem(SAVE_KEY); if(!raw) return toast('No save in Slot 1');
      const d=JSON.parse(raw);
      Object.assign(Game, d.Game||{}); Game.discovered=new Set((d.Game?.discovered)||[]);
      Object.assign(player, d.player||{});
      items.length=0; npcs.length=0; pals.length=0; portals.length=0; chests.length=0; particles.length=0;
      items.push(...(d.items||[])); npcs.push(...(d.npcs||[])); pals.push(...(d.pals||[])); portals.push(...(d.portals||[]));
      if(Array.isArray(d.ground) && d.ground.length===ground.length) ground.set(d.ground); // includes BRUSH
      if(Array.isArray(d.deco)   && d.deco.length===deco.length)     deco.set(d.deco);
      if(Array.isArray(d.seen)   && d.seen.length===seen.length)     seen.set(d.seen);
      toast('Loaded (Slot 1)');
    }catch(e){ toast('Load failed'); }
  }
  function resetPartyToStarter(){ Game.companions=[{id:'rabbit', isActive:true}]; }
  function newWorld(){
    try{
      if (Game.settings.seedEnabled) RNG.reseed(0xC0FFEE); else RNG.reseed((Math.random()*0xFFFFFFFF)>>>0);
      Game.currentBiome='meadow';
      regenMeadow();
      Game.coins=0; Game.inventory.length=0; Game.quests={}; Game.flags={}; Game.unlocked={meadow:true};
      Game.discovered = new Set();
      resetPartyToStarter();
      player.x=(W*TILE)/2; player.y=(H*TILE)/2;
      seedByBiome();
      toast('New world created');
    }catch(e){ toast('New world failed'); console.error(e); }
  }

  // ---------- Cheats ----------
  function applyCheat(code){
  if(!code){
    // If called without code (e.g., from Start menu), open Quick Panel to Cheats tab
    if (typeof UI!=='undefined'){ UI.quick = true; }
    if (typeof quickTab!=='undefined'){ quickTab = QUICK_TABS.indexOf('Cheats') >= 0 ? QUICK_TABS.indexOf('Cheats') : quickTab; }
    toast('Open Quick Panel → Cheats');
    return;
  }
  switch(code){
    case 'CHESTHERE': chests.push({x:(player.x|0), y:(player.y|0), w:(TILE-12), h:(TILE-12), opened:false}); break;
    case 'CHESTME': { const cx=(player.x|0)+(player.w>>1), cy=(player.y|0)+(player.h>>1); const ax=cx+TILE*lastDir.x, ay=cy+TILE*lastDir.y; chests.push({x:(ax-((TILE-12)>>1))|0, y:(ay-((TILE-12)>>1))|0, w:(TILE-12), h:(TILE-12), opened:false}); } break;
    case 'RICHIE': Game.coins = (Game.coins||0)+1000; break;
    case 'MONEYRAIN': Game.coins = (Game.coins||0)+5000; break;
    case 'BUFFME': if (Game.buffs) Game.buffs.defUntil=Date.now()+60000; break;
    case 'ULTRASPEED':
      if (Game.buffs) Game.buffs.speedUntil=Date.now()+20000;
      if (Game.stats) Game.stats.speedMult=2.5;
      break;
    case 'PARTYTIME': if (Game.buffs) Game.buffs.partyUntil=Date.now()+20000; break;
    case 'FORESTOPEN': if (Game.unlocked) Game.unlocked.forest=true; toast('Forest unlocked'); break;
    case 'DESERTOPEN': if (Game.unlocked) Game.unlocked.desert=true; toast('Desert unlocked'); break;
    case 'WETLANDSOPEN': if (Game.unlocked) Game.unlocked.wetlands=true; toast('Wetlands unlocked'); break;
    case 'VOLCANOOPEN': if (Game.unlocked) Game.unlocked.volcano=true; toast('Volcano unlocked'); break;
    case 'GLACIEROPEN': if (Game.unlocked) Game.unlocked.glacier=true; toast('Glacier unlocked'); break;
    case 'MYSTICOPEN': if (Game.unlocked) Game.unlocked.mystic=true; toast('Mystic unlocked'); break;
    case 'SKYREALMOPEN': if (Game.unlocked) Game.unlocked.skyrealm=true; toast('Sky Realm unlocked'); break;
    case 'UNDERSEAOPEN': if (Game.unlocked) Game.unlocked.undersea=true; toast('Undersea unlocked'); break;
    case 'MYTHIC': /* stub: spawn mythic pal */ break;
    case 'LEGENDARY': /* stub: spawn legendary pal */ break;
    case 'RARE': /* stub: spawn rare pal */ break;
    case 'ALLOPEN':
      if (Game.unlocked){
        Object.assign(Game.unlocked, {meadow:true,forest:true,desert:true,wetlands:true});
        toast('All main biomes unlocked');
      }
       rebuildPortals(); ensureDesertReturnPortal(); toast('Portals updated'); break;
    case 'SECRETSOPEN':
      if (Game.unlocked){
        Object.assign(Game.unlocked, {volcano:true,glacier:true,mystic:true,skyrealm:true,undersea:true});
        toast('All secret biomes unlocked');
      }
       rebuildPortals(); ensureDesertReturnPortal(); toast('Portals updated'); break;
  }
  if (typeof CheatsHistory!=='undefined'){
    CheatsHistory.unshift(code);
    if (CheatsHistory.length>20) CheatsHistory.length=20;
  }
  toast('Cheat: '+code);
}
    // ---------- UI Panels ----------
  const UI = { start:false, quick:false, startIdx:0 };
const JournalUI = { idx: 0 };
  const START_ITEMS = ['Resume','Save (Slot 1)','Load (Slot 1)','New World','Settings','Cheats','Close'];
  const QUICK_TABS=['Inventory','Crafting','Journal','Minimap', 'Cheats']; let quickTab=0, craftIdx=0;
let invIdx=0;

  // Journal stats + perks list
  function journalStats(){
    return {
      biome:Game.currentBiome, coins:Game.coins, stacks:Game.inventory.length,
      palsOwned:Game.companions.length, discoveredItems:Game.discovered.size,
      qMain: (Game.currentBiome==='forest')? questState('q_forest_main') : questState('q_meadow_main'),
      qGuardian: (Game.flags && Game.flags.owl_trial_pass ? 'done' : ((Game.currentBiome==='forest')? questState('q_forest_guardian_owl') : 'locked'))
    };
  }

  // ---------- Draw helpers ----------
  function clamp(v,a,b){ return v<a?a : v>b?b : v; }
  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }
  function nearest(list, r=64){
    let best=-1, bd=r*r, cx=player.x+player.w/2, cy=player.y+player.h/2;
    for(let i=0;i<list.length;i++){ const o=list[i], d=dist2(cx,cy,o.x+o.w/2,o.y+o.h/2); if(d<bd){bd=d; best=i;} }
    return best;
  }
  function rectOutline(ctx,x,y,w,h,fill,stroke){ ctx.fillStyle=fill; ctx.fillRect(x|0,y|0,w,h); ctx.lineWidth=2; ctx.strokeStyle=stroke; ctx.strokeRect((x|0)+0.5,(y|0)+0.5,w,h); }

function drawPal(ctx, p, vx, vy){
  drawPalIcon(ctx, vx, vy, p);
}

  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    const rr=Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    if(fill) ctx.fill(); if(stroke) ctx.stroke();
  }
  function drawShell(ctx, w, h){
    ctx.fillStyle='#20314f'; ctx.fillRect(0,0,w,h);
    ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1;
    for(let x=0; x<w; x+=32){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0; y<h; y+=32){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(0,y); ctx.stroke(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  }

  // Minimap (tint per biome)
  function drawMinimap(ctx, x, y, w, h){
    const pad=8;
    const iw = w - pad*2, ih = h - pad*2;
    const sx = Math.max(1, Math.floor(iw / W));
    const sy = Math.max(1, Math.floor(ih / H));
    const scale = Math.min(sx, sy);
    const mw = W*scale, mh = H*scale;
    const ox = x + (w - mw)/2, oy = y + (h - mh)/2;

    ctx.fillStyle='rgba(0,0,0,0.35)'; roundRect(ctx, x, y, w, h, 8, true, false);

    for(let ty=0; ty<H; ty++){
      for(let tx=0; tx<W; tx++){
        if (Game.currentBiome==='desert'){
          const g=ground[gi(tx,ty)];
          ctx.fillStyle = (g===4) ? (COLORS[g]||'#3a78b8') : desertTone(tx,ty);
        } else {
          ctx.fillStyle = COLORS[ground[gi(tx,ty)]] || '#2f7a3f';
        }
        ctx.fillRect(ox+tx*scale, oy+ty*scale, scale, scale);
      }
    }

    // biome tint
    ctx.fillStyle = (Game.currentBiome==='forest') ? 'rgba(30,60,30,0.10)' : (Game.currentBiome==='desert' ? 'rgba(160,120,40,0.10)' : 'rgba(40,70,40,0.06)');
    ctx.fillRect(ox, oy, mw, mh);

    // fog overlay
    ctx.fillStyle='rgba(0,0,0,0.55)';
    for(let ty=0; ty<H; ty++){
      for(let tx=0; tx<W; tx++){
        if(!seen[gi(tx,ty)]) ctx.fillRect(ox+tx*scale, oy+ty*scale, scale, scale);
      }
    }
    // player ping
    const ptx = (player.x/TILE)|0, pty = (player.y/TILE)|0;
    ctx.fillStyle='#ffd54a'; ctx.fillRect(ox+ptx*scale, oy+pty*scale, scale, scale);
    ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.strokeRect(ox-0.5, oy-0.5, mw+1, mh+1);
  }

  // Hint helper
  function isTouchDevice(){ return ('ontouchstart' in window) || navigator.maxTouchPoints>0 || navigator.msMaxTouchPoints>0; }
  function hintText(){ return isTouchDevice() ? 'Hold A: interact  •  Select: SELECT  •  Start: START'
                                              : 'Hold E/J: interact  •  Select: Space/Tab  •  Start: Enter/Esc'; }

  function drawHint(ctx, px, py){
    const text = hintText(); ctx.font='12px ui-monospace, monospace';
    const tw = ctx.measureText(text).width, padX=8, padY=5;
    const bx = (px|0)-6, by=(py|0)-24, bw=tw+padX*2, bh=18+padY-4;
    ctx.fillStyle='rgba(0,0,0,0.72)'; roundRect(ctx, bx, by, bw, bh, 6, true, false);
    ctx.fillStyle='#e9f1ff'; ctx.fillText(text, bx+padX, by+12);
  }

  // ---------- Portal VFX ----------
  let animT = 0; // ms from rAF
  function drawPortal(ctx, pt, vx, vy){
    const x = pt.x - vx + pt.w/2;
    const y = pt.y - vy + pt.h/2;
    const baseR = 16;
    const t = animT * 0.002; // speed
    // pulsating glow
    const pulse = 0.5 + 0.5*Math.sin(t*2.0);
    const glowR = baseR + 6 + 4*pulse;

    // outer glow
    const g = ctx.createRadialGradient(x, y, baseR*0.2, x, y, glowR);
    g.addColorStop(0, 'rgba(185,120,255,0.55)');
    g.addColorStop(1, 'rgba(185,120,255,0.0)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,glowR,0,Math.PI*2); ctx.fill();

    // portal disk
    ctx.fillStyle='#8238ff';
    ctx.beginPath(); ctx.arc(x,y, baseR, 0, Math.PI*2); ctx.fill();

    // swirling rings
    ctx.strokeStyle='#caa8ff'; ctx.lineWidth=2;
    const ringCount=3;
    for(let i=0;i<ringCount;i++){
      const r = baseR - 4*i;
      const start = t + i*0.8;
      ctx.beginPath();
      ctx.arc(x, y, r, start, start + Math.PI*1.2); ctx.stroke();
    }

    // inner swirl
    ctx.strokeStyle='#ffffff';
    ctx.lineWidth=1.5;
    ctx.beginPath();
    ctx.arc(x, y, baseR*0.55, t*1.8, t*1.8 + Math.PI*1.4);
    ctx.stroke();
  }

  // Quick Panel (+Shop overlay buy/sell)
  function drawQuickPanel(ctx,w,h){
    const panelW = Math.max(360, Math.min(520, w - 24));
const x = Math.max(12, Math.floor((w - panelW) / 2));
const y = 70, ph = h - 140;
    ctx.fillStyle='rgba(0,0,0,0.70)'; roundRect(ctx,x,y,panelW,ph,10,true,false);

    // tabs
    for(let i=0;i<QUICK_TABS.length;i++){
      ctx.fillStyle = (i===quickTab)? '#ffd54a' : '#cfe6ff';
      ctx.font='14px ui-monospace, monospace';
      ctx.fillText(QUICK_TABS[i], x + 12 + i * Math.floor((panelW - 24) / QUICK_TABS.length), y+24);
    }
    ctx.fillStyle='#e9f1ff'; ctx.font='12px ui-monospace, monospace';
    let yy=y+48;

    if(quickTab===0){
      const list = Game.inventory;
      if(!list.length){ ctx.fillText('(bag empty)', x+14, yy); }
      else{
        if(invIdx>=list.length) invIdx=list.length-1; if(invIdx<0) invIdx=0;
        for(let i=0;i<list.length;i++){
          const s=list[i], hi=(i===invIdx);
          const slot=slotForItemId(s.id);
          const eq = slot? (equippedId(slot)===s.id) : false;
          ctx.fillStyle = hi? '#ffd54a' : '#e9f1ff';
          const suffix = eq? '  [E]' : '';
          ctx.fillText((hi?'> ':'  ')+`${s.id} ×${s.qty}`+suffix, x+14, yy); yy+=18;
          if (ITEMS[s.id]?.chargesMax){ ctx.fillStyle='#9fe8ff'; ctx.fillText(`   equip: ${s.id} has ${ITEMS[s.id].chargesMax} charges`, x+14, yy); yy+=16; }
        }
        yy+=8; ctx.fillStyle='#9fe8ff';
        ctx.fillText('A: Equip/Unequip  Left/Right: switch tab  B/Start: close', x+14, yy); yy+=16;
      }
    } else if(quickTab===1){
      const list = RECIPES.filter(r=>!r.requiresFlag || Game.flags[r.requiresFlag]); if(craftIdx>=list.length) craftIdx=list.length-1; if(craftIdx<0) craftIdx=0;
      for(let i=0;i<list.length;i++){
        const r=list[i], ok=hasItems(r.needs);
        ctx.fillStyle = (i===craftIdx)? '#ffd54a' : '#e9f1ff';
        ctx.fillText((i===craftIdx?'> ':'  ')+r.out, x+14, yy); yy+=16;
        ctx.fillStyle = ok? '#b7ffb7' : '#9ec6ff';
        ctx.fillText('needs: '+r.needs.map(n=>`${n.id}×${n.qty}`).join(', ') + (ok?'   [A craft]':'   (need mats)'), x+28, yy); yy+=18;
      }
    } else if(quickTab===2){
      const j=journalStats();
      ctx.fillText('— Journal —', x+14, yy); yy+=18;
      ctx.fillText(`Biome: ${j.biome}`, x+14, yy); yy+=16;
      ctx.fillText(`Coins: ${j.coins}`, x+14, yy); yy+=16;
      ctx.fillText(`Inventory stacks: ${j.stacks}`, x+14, yy); yy+=16;
      ctx.fillText(`Pals owned: ${j.palsOwned}`, x+14, yy); yy+=16;
      ctx.fillText(`Discovered items: ${j.discoveredItems}`, x+14, yy); yy+=16;
      
      { // Unified quest lines for all biomes
        let qid = (j.biome==='forest') ? 'q_forest_main' :
                  (j.biome==='meadow') ? 'q_meadow_main' :
                  (j.biome==='desert') ? 'q_desert_main' : null;
        if (qid && questState(qid)!=="locked"){
          const qpr = questProgress(qid);
          ctx.fillStyle='#ffd54a';
          ctx.fillText('Quest: '+QUESTS[qid].name, x+14, yy); yy+=16;
          ctx.fillStyle='#e9f1ff';
          // print up to 3 objective segments per line
          let line=''; let segs=0;
          for(const seg of qpr.prog){
            const t = seg.label+(seg.done?' ✓':'');
            if (segs && (line.length + t.length) > 40){ ctx.fillText(line, x+28, yy); yy+=16; line=''; segs=0; }
            line += (segs? '   ' : '') + t; segs++;
          }
          if (line) { ctx.fillText(line, x+28, yy); yy+=16; }
        } else if (!qid){
          ctx.fillText('Explore freely', x+14, yy);       hudQuestBottomY = 54;
yy+=16;
        } else {
          const tip = (j.biome==='forest') ? 'Talk to the Ranger to begin.' :
                      (j.biome==='meadow') ? 'Talk to the Elder to begin.' :
                      (j.biome==='desert') ? 'Speak with the Nomad Chief to start the circuit.' : '—';
          ctx.fillText(tip, x+14, yy);       hudQuestBottomY = 54;
yy+=16;
        }
        // Guardian/Trial line
        if (j.biome==='forest'){
          ctx.fillText(`Guardian Trial: ${questState('q_forest_guardian_owl')}`, x+14, yy); yy+=16;
        } else if (j.biome==='desert'){
          let gState = 'locked';
          try{
            if (Game.flags.desert_guardian_portal_ready || (Game.unlocked&&Game.unlocked.wetlands)) gState='done';
            else if (Game.flags.desert_oasis_guardian_awake) gState='active';
          }catch(_){}
          ctx.fillText(`Guardian: ${gState}`, x+14, yy); yy+=16;
        }
      }
    
      yy+=8; ctx.fillText('Pals & perks:', x+14, yy); yy+=16;
      // Scrollable pals list
      const listTop = yy;
      const listHeight = (y+ph - 24) - listTop; // leave a small bottom margin
      const rowH = 32; // name + perks
      if (JournalUI.scrollY == null) JournalUI.scrollY = 0;
      // Auto-scroll to keep selection visible
      const selTopPx = JournalUI.idx * rowH - JournalUI.scrollY;
      const selBotPx = selTopPx + rowH;
      if (selTopPx < 0) JournalUI.scrollY = Math.max(0, JournalUI.idx*rowH);
      else if (selBotPx > listHeight) JournalUI.scrollY = Math.min(JournalUI.idx*rowH - (listHeight - rowH), Math.max(0, Game.companions.length*rowH - listHeight));

      // Clip to panel
      ctx.save();
      ctx.beginPath();
      ctx.rect(x+10, listTop - 14, panelW - 20, listHeight + 20);
      ctx.clip();

      // Render visible slice
      for(let i=0;i<Game.companions.length;i++){
        const c = Game.companions[i];
        const lineY = listTop + (i*rowH) - JournalUI.scrollY;
        if (lineY > listTop-32 && lineY < listTop + listHeight + 16){
          const hi = (i===JournalUI.idx);
          ctx.fillStyle = hi? '#ffd54a' : '#e9f1ff';
          ctx.fillText((hi?'> ':'  ') + '• '+c.id + (c.isActive?' (active)':''), x+14, lineY);
          const perks=PALS[c.id]?.perks||{};
          const line=Object.keys(perks).map(k=>`${k}:${perks[k]===true?'✓':perks[k]}`).join(', ');
          if(line){ ctx.fillStyle='#9fe8ff'; ctx.fillText('   '+line, x+14, lineY+14); }
        }
      }
      ctx.restore();

      // Slim scrollbar
      const totalPx = Math.max(1, Game.companions.length*rowH);
      if (totalPx > listHeight){
        const trackX = x + panelW - 12, trackY = listTop, trackH = listHeight;
        ctx.fillStyle='rgba(255,255,255,0.12)'; ctx.fillRect(trackX, trackY, 2, trackH);
        const thumbH = Math.max(18, trackH * (listHeight/totalPx));
        const maxScroll = totalPx - listHeight;
        const thumbY = trackY + (maxScroll? (JournalUI.scrollY / maxScroll) * (trackH - thumbH) : 0);
        ctx.fillStyle='#ffd54a'; ctx.fillRect(trackX-1, thumbY, 4, thumbH);
      }

      yy = listTop + listHeight; yy+=8; ctx.fillStyle='#9fe8ff'; ctx.fillText('Up/Down: select    A: Drop selected', x+14, yy); yy+=16;
    } else if(quickTab===3){
      const pad=12, mapX=x+pad, mapY=y+40, mapW=panelW-2*pad, mapH=ph-52;
      drawMinimap(ctx, mapX, mapY, mapW, mapH);
    }
// Cheats (4)
else if (quickTab === 4) {
  // windowed render around the current index so it "scrolls" without extra state
  const list = CheatsUI.list;
  const visible = 8;                  // fits in the panel nicely
  const start = Math.max(0, Math.min(list.length - visible, CheatsUI.idx - Math.floor(visible / 2)));
  const end = Math.min(list.length, start + visible);

  // header
  ctx.fillStyle = '#cfe6ff';
  ctx.fillText('— Cheats —', x + 14, yy);
  yy += 18;

  for (let i = start; i < end; i++) {
    const row = list[i];
    const hi = (i === CheatsUI.idx);
    // code line
    ctx.fillStyle = hi ? '#ffd54a' : '#e9f1ff';
    ctx.fillText((hi ? '> ' : '  ') + row.code, x + 14, yy);
    yy += 16;
    // description line
    ctx.fillStyle = '#9ec6ff';
    ctx.fillText('   ' + row.desc, x + 14, yy);
    yy += 16;
  }

  yy += 8;
  ctx.fillStyle = '#9fe8ff';
  ctx.fillText('Up/Down: select   A: Run   B/Start: close   Left/Right: switch tab', x + 14, yy);
}

    // Shop overlay (buy/sell tabs)
    if (ShopUI.open){
      const sw=340, sh=240, sx=(x+panelW/2 - sw/2)|0, sy=(y+ph/2 - sh/2)|0;
      ctx.fillStyle='rgba(10,14,24,0.95)'; ctx.fillRect(sx,sy,sw,sh);
      ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.strokeRect(sx+0.5,sy+0.5,sw,sh);
      // tabs
      ctx.font='14px ui-monospace, monospace';
      ctx.fillStyle= ShopUI.mode==='buy' ? '#ffd54a' : '#9ec6ff'; ctx.fillText('Buy', sx+14, sy+22);
      ctx.fillStyle= ShopUI.mode==='sell'? '#ffd54a' : '#9ec6ff'; ctx.fillText('Sell', sx+64, sy+22);
      // list
      ctx.fillStyle='#cfe6ff'; ctx.font='12px ui-monospace, monospace';
      const list=shopItems(); let y2=sy+48;
      if(!list.length){ ctx.fillText(ShopUI.mode==='buy'?'(no stock)':'(nothing to sell)', sx+14, y2); }
      else{
        for(let i=0;i<list.length;i++){
          const it=list[i], hi=i===ShopUI.idx;
          ctx.fillStyle=hi?'#ffd54a':'#e9f1ff';
          const label = ShopUI.mode==='buy'
            ? ((hi?'> ':'  ')+it.id+'  —  '+it.price+'c')
            : ((hi?'> ':'  ')+it.id+'  —  '+(SELL_VALUE[it.id]||0)+'c  (×'+it.qty+')');
          ctx.fillText(label, sx+14, y2); y2+=18;
        }
        y2+=10; ctx.fillStyle='#9fe8ff';
        ctx.fillText(ShopUI.mode==='buy' ? 'A: buy   Left/Right: switch tab   B/Start: close'
                                         : 'A: sell  Left/Right: switch tab   B/Start: close', sx+14, y2);
      }
    }
  }
// === Guardian Trial visuals ===
function glowCircle(ctx, cx, cy, r, rgbaStart){
  const g = ctx.createRadialGradient(cx,cy, r*0.2, cx,cy, r);
  g.addColorStop(0, rgbaStart);
  g.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
}
function twinkle(ctx, cx, cy, t){
  const p = (Math.sin(t*4.0)+1)*0.5;
  ctx.save(); ctx.globalAlpha = 0.6 + 0.4*p; ctx.lineWidth=1.5; ctx.strokeStyle='#a6f6ff';
  ctx.beginPath();
  ctx.moveTo(cx-6,cy); ctx.lineTo(cx+6,cy);
  ctx.moveTo(cx,cy-6); ctx.lineTo(cx,cy+6);
  ctx.stroke(); ctx.restore();
}
function drawGuardianLayer(ctx, vx, vy){
  try{
  // Pedestal (only if not passed)
  if (Game.currentBiome==='forest' && (!Game.flags.owl_trial_pass || !Game.flags.q_forest_main_done) && GuardianTrial.pedestal.x!=null){
    const cx = GuardianTrial.pedestal.x - vx, cy = GuardianTrial.pedestal.y - vy;
    ctx.save();
    glowCircle(ctx, cx, cy, 24, 'rgba(120,200,255,0.45)');
    ctx.fillStyle='#6e6f78';
    ctx.fillRect((cx-14)|0,(cy-14)|0,28,28);
    ctx.strokeStyle='#2b2c33'; ctx.lineWidth=2; ctx.strokeRect((cx-14)+0.5,(cy-14)+0.5,27,27);
    ctx.restore();
    // Hint when close
    if (!GuardianTrial.active && distToPlayer(GuardianTrial.pedestal.x, GuardianTrial.pedestal.y) < 64){
      ctx.save(); ctx.globalAlpha=0.95; ctx.fillStyle='#dfe8ff'; ctx.font='bold 14px ui-monospace';
      ctx.fillText('Press A to begin', (cx-54)|0, (cy-22)|0); ctx.restore();
    }
    if (state && state.pressEdge && state.pressEdge.has && state.pressEdge.has('A')){
      try{ state.pressEdge.delete('A'); }catch(_){}
      window.__AHandledPedestal = true;
      startGuardianTrial();
    }
    
  }
  // Wisps
  if (GuardianTrial.active){
    const t = performance.now()*0.001;
    for (const w of GuardianTrial.wisps){
      const x = w.x - vx, y = w.y - vy;
      if (w.collected){ glowCircle(ctx, x, y, 12, 'rgba(166,246,255,0.35)'); continue; }
      glowCircle(ctx, x, y, 16, 'rgba(166,246,255,0.60)');
      twinkle(ctx, x, y, t + (w.t0||0)*0.001);
      ctx.save(); ctx.globalAlpha=0.9; ctx.fillStyle='#bff9ff'; ctx.beginPath(); ctx.arc(x,y,3.2,0,Math.PI*2); ctx.fill(); ctx.restore();
    }
  }
  }catch(e){}
}
  // ---------- HUD / World draw ----------
// Guard: ensure drawPlayer exists before drawWorld is called
if (typeof window.drawPlayer !== 'function') {
  window.drawPlayer = function(ctx, px, py){
    const x=(px|0), y=(py|0);
    ctx.save();
    ctx.fillStyle='#ffd86b'; ctx.fillRect(x-3,y-8,6,6);
    ctx.fillStyle='#e9eef7'; ctx.fillRect(x-3,y-2,6,6);
    ctx.restore();
  };
}

  function drawWorld(ctx,w,h){
    const worldW=W*TILE, worldH=H*TILE;
    const vx = clamp((player.x|0) - (w>>1), 0, Math.max(0, worldW - w));
    const vy = clamp((player.y|0) - (h>>1), 0, Math.max(0, worldH - h));
    const tx0=Math.max(0,(vx/TILE|0)-1), ty0=Math.max(0,(vy/TILE|0)-1);
    const tx1=Math.min(W-1,((vx+w)/TILE|0)+1), ty1=Math.min(H-1,((vy+h)/TILE|0)+1);

    // tiles
    for(let ty=ty0; ty<=ty1; ty++) for(let tx=tx0; tx<=tx1; tx++){
      if (Game.currentBiome==='desert'){
        const g=ground[gi(tx,ty)];
        ctx.fillStyle = (g===4) ? (COLORS[g]||'#3a78b8') : desertTone(tx,ty);
      } else if (Game.currentBiome==='wetlands'){
        ctx.fillStyle = (typeof wetlandsTone==='function') ? wetlandsTone(tx,ty) : (COLORS[ground[gi(tx,ty)]] || '#2f7a3f');
      } else {
        ctx.fillStyle = COLORS[ground[gi(tx,ty)]] || '#2f7a3f';
      }
      ctx.fillRect(tx*TILE - vx, ty*TILE - vy, TILE, TILE);
    }
    // deco
    for(let ty=ty0; ty<=ty1; ty++) for(let tx=tx0; tx<=tx1; tx++){
      const d=deco[gi(tx,ty)]; if(!d) continue; const x=tx*TILE-vx, y=ty*TILE-vy;
      if (d===1){ ctx.fillStyle='#ffd1e6'; ctx.fillRect(x+10,y+10,4,4); ctx.fillStyle='#ffe66d'; ctx.fillRect(x+14,y+14,3,3); } // flowers
      else if (d===2){ ctx.fillStyle='#1f6a33'; ctx.fillRect(x+6,y+6,20,20); } // bush
      else if (d===3){ ctx.fillStyle='#a8b1ba'; ctx.fillRect(x+8,y+12,16,12); } // rock
      else if (d===4){ ctx.fillStyle='#a0c24a'; ctx.fillRect(x+12,y+6,4,16); ctx.fillRect(x+16,y+10,4,16); } // reeds
      else if (d===5){ ctx.fillStyle='#2e3b17'; ctx.fillRect(x+8,y+8,16,16); } // tree chunk
    
      else if (Game.currentBiome==='desert' && d===10){ // cactus
        ctx.fillStyle='#1e8f5e'; ctx.fillRect(x+12,y+6,8,20);
        ctx.fillRect(x+8,y+12,4,10); ctx.fillRect(x+20,y+12,4,10);
        ctx.strokeStyle='#0d4f35'; ctx.strokeRect(x+12.5,y+6.5,7,19);
      } else if (Game.currentBiome==='desert' && d===11){ // rock
        ctx.fillStyle='#a18a6a'; ctx.fillRect(x+10,y+14,12,10);
        ctx.fillStyle='#8b765c'; ctx.fillRect(x+6,y+18,8,6);
      } else if (Game.currentBiome==='desert' && d===12){ // dry shrub
        ctx.strokeStyle='#b4935b'; ctx.beginPath(); ctx.moveTo(x+10,y+20); ctx.lineTo(x+16,y+12); ctx.lineTo(x+22,y+20); ctx.stroke();
      }
}

    // entities
    /* Stage 5e: desert world plates (under entities & player) */
    try{
      if (Game && Game.currentBiome==='desert' && Game.flags && Array.isArray(Game.flags.desert_landmarks)){
        var id = (ctx && ctx.canvas && ctx.canvas.id) || '';
        if (id==='game' || id==='gameLandscape'){
          var __vx = (typeof vx!=='undefined'?vx:(typeof camX!=='undefined'?camX:0));
          var __vy = (typeof vy!=='undefined'?vy:(typeof camY!=='undefined'?camY:0));
          var T = (typeof TILE!=='undefined'?TILE:32);
          for (var i=0;i<Game.flags.desert_landmarks.length;i++){
            var L = Game.flags.desert_landmarks[i];
            var x = (L.tx*T - __vx)|0, y = (L.ty*T - __vy)|0;
            // painted structures
            const obj = {x:x, y:y, w:T, h:T};
            if (L.type==='scout'){
              drawDesertPost(ctx, obj, 0, 0);
            } else if (L.type && L.type.indexOf('shrine_')===0){
              drawDesertShrine(ctx, obj, 0, 0);
            } else if (L.type==='vault'){
              drawDesertVault(ctx, obj, 0, 0);
            }
            else if (L.type && L.type.indexOf('shrine_')===0){
              ctx.strokeStyle = '#ff3b5c'; ctx.lineWidth = 2; ctx.strokeRect(x+5, y+5, T-10, T-10);
            } else if (L.type==='vault'){
              ctx.strokeStyle = '#d9c36a'; ctx.lineWidth = 2; ctx.strokeRect(x+7, y+7, T-14, T-14);
            }
          }
        }
      }
    }catch(_){}

    items.forEach(it=> drawItemIcon(ctx, vx, vy, it));
    npcs .forEach(n => drawNPC(ctx, vx, vy, n));
    pals.forEach(p => drawPal(ctx, p, vx, vy));
    portals.forEach(pt=> drawPortal(ctx, pt, vx, vy)); // purple swirl with glow

    // Guardian pedestal + wisps (rendered below player)
    try{ drawGuardianLayer(ctx, vx, vy); }catch(e){}

    // player
const px = player.x - vx, py = player.y - vy;
drawPlayer(ctx, px, py);

    // hint
    const nearAny = nearest(items.concat(npcs, pals, portals), 64);
    if (nearAny !== -1) drawHint(ctx, px, py);

    
    // draw chests and particles
    drawChests(ctx, vx, vy);
    // particles
    for(const p of particles){ const px=(p.x-vx)|0, py=(p.y-vy)|0; ctx.fillStyle = ['#ffd54a','#7eddd7','#caa8ff','#ff8aa0','#9fe8ff'][(Math.random()*5)|0]; ctx.fillRect(px, py, 3, 3);} 

    // Buff chips
    const nowB = Date.now();
    let bx=420, by=56;
    if (Game.buffs && nowB < Game.buffs.defUntil){ ctx.fillStyle='rgba(43,60,43,0.65)'; ctx.fillRect(bx,by-12,84,16); ctx.fillStyle='#b7ffb7'; ctx.fillText('BUFF: DEF↑', bx+6, by); bx+=96; }
    if (Game.buffs && nowB < Game.buffs.speedUntil){ ctx.fillStyle='rgba(43,52,72,0.65)'; ctx.fillRect(bx,by-12,104,16); ctx.fillStyle='#9ec6ff'; ctx.fillText('BUFF: SPEED↑', bx+6, by); bx+=116; }
    if (Game.buffs && nowB < Game.buffs.partyUntil){ ctx.fillStyle='rgba(60,43,58,0.65)'; ctx.fillRect(bx,by-12,116,16); ctx.fillStyle='#ffb7d1'; ctx.fillText('PARTYTIME', bx+6, by); }

// HUD band (expanded height to prevent overlap)
    const bandX=8, bandY=8, bandW=w-16, bandH=96;
    ctx.fillStyle='rgba(0,0,0,0.55)'; roundRect(ctx, bandX, bandY, bandW, bandH, 10, true, false);
    ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.beginPath();
    ctx.moveTo(150, bandY+12); ctx.lineTo(150, bandY+bandH-12);
    ctx.moveTo(300, bandY+12); ctx.lineTo(300, bandY+bandH-12);
    ctx.stroke();

    ctx.fillStyle='#e9f1ff'; ctx.font='12px ui-monospace, monospace';
    // Row 1 — static readouts
    ctx.fillText('Scene: '+Game.currentBiome, 16, 24);
    ctx.fillText('Pos: '+(player.x|0)+','+(player.y|0), 16, 40);
    ctx.fillText('Coins: '+Game.coins, 160, 24);
    ctx.fillText('Bag: '+Game.inventory.length+' stacks', 160, 40);

    // active pal chip
    const ap = Game.companions.find(p=>p.isActive) || Game.companions[0];
    if (ap){ ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(260, 16, 120, 20); ctx.fillStyle='#e9f1ff'; ctx.fillText('Pal: '+ap.id, 266, 26); }

    // Player HP bar
    { const hp=Game.stats.hp||Game.stats.hpMax||100, hpm=Game.stats.hpMax||100;
      const ratio = Math.max(0, Math.min(1, hp/hpm));
      ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(12,54,180,10);
      ctx.fillStyle='#54C9C1'; ctx.fillRect(12,54, (180*ratio)|0, 10);
      ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.strokeRect(12.5,56.5,179,9);
    }

    // === Quest / Progress line (full row, wraps) ===
    hudQuestBottomY = 56; // default fall-back baseline
    {
      const qpr = (typeof window!=='undefined' && typeof window.buildQuestProgress==='function') ? window.buildQuestProgress() : (typeof buildQuestProgress==='function' ? buildQuestProgress() : null);
      if (qpr && qpr.prog && qpr.prog.length){
        const segs = qpr.prog.map(seg => (seg.done?'\u2713 ':'• ') + seg.label);
        const x0 = 16, y0 = 68; const maxW = Math.max(140, (ctx.canvas?ctx.canvas.width:960) - x0 - 18);
        const lines = clampHUDSegments(ctx, segs, maxW, 2);
        for(let i=0;i<lines.length;i++){ ctx.fillText(lines[i], x0, y0 + i*14); }
        hudQuestBottomY = y0 + lines.length*14;
      } else {
        // No quest progress — show a single, right-aligned hint on the top HUD row.
        var hint = (Game.currentBiome === 'desert')
          ? ''
          : (Game.currentBiome === 'forest'
              ? ''
              : '');

        // right-align at y=24, clamp to one line with ellipsis
        var padR = 18;
        var maxW = Math.max(120, (ctx.canvas ? ctx.canvas.width : 960) * 0.40);
        function clampOneLine(text, maxWidth){
          var w = ctx.measureText(text).width;
          if (w <= maxWidth) return text;
          var ell = '…', out = '';
          for (var i=0;i<text.length;i++){ var t = out + text[i]; if (ctx.measureText(t + ell).width > maxWidth) break; out = t; }
          return out + ell;
        }
        var txt = clampOneLine(hint, maxW);
        var tw = ctx.measureText(txt).width;
        var xRight = (ctx.canvas ? ctx.canvas.width : 960) - padR - tw;
        ctx.fillText(txt, xRight, 24);
        hudQuestBottomY = 68; // baseline for HP layout
      }}

    // === Equipment chips on next row (wrap as needed) + Boss HP bar avoids them ===
    {
      let ex = 16, ey = hudQuestBottomY + 4;
      const chips = [];
      if (Game.equipped){
        if (Game.equipped.weapon){
          const t = Game.equipped.weapon;
          chips.push(['Weapon', t.id + (t.usesLeft!=null? ` (${t.usesLeft}/${t.usesMax||t.usesLeft})` : '')]);
        }
        if (Game.equipped.tool){
          const t = Game.equipped.tool;
          chips.push(['Tool', t.id + (t.usesLeft!=null? ` (${t.usesLeft}/${t.usesMax||t.usesLeft})` : '')]);
        }
        if (Game.equipped.armor){
          chips.push(['Armor', Game.equipped.armor.id]);
        }
        if (Game.buffs && Game.buffs.buffme){ // BUFF+ chip if cheat active
          chips.push(['BUFF+', 'Active']);
        }
      }
      ctx.font='12px ui-monospace, monospace';
      const chipRects = [];
      const rightLimit = w - 16;
      for (const [k,v] of chips){
        const label = `${k}: ${v}`;
        const tw = Math.ceil(ctx.measureText(label).width);
        const cw = tw + 14;
        if (ex + cw > rightLimit){ ex = 16; ey += 22; }
        chipRects.push({x:ex, y:ey, w:cw, h:20, label});
        ex += cw + 10;
      }
      const chipsRight = chipRects.length ? (chipRects[chipRects.length-1].x + chipRects[chipRects.length-1].w) : 16;

      // Boss HP bar (y aligned under chips) — shrink/move left to avoid chips
      if (typeof BoarBoss!=='undefined' && BoarBoss.active){
        const desiredW = 240;
        let bx = Math.max((w - 12 - desiredW)|0, (chipsRight + 8)|0);
        let bwMax = Math.max(0, (w - 12) - bx);
        const ratio = Math.max(0, Math.min(1, BoarBoss.hp/BoarBoss.hpMax));
        ctx.fillStyle='rgba(0,0,0,0.5)';
        ctx.fillRect(bx, ey + 8, bwMax, 12);
        ctx.fillStyle='#ff7b7b';
        ctx.fillRect(bx, ey + 8, Math.max(0, bwMax*ratio), 12);
        ctx.fillStyle='#e9f1ff';
        const labelX = bx + (bwMax>>1) - 18;
        ctx.fillText('Boar', labelX|0, ey + 6);
      }

      for (const r of chipRects){
        ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(r.x, r.y, r.w, r.h);
        ctx.fillStyle='#e9f1ff'; ctx.fillText(r.label, r.x+6, r.y+14);
      }
    }
function clampHUDSegments(ctx, segments, maxWidth, maxLines){
  const lines=[]; let line=''; let segs=0;
  for(const seg of segments){
    const token = (segs? '   ' : '') + seg;
    if (line && ctx.measureText(line + token).width > maxWidth){
      lines.push(line); line = seg; segs = 1;
      if (lines.length >= maxLines) break;
    } else {
      line += token; segs++;
    }
  }
  if (line && lines.length < maxLines) lines.push(line);
  const joined = segments.join('   ');
  const printed = lines.join('   ');
  if (joined.length > printed.length && lines.length){
    let last = lines[lines.length-1]; const ell=' …';
    while (last && ctx.measureText(last + ell).width > maxWidth){ last = last.slice(0,-1); }
    lines[lines.length-1] = (last||'…') + (last ? ell : '');
  }
  return lines;
}
// quest tracker
{
  hudQuestBottomY = 0;  // unified declaration to avoid redeclare errors

  const qid = (Game.currentBiome==='forest') ? 'q_forest_main'
            : (Game.currentBiome==='meadow') ? 'q_meadow_main'
            : (Game.currentBiome==='desert') ? 'q_desert_main'
            : (Game.currentBiome==='wetlands') ? 'q_wetlands_main'
            : null;

  if (qid && questState(qid)!=="locked"){
    const qpr = questProgress(qid);
    ctx.fillText('Quest: '+QUESTS[qid].name, 420, 24);
    const segs = qpr.prog.map(seg => seg.label + (seg.done?' ✓':''));
    const x0 = 420, y0 = 40; 
    const maxW = Math.max(140, (ctx.canvas ? ctx.canvas.width : 960) - x0 - 18);
    const lines = clampHUDSegments(ctx, segs, maxW, 2);
    for (let i=0; i<lines.length; i++){ 
      ctx.fillText(lines[i], x0, y0 + i*14); 
    }
    hudQuestBottomY = y0 + lines.length*14;

  } else if (Game.currentBiome === 'desert') {
    ctx.fillText('Speak with the Nomad Chief to start the circuit.', 420, 24);
    hudQuestBottomY = 54;

  } else if (Game.currentBiome === 'wetlands') {
    ctx.fillText('Seek out the Bog Hermit to begin your swamp trials.', 420, 24);
    hudQuestBottomY = 54;

  } else {
    const tip = (Game.currentBiome==='forest')
      ? 'Talk to the Ranger to begin the forest quest.'
      : 'Talk to the Elder to begin the meadow quest.';
    ctx.fillText(tip, 420, 24);
    hudQuestBottomY = 54;
  }
   }
// Guardian Trial HUD (compact, inside top band)
    if (Game.currentBiome==='forest' && (!Game.flags.owl_trial_pass || GuardianTrial.active)){
      const label = 'Wisps ' + GuardianTrial.collected + '/5';
      const secs = Math.ceil((GuardianTrial.active? Math.max(0, GuardianTrial.timeLeft):0)/1000);
      const timeTxt = GuardianTrial.active ? (String(Math.floor(secs/60))+':'+String(secs%60).padStart(2,'0')) : '—:—';
      const chip = label + '  ' + timeTxt;
      ctx.font='12px ui-monospace, monospace';
      const tw = ctx.measureText(chip).width;
      const cw = tw + 16, ch = 18;
      const cx = w - cw - 16, cy = 14;
      ctx.fillStyle='rgba(12,18,28,0.65)'; ctx.fillRect(cx, cy, cw, ch);
      ctx.fillStyle='#a6f6ff'; ctx.fillText(chip, cx+8, cy+13);
    }


    // Calm prompt over boar when downed
    if (typeof BoarBoss!=='undefined' && BoarBoss.active && BoarBoss.hp<=0){
      const bc = (function(){ const i=pals.findIndex(p=>p.id==='boar' && p.boss); if(i===-1) return null; const b=pals[i]; return {x:b.x+b.w/2 - vx, y:b.y - vy - 18}; })();
      if (bc){ ctx.save(); ctx.globalAlpha=0.95; ctx.fillStyle='#dfe8ff'; ctx.font='bold 14px ui-monospace'; ctx.fillText('Press A to calm', (bc.x-52)|0, (bc.y|0)); ctx.restore(); }
    }

    // Toast
    if (performance.now() < toastUntil) {

      // Toast with dynamic background sizing (multi-line safe)
      var padX = 12, padY = 6;
      var maxW = w - 24;
      var lines = (toastMsg && (""+toastMsg).split("\n")) || [""];
      ctx.save();
      if (typeof ctx.setTransform==='function') ctx.setTransform(1,0,0,1,0,0);
      ctx.font = ctx.font || '14px ui-monospace';
      var textW = 0;
      for (var i=0;i<lines.length;i++){
        var tw = (ctx.measureText? ctx.measureText(lines[i]).width : (12*lines[i].length));
        if (tw > textW) textW = tw;
      }
      var boxW = Math.min(Math.max(textW + padX*2, 220), maxW);
      var lineH = 18;
      var boxH = padY*2 + lineH*lines.length;
      var x = 12, y = h - (boxH + 14);

      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(x, y, boxW, boxH);

      ctx.fillStyle = '#e9f1ff';
      for (var j=0;j<lines.length;j++){
        ctx.fillText(lines[j], x + padX, y + padY + lineH*(j+0.7));
      }
      ctx.restore();

    }

    // Panels
    if (UI.quick) drawQuickPanel(ctx,w,h);
    if (UI.start) drawStartMenu(ctx,w,h);
  
  /* Desert quick-fix: world plates under sprites */
  try{
    if (Game && Game.currentBiome==='desert' && Game.flags && Array.isArray(Game.flags.desert_landmarks)){
      var id = (ctx && ctx.canvas && ctx.canvas.id) || '';
      if (id==='game' || id==='gameLandscape'){
        var __vx = (typeof vx!=='undefined'?vx:(typeof camX!=='undefined'?camX:0));
        var __vy = (typeof vy!=='undefined'?vy:(typeof camY!=='undefined'?camY:0));
        var T = (typeof TILE!=='undefined'?TILE:32);
        var __prevGCO = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'destination-over';
        for (var i=0;i<Game.flags.desert_landmarks.length;i++){
          var L = Game.flags.desert_landmarks[i];
          var x = (L.tx*T - __vx)|0, y = (L.ty*T - __vy)|0;
          if (L.type==='scout'){
            ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 2; ctx.strokeRect(x+6, y+6, T-12, T-12);
          } else if (L.type && L.type.indexOf('shrine_')===0){
            ctx.strokeStyle = '#ff3b5c'; ctx.lineWidth = 2; ctx.strokeRect(x+5, y+5, T-10, T-10);
          } else if (L.type==='vault'){
            ctx.strokeStyle = '#d9c36a'; ctx.lineWidth = 2; ctx.strokeRect(x+7, y+7, T-14, T-14);
          }
        }
        ctx.globalCompositeOperation = __prevGCO;
      }
    }
  }catch(_){}

}


  function controlsLine(){
    return isTouchDevice()
      ? 'Move: D-Pad  •  Interact: A  •  Pal: B  •  Start: START  •  Select: SELECT'
      : 'Move: WASD/Arrows  •  Interact: E or J  •  Pal: Q or K  •  Start: Enter/Esc  •  Select: Space/Tab';
  }
  function drawStartMenu(ctx,w,h){
    const mw = Math.min(520, w-120), mh = Math.min(360, h-120);
    const x = (w-mw)>>1, y = (h-mh)>>1;
    ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,w,h);
    ctx.fillStyle='rgba(12,16,28,0.95)'; ctx.fillRect(x,y,mw,mh);
    ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.strokeRect(x+0.5,y+0.5,mw,mh);
    ctx.fillStyle='#e9f1ff'; ctx.font='18px ui-monospace, monospace';
    ctx.fillText('START MENU', x+18, y+30);
    ctx.font='13px ui-monospace, monospace';
    ctx.fillText(controlsLine(), 16, 64);
    let yy=y+84;
    for(let i=0;i<START_ITEMS.length;i++){
      const hi = (i===UI.startIdx);
      ctx.fillStyle = hi? '#20314f' : 'transparent';
      ctx.fillRect(x+14, yy-14, mw-28, 22);
      ctx.fillStyle = hi? '#ffd54a' : '#cfe6ff';
      ctx.fillText(START_ITEMS[i], x+24, yy);
      yy+=26;
    }
  }

  // ---------- Movement helpers ----------
  function activePal(){ return Game.companions.find(p=>p.isActive) || Game.companions[0]; }
  function currentSpeed(){
    const ap=activePal(); const perk=PALS[ap?.id]?.perks||{};
    return player.baseSpeed * (1 + (perk.speed||0));
  }

  // ---------- Loop ----------
  let last=0, aHoldT=0;
  function frame(t){
    window.__AHandledPedestal = false;
animT = t; // for portal animation
    const dt = Math.min(0.05,(t-last)/1000||0); last=t;

    if (Game.currentBiome==='desert' && typeof DESERT!=='undefined' && DESERT && DESERT._trialUpdate) DESERT._trialUpdate(dt, state);

    // Movement (water + brush checks)
    if (!UI.start){
      let ax=0, ay=0; const p=state.pressed;
      if(p.has('Left')) ax-=1; if(p.has('Right')) ax+=1; if(p.has('Up')) ay-=1; if(p.has('Down')) ay+=1;
      const sp=currentSpeed();

      const ap=activePal(); const perks=PALS[ap?.id]?.perks||{};
      const allowWater = !!perks.water_walk;
      const allowBrush = !!perks.brush_break;

      // try X
      const nx = clamp(player.x + ax*sp*dt, 2, W*TILE - player.w - 2);
      const cxX = ((nx + player.w/2)/TILE)|0, cyX = ((player.y + player.h/2)/TILE)|0;
      const gxX = ground[gi(cxX,cyX)];
      const canX = (gxX!==4 || allowWater) && (gxX!==BRUSH || allowBrush);
      if (canX) player.x = nx;

      // try Y
      const ny = clamp(player.y + ay*sp*dt, 2, H*TILE - player.h - 2);
      const cxY = ((player.x + player.w/2)/TILE)|0, cyY = ((ny + player.h/2)/TILE)|0;
      const gxY = ground[gi(cxY,cyY)];
      const canY = (gxY!==4 || allowWater) && (gxY!==BRUSH || allowBrush);
      if (canY) player.y = ny;
    }

    // Guardian Trial update (timer + collection)
    if (Game.currentBiome==='forest'){
      if (GuardianTrial.active){
        GuardianTrial.timeLeft = Math.max(0, GuardianTrial.timeLeft - dt*1000);
        try{
// collect wisps within ~24px radius (one per frame)
        for (let i=0;i<GuardianTrial.wisps.length;i++){
          const w = GuardianTrial.wisps[i];
          if (!w.collected && Math.hypot((player.x+player.w/2)-w.x, (player.y+player.h/2)-w.y) <= 24){
            w.collected = true; GuardianTrial.collected++; toast('Wisp +1');
            break;
          }
        }
}catch(e){}
if (GuardianTrial.collected >= 5){ endGuardianTrial(true); }
        else if (GuardianTrial.timeLeft <= 0){ endGuardianTrial(false); }
      }
    }

    // --- Boar boss combat update ---
    ensureBoarBoss();
    if (BoarBoss.active){
      const bc = bossCenter();
      if (bc){
        const b = bc.b;
        // timers
        BoarBoss.t += dt; if (BoarBoss.iframe>0) BoarBoss.iframe -= dt; if (BoarBoss.contactCD>0) BoarBoss.contactCD -= dt;
        // vector to player
        const dx = (player.x+player.w/2) - (b.x+b.w/2);
        const dy = (player.y+player.h/2) - (b.y+b.h/2);
        const d = Math.hypot(dx,dy)||1;
        // simple state machine
        if (BoarBoss.state==='idle'){ if (BoarBoss.t>1.0){ BoarBoss.t=0; BoarBoss.state='tele'; } }
        else if (BoarBoss.state==='tele'){ if (BoarBoss.t>0.6){ BoarBoss.t=0; BoarBoss.state='charge'; BoarBoss.vx=(dx/d)*240; BoarBoss.vy=(dy/d)*240; } }
        else if (BoarBoss.state==='charge'){ b.x += BoarBoss.vx*dt; b.y += BoarBoss.vy*dt; if (BoarBoss.t>0.45){ BoarBoss.t=0; BoarBoss.state='idle'; BoarBoss.vx=BoarBoss.vy=0; } }
        // clamp within world
        b.x = clamp(b.x, 2, W*TILE - b.w - 2); b.y = clamp(b.y, 2, H*TILE - b.h - 2);
        // Z attack (player)
        if (state.pressEdge.has('Z')){
          const pr=36;
          if (Math.hypot(dx,dy) <= pr){
            let dmg=4;
            const wInst = Game.equipped && Game.equipped.weapon;
            if (wInst && wInst.id==='weapon_stick' && (wInst.usesLeft||0)>0){ dmg=8; wInst.usesLeft-=1; if (wInst.usesLeft<=0){ Game.equipped.weapon=null; toast('Stick broke'); } }
            if (BoarBoss.iframe<=0){ BoarBoss.hp=Math.max(0, BoarBoss.hp - dmg); BoarBoss.iframe=0.6; toast('Hit -'+dmg); }
          }
        }
        // Boss hits player on contact during charge
        if (BoarBoss.state==='charge' && Math.hypot(dx,dy) < 20 && BoarBoss.contactCD<=0){
          const m=Game.stats.hpMax||100; Game.stats.hp=Math.max(0,(Game.stats.hp||m)-20); BoarBoss.contactCD=0.8;
          if (Game.stats.hp<=0){
            toast('You were knocked out!'); Game.stats.hp = Game.stats.hpMax||100;
            BoarBoss.hp = BoarBoss.hpMax; BoarBoss.state='idle'; BoarBoss.t=0; BoarBoss.vx=BoarBoss.vy=0; BoarBoss.iframe=0;
            const sp = safeCampSpawn(); player.x = sp.x; player.y = sp.y;
          }
        }
        // Calm (A) when boss HP zero
        if (BoarBoss.hp<=0){
          if (state.pressEdge.has('A')){
            // befriend
            const idx = pals.findIndex(p=>p.id==='boar' && p.boss);
            if (idx!==-1) pals.splice(idx,1);
            Game.flags.boar_miniboss_defeated=true; Game.flags.boarBossActive=false; BoarBoss.active=false;
            Game.companions.push({id:'boar'}); Game.discovered.add('boar'); toast('Boar joined your party!');
          }
        }
      }
    }


    // desert auto-sanitize (lightweight, every ~120 frames)
    if (Game.currentBiome==='desert'){
      if (!frame.__sanCt) frame.__sanCt = 0;
      frame.__sanCt++;
      if (frame.__sanCt % 120 === 0 && typeof sanitizeBiomeEntities==='function'){
        sanitizeBiomeEntities();
      }
    }
    // reveal tiles to minimap fog
    const ptx=(player.x/TILE)|0, pty=(player.y/TILE)|0;
    for(let ry=-5; ry<=5; ry++){
      for(let rx=-5; rx<=5; rx++){
        const tx=ptx+rx, ty=pty+ry;
// Patch: remember last facing direction
if (state.pressed.has('Left'))  lastDir.x = -1, lastDir.y = 0;
if (state.pressed.has('Right')) lastDir.x =  1, lastDir.y = 0;
if (state.pressed.has('Up'))    lastDir.x =  0, lastDir.y = -1;
if (state.pressed.has('Down'))  lastDir.x =  0, lastDir.y = 1;
        if(tx>=0 && ty>=0 && tx<W && ty<H) seen[gi(tx,ty)] = 1;
      }
    }

    
    // Buff timers + speed multiplier
    if (Game && Game.buffs){
      if (Date.now() < Game.buffs.speedUntil) Game.stats.speedMult = 2.5; else Game.stats.speedMult = 1.0;
      const partyOn = Date.now() < Game.buffs.partyUntil;
      // confetti emit
      if (partyOn && particles.length<220){
        const cv = activeCanvas();
        const vx0 = clamp((player.x|0) - (cv.width>>1), 0, Math.max(0, (W*TILE) - cv.width));
        const vy0 = clamp((player.y|0) - (cv.height>>1), 0, Math.max(0, (H*TILE) - cv.height));
        for(let i=0;i<6;i++){
          const sx = vx0 + (Math.random()*cv.width|0);
          const sy = vy0 + (Math.random()*18|0);
          particles.push({x:sx, y:sy, vx:(Math.random()*2-1)*40, vy:(Math.random()*-30), life: 900+((Math.random()*600)|0)});
        }
      }
    }
    // integrate particles
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.life -= dt*1000;
      p.vy += 50*dt;
      p.x += p.vx*dt; p.y += p.vy*dt;
      if (p.life<=0) particles.splice(i,1);
    }
// ----- Edge actions -----
    if (state.pressEdge.has('Start')){ UI.start = !UI.start; if(UI.start){ UI.quick=false; ShopUI.open=false; } toast(UI.start?'Pause — Start Menu':'Resume'); }
    if (state.pressEdge.has('B') && UI.start){ UI.start=false; }

    if (UI.start){
      if (state.pressEdge.has('Up'))   UI.startIdx = (UI.startIdx + START_ITEMS.length - 1) % START_ITEMS.length;
      if (state.pressEdge.has('Down')) UI.startIdx = (UI.startIdx + 1) % START_ITEMS.length;
      if (state.pressEdge.has('A')){
        const choice = START_ITEMS[UI.startIdx];
        if (choice==='Resume' || choice==='Close'){ UI.start=false; }
        else if (choice==='Save (Slot 1)'){ saveGame(); }
        else if (choice==='Load (Slot 1)'){ loadGame(); }
        else if (choice==='New World'){ newWorld(); UI.start=false; }
        else if (choice==='Settings'){ Game.settings.seedEnabled=!Game.settings.seedEnabled; toast('Seeded RNG: '+(Game.settings.seedEnabled?'ON':'OFF')); }
        else if (choice==='Cheats'){ UI.start=false;
UI.quick=true;
if (typeof QUICK_TABS!=='undefined'){
  const idx = QUICK_TABS.indexOf('Cheats');
  quickTab = idx>=0 ? idx : 0;
} else { quickTab = 0; }
toast('Cheats menu'); }
      }
    } else {
      if (state.pressEdge.has('Select')){ UI.quick=!UI.quick; if(UI.quick) ShopUI.open=false; toast(UI.quick?'Quick panel':'Close panel'); }
      if (UI.quick){
        if (ShopUI.open){
          const list=shopItems();
          if (state.pressEdge.has('Left'))  ShopUI.mode = (ShopUI.mode==='buy'?'sell':'buy'), ShopUI.idx=0;
          if (state.pressEdge.has('Right')) ShopUI.mode = (ShopUI.mode==='buy'?'sell':'buy'), ShopUI.idx=0;
          if (state.pressEdge.has('Up'))   ShopUI.idx=(ShopUI.idx+(list.length||1)-1)%(list.length||1);
          if (state.pressEdge.has('Down')) ShopUI.idx=(ShopUI.idx+1)%(list.length||1);
          if (state.pressEdge.has('A')){ ShopUI.mode==='buy' ? buySelected() : sellSelected(); }

          if (state.pressEdge.has('B') || state.pressEdge.has('Start')){ closeShop(); }
        } else {
          if (state.pressEdge.has('Left')) quickTab=(quickTab+QUICK_TABS.length-1)%QUICK_TABS.length; if (quickTab===0 && Game.inventory.length) invIdx = Math.min(invIdx, Game.inventory.length-1);
          if (state.pressEdge.has('Right')) quickTab=(quickTab+1)%QUICK_TABS.length;
          // Cheats tab navigation + Run
          if (QUICK_TABS && QUICK_TABS[quickTab]==='Cheats'){
            if (state.pressEdge.has('Up'))   CheatsUI.idx = (CheatsUI.idx + CheatsUI.list.length - 1) % CheatsUI.list.length;
            if (state.pressEdge.has('Down')) CheatsUI.idx = (CheatsUI.idx + 1) % CheatsUI.list.length;
            if (state.pressEdge.has('A'))    applyCheat(CheatsUI.list[CheatsUI.idx].code);
          }

          if (quickTab===2){
            // Journal pals selection + drop
            const L = Game.companions.length||0;
            if (state.pressEdge.has('Up'))   JournalUI.idx = (JournalUI.idx + L - 1) % (L||1);
            if (state.pressEdge.has('Down')) JournalUI.idx = (JournalUI.idx + 1) % (L||1);
            if (state.pressEdge.has('A')) dropPalAt(JournalUI.idx);
          } else if (quickTab===0){
            // Inventory scrolling + equip/unequip
            const L = Game.inventory.length||0;
            if (state.pressEdge.has('Up'))   invIdx = (invIdx + L - 1) % (L||1);
            if (state.pressEdge.has('Down')) invIdx = (invIdx + 1) % (L||1);
            if (state.pressEdge.has('A')){
              const s=Game.inventory[invIdx];
              if (s && ITEMS[s.id]?.cat==='consumable'){
                if (s.id==='pot_heal_s'){
                  const m=Game.stats.hpMax||100; Game.stats.hp=Math.min(m,(Game.stats.hp||m)+15);
                  s.qty-=1; if(s.qty<=0){ Game.inventory=Game.inventory.filter(x=>x.qty>0); }
                  toast('Healed +15');
                } else if (s.id==='pot_heal_s_plus'){
                  const m=Game.stats.hpMax||100; Game.stats.hp=Math.min(m,(Game.stats.hp||m)+30);
                  s.qty-=1; if(s.qty<=0){ Game.inventory=Game.inventory.filter(x=>x.qty>0); }
                  toast('Healed +30');
                } else { toast('Used '+s.id); s.qty-=1; if(s.qty<=0){ Game.inventory=Game.inventory.filter(x=>x.qty>0); } }
              } else {
                equipFromInventory(invIdx);
              }
            }
          } else if (quickTab===1){ // Crafting
            const nearWB = npcs && npcs.some(n=>n.role==='workbench' && Math.hypot((n.x+13)-(player.x+13),(n.y+13)-(player.y+13))<64);
const list = RECIPES.filter(r=>(!r.requiresFlag || Game.flags[r.requiresFlag]) && (r.bench==='work') && (!r.biome || r.biome===Game.currentBiome));
            if (state.pressEdge.has('Up')) craftIdx = (craftIdx+list.length-1)%(list.length||1);
            if (state.pressEdge.has('Down')) craftIdx = (craftIdx+1)%(list.length||1);
            if (state.pressEdge.has('A')){ const r = list[craftIdx]||null; if(!r){/* no-op */}else if(!nearWB){ toast('Find a workbench'); } else if (hasItems(r.needs)) craft(r.out); else toast('Need mats'); }
          }
        }
      } else {
        // cycle active pal
        if (state.pressEdge.has('B')){
          const i = Math.max(0, Game.companions.findIndex(p=>p.isActive));
          if (Game.companions.length){ Game.companions[i].isActive=false; const nxt=(i+1)%Game.companions.length; Game.companions[nxt].isActive=true; toast('Active pal: '+Game.companions[nxt].id); }
        }

        if (state.pressed.has('A')) aHoldT += dt; else aHoldT = 0;
        if (state.pressEdge.has('A') || aHoldT>0.20){
  try{
  // Guardian Pedestal priority (forest)
  let __handled = false;
  if (Game.currentBiome==='forest' && (!Game.flags.owl_trial_pass || !Game.flags.q_forest_main_done) && GuardianTrial.pedestal.x!=null){
    if (distToPlayer(GuardianTrial.pedestal.x, GuardianTrial.pedestal.y) <= 64){
      if (!GuardianTrial.active){
        startGuardianTrial();
        __handled = true;
      }
    }
  }
  if (!__handled){

          // nearest portal?
          let idx = nearest(portals,60);
          if (idx!==-1){
            const to = portals[idx].to; travelTo(to);
          }
          
          else if ((idx=nearest(chests,36))!==-1){
            const c = chests[idx];
            if (!c.opened){
              c.opened=true;
              // loot burst
              const burst = 2 + (Math.random()*3|0); // 2-4
              for(let i=0;i<burst;i++){
                const roll = Math.random();
                const id = roll<0.2?'coins' : roll<0.55?'wood' : roll<0.8?'berry' : 'mushroom';
                if (id==='coins') Game.coins = (Game.coins||0) + (10 + (Math.random()*30|0));
                else addItem(id,1);
              }
              // particles burst
              for(let i=0;i<16;i++){
                particles.push({x:c.x*TILE+TILE/2, y:c.y*TILE+TILE/2, vx:(Math.random()*2-1)*80, vy:(-40 - Math.random()*60), life:600+((Math.random()*400)|0)});
              }
              toast('Chest opened!');
            } else { toast('Empty chest'); }
          }
    
          else if (Game.currentBiome==='desert' && DESERT.interactNearby()) { /* desert handled */ }else if ((idx=nearest(items,64))!==-1){
            const gotId = items[idx].id;
            addItem(gotId,1);
            // forage bonus from active pal
            const perk=PALS[activePal()?.id]?.perks||{};
            if (typeof perk.forage_bonus==='number' && RNG.chance(perk.forage_bonus)) addItem(gotId,1);
            items.splice(idx,1); toast('Picked up');
          }
          else if ((idx=nearest(npcs,64))!==-1){
            const n=npcs[idx];
            if (n.role==='elder'){
              if (questState('q_meadow_main')==='locked') beginQuest('q_meadow_main');
              else if (questState('q_meadow_main')==='active') tryTurnIn('q_meadow_main');
              else toast('Elder: "Good work!"');
            } else if (n.role==='ranger'){
              if (questState('q_forest_main')==='locked') beginQuest('q_forest_main');
              else if (questState('q_forest_main')==='active') tryTurnIn('q_forest_main');
              else toast('Ranger: "Trails are clear. Thanks."');
            } else if (n.role==='workbench'){ toast('Craft via Select → Crafting'); }
            else if (n.role==='market'){ UI.quick=true; openShop(n.shopId||'meadow_village'); }
          }
          
else if ((function(){
  let range = 64;
  let e = Game.equipped && Game.equipped.tool;
  if (e && e.id==='net_basic' && (e.usesLeft||0)>0){ range = 96; }
  const i = nearest(pals, range);
  if (i===-1) return false;
  // Disallow extended range for boar boss
  const target = pals[i];
  const cx = player.x+player.w/2, cy=player.y+player.h/2;
  const d = Math.hypot((target.x+target.w/2)-cx, (target.y+target.h/2)-cy);
  if (target.id==='boar' && target.boss && d>64) return false;
  if (target.id==='boar' && target.boss && typeof BoarBoss!=='undefined' && BoarBoss.active && BoarBoss.hp>0) return false;
  idx = i; return true;
})()){
  if (Game.companions.length>=MAX_PARTY) toast('Party full');
  else {
    const ref = pals[idx];
    const isBoss = !!(ref.id==='boar' && ref.boss);
    const useNet = (Game.equipped && Game.equipped.tool && Game.equipped.tool.id==='net_basic' && (Game.equipped.tool.usesLeft||0)>0 && !isBoss);
    deferAction(function(){
      try{
        const i = pals.indexOf(ref);
        if (i===-1) return;
        const pid = pals[i].id;
        pals.splice(i,1);
        Game.companions.push({id:pid});
        Game.discovered.add(pid);
        if (pid==='sprite') Game.flags.captured_sprite=true;
        if (pid==='owllet') Game.flags.captured_owllet=true;
        if (pid==='boar' && Game.flags.boarBossActive){ Game.flags.boar_miniboss_defeated=true; Game.flags.boarBossActive=false; toast('Defeated the rampaging boar!'); }
        if (useNet){
          let tool = Game.equipped.tool;
          if (tool && tool.usesLeft!=null){
            tool.usesLeft -= 1;
            if (tool.usesLeft<=0){ Game.equipped.tool = null; toast('Net broke'); }
          }
        }
        toast('Captured '+pid);
      }catch(e){};
    });
  }
} else maybeToastNoInteract();

} // end !__handled

  }catch(e){ try{ maybeToastNoInteract(); }catch(_){} }
}

      }
    }

    state.pressEdge.clear();

    // Render
    const ctx = activeCtx(); const w=activeCanvas().width, h=activeCanvas().height;
    drawShell(ctx,w,h); drawWorld(ctx,w,h);

    
// Flush deferred actions (apply after render)
try{ if(DefQ.length){ const q=DefQ.splice(0); for(const fn of q){ try{ fn(); }catch(e){} } } }catch(e){}
status(['mode: '+state.mode,'biome: '+Game.currentBiome,'pressed: ['+(Array.from(state.pressed).join(', ')||' ')+']','fps~: '+(dt? (1/dt|0):'—')].join('  |  '));
    requestAnimationFrame(frame);
  
    if (Game.currentBiome==='desert' && DESERT && DESERT._trialDraw) DESERT._trialDraw(ctx);
}

  // ---------- Travel ----------
  function travelTo(targetBiome){ if (targetBiome===Game.currentBiome) return; Game.currentBiome = targetBiome;
    try{ if (targetBiome==='desert'){ Game.quests = Game.quests||{}; if (!Game.quests['q_desert_main']) Game.quests['q_desert_main']='active'; } }catch(_){} if (targetBiome==='forest'){ regenForest(); }
    else if (targetBiome==='desert'){ regenDesert(); }
    else if (targetBiome==='wetlands'){ regenWetlands(); }
    else { regenMeadow(); }
    // put player near the respective portal landing
    const trackY=(H*0.575)|0;
    player.y = trackY*TILE;
    player.x = (targetBiome==='forest' || targetBiome==='wetlands') ? (12*TILE) : ((W-12)*TILE);
    seedByBiome(); ensureDesertReturnPortal();
    toast('Travelled to '+targetBiome);
  }

  // ---------- Boot ----------
  RNG.reseed(0xC0FFEE);
  regenMeadow();
  seedByBiome();
  requestAnimationFrame(frame);

  // Expose hooks (debug)
  window.WildPals = { items, npcs, pals, portals, player, Game, toast, saveGame, loadGame, newWorld, RNG,
    regenMeadow, regenForest, seedByBiome, travelTo, openShop };
})();

// Data-only helper to increment owl riddle progress
function solveOwlRiddle(){ Game.flags.owl_riddle_count = (Game.flags.owl_riddle_count||0)+1; }

function _hashNoise(x,y){
  let n = (x*73856093) ^ (y*19349663); n = (n<<13) ^ n;
  return ((1.0 + (n*(n*n*15731 + 789221) + 1376312589) & 0x7fffffff) / 2147483648.0);
}

function _hexToRGBArr(hex){
  try{ return [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)]; }
  catch(_){ return [32,49,79]; }
}
function _shade(hex, k){
  var a=_hexToRGBArr(hex); var r=(a[0]*(1-k))|0, g=(a[1]*(1-k))|0, b=(a[2]*(1-k))|0;
  return 'rgb('+r+','+g+','+b+')';
}
</script>
<script>
// === Player sprite ===
// Uses the same blocky style as your shopHUD code, but with the local canvas ctx.
function drawPlayer(ctx, px, py){
  // Keep the cheat/invisibility behavior if you want it:
  if (typeof playerInvisible !== 'undefined' && playerInvisible) return;

  // head
  ctx.fillStyle = '#eaeaea'; ctx.fillRect(px+8,  py+6,  8, 8);
  // torso
  ctx.fillStyle = '#3a75c4'; ctx.fillRect(px+6,  py+14, 12, 8);
  // legs
  ctx.fillStyle = '#2b2b2b'; ctx.fillRect(px+6,  py+22,  5, 2);
  ctx.fillStyle = '#2b2b2b'; ctx.fillRect(px+13, py+22,  5, 2);
  // eye
  ctx.fillStyle = '#000000'; ctx.fillRect(px+11, py+9,   2, 2);
}

</script>
<script>
// Guard to suppress "Nothing to interact with" when A started the Guardian Trial.
window.__AHandledPedestal = false;
function maybeToastNoInteract(){ if (!window.__AHandledPedestal) toast('Nothing to interact with'); }
</script>


<div id="introOverlay" role="dialog" aria-modal="true" tabindex="0">
  <div class="box">
    <h1>Wild Pals — The Palbond</h1>
    <p>Long ago, the Palbond Stone kept the world in harmony.</p>
    <p>When it shattered, the guardians turned apart. The biomes drifted into silence.</p>
    <p>You alone can bond with wild pals and mend the rift.</p>
    <p class="cta">Your journey begins now — Seek the <strong>Wetlands</strong> to start the true path.</p>
    <div class="hint">Press Start / Select / A — or Enter / Space — or tap anywhere to begin</div>
  </div>
</div>



<script id="introOverlayScript">
(function(){
  if (window.__INTRO_WIRED__) return; window.__INTRO_WIRED__ = true;
  var overlay = document.getElementById('introOverlay');
  if (!overlay) return;
  // Focus so keyboard works without clicking first
  overlay.setAttribute('tabindex','0');
  try{ overlay.focus({preventScroll:true}); }catch(_){ try{ overlay.focus(); }catch(__){} }
  window.__INTRO_ACTIVE__ = true;

  function startGame(){
    overlay.style.display = 'none';
    window.__INTRO_ACTIVE__ = false;
    try{ if (typeof toast==='function') toast('Begin.'); }catch(e){}
  }
  function introActive(){ return (overlay && overlay.style.display !== 'none'); }
  function stop(e){ try{ e.preventDefault(); e.stopPropagation(); }catch(_){ } }

  // Pointer/touch/mouse handlers on the overlay itself
  ['click','pointerdown','pointerup','touchstart','touchend','mousedown','mouseup'].forEach(function(ev){
    overlay.addEventListener(ev, function(e){ stop(e); if (introActive()) startGame(); }, {passive:false});
  });

  // Fallback on document (in case overlay misses an event)
  ['pointerdown','pointerup','touchstart','touchend','click','mousedown','mouseup'].forEach(function(ev){
    window.addEventListener(ev, function(e){ if (introActive()){ stop(e); startGame(); } }, {passive:false});
  });

  // Buttons present in your shell (portrait + landscape) — click to start
  function hook(id){ var el=document.getElementById(id); if (el) el.addEventListener('click', function(e){ stop(e); startGame(); }, {passive:false}); }
  ['btnStart','btnSelect','btnA','btnB','btnZ','lStart','lSelect','lA','lB','lZ'].forEach(hook);
  // Canvas clicks also start
  var cv = document.getElementById('game'); if (cv) cv.addEventListener('click', function(e){ if (introActive()){ stop(e); startGame(); } }, {passive:false});
  var cv2= document.getElementById('gameLandscape'); if (cv2) cv2.addEventListener('click', function(e){ if (introActive()){ stop(e); startGame(); } }, {passive:false});

  
  // Keyboard: Q/E/WASD/Enter/Space/Arrow keys
  window.addEventListener('keydown', function(e){
    var ok = (
      e.code==='KeyQ' || e.code==='KeyE' ||
      e.code==='KeyW' || e.code==='KeyA' || e.code==='KeyS' || e.code==='KeyD' ||
      e.code==='Enter' || e.code==='Space' ||
      e.code==='ArrowUp' || e.code==='ArrowDown' || e.code==='ArrowLeft' || e.code==='ArrowRight'
    );
    if (ok && introActive()){ stop(e); startGame(); }
  }, {passive:false});
  // Safety auto-dismiss
  setTimeout(function(){ if (introActive()) startGame(); }, 12000);
})();

</script>


</body>
</html>